<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <title>Finance Calendar</title>
  <link rel="stylesheet" href="./fin-theme.css" />
</head>
<body>
  <div id="app" class="app layout">
    <header id="topbar" class="topbar">
      <div class="topbar__left">
        <button id="btnSidebarToggle" class="btn btn--ghost" type="button">☰ Filtri</button>
        <button id="btnPrev" class="btn btn--icon btn--ghost" type="button" aria-label="Precedente">‹</button>
        <button id="btnToday" class="btn btn--ghost" type="button">Oggi</button>
        <button id="btnNext" class="btn btn--icon btn--ghost" type="button" aria-label="Successivo">›</button>
        <span id="rangeLabel" class="topbar__range">—</span>
      </div>

      <div class="topbar__right">
        <span id="viewSwitch" class="segmented" aria-label="Vista">
          <button class="btn btn--seg" type="button" data-view="day" aria-pressed="false">Giorno</button>
          <button class="btn btn--seg" type="button" data-view="week" aria-pressed="false">Settimana</button>
          <button class="btn btn--seg" type="button" data-view="month" aria-pressed="true">Mese</button>
          <button class="btn btn--seg" type="button" data-view="year" aria-pressed="false">Anno</button>
        </span>

        <span id="densitySwitch" class="segmented" aria-label="Densità">
          <button class="btn btn--seg" type="button" data-density="comfort" aria-pressed="true">Comfort</button>
          <button class="btn btn--seg" type="button" data-density="compact" aria-pressed="false">Compatta</button>
        </span>

        <button id="btnNewEvent" class="btn btn--primary" type="button">＋ Nuovo</button>
      </div>
    </header>

    <aside id="sidebar" class="sidebar" data-open="true">
      <div class="sidebar__header">
        <h2 class="sidebar__title">Filtri</h2>
      </div>

      <section class="sidebar__section">
        <label class="label" for="searchInput">Cerca</label>
        <input id="searchInput" type="search" autocomplete="off" placeholder="Titolo, categoria, note…" />
      </section>

      <section class="sidebar__section">
        <label class="label" for="categorySelect">Categoria</label>
        <select id="categorySelect">
          <option value="all">Tutte</option>
        </select>
      </section>

      <section class="sidebar__section">
        <div class="toggle">
          <div class="toggle__label">Entrate</div>
          <input id="toggleIncome" type="checkbox" checked />
        </div>
        <div style="height:10px"></div>
        <div class="toggle">
          <div class="toggle__label">Uscite</div>
          <input id="toggleExpense" type="checkbox" checked />
        </div>
        <div style="height:10px"></div>
        <div class="toggle">
          <div class="toggle__label">Altro</div>
          <input id="toggleOther" type="checkbox" checked />
        </div>
      </section>

      <section class="sidebar__section">
        <div class="sidebar__section-title" style="margin-bottom:10px;">
          <span>Range</span>
          <small>Filtro date</small>
        </div>

        <div id="rangePresets" class="pill-row" style="margin-bottom:10px;">
          <button class="btn btn--pill" type="button" data-preset="all" aria-pressed="true">Da inizio</button>
          <button class="btn btn--pill" type="button" data-preset="from" aria-pressed="false">Da data</button>
          <button class="btn btn--pill" type="button" data-preset="between" aria-pressed="false">Tra date</button>
        </div>

        <label class="label" for="fromDate">Da</label>
        <input id="fromDate" type="date" />

        <label class="label" for="toDate">A</label>
        <input id="toDate" type="date" />

        <div style="height:12px"></div>
        <div class="pill-row">
          <button id="btnApplyFilters" class="btn btn--ghost" type="button">Applica</button>
          <button id="btnClearFilters" class="btn btn--ghost" type="button">Reset</button>
        </div>
      </section>

      <section class="sidebar__section">
        <div class="sidebar__section-title" style="margin-bottom:10px;">
          <span>Backup</span>
          <small>Import/Export</small>
        </div>

        <div class="pill-row">
          <button id="btnExport" class="btn btn--ghost" type="button">Esporta JSON</button>
        </div>

        <div style="height:10px"></div>

        <label class="label" for="importFile">Importa JSON</label>
        <input id="importFile" type="file" accept="application/json" />
        <small class="help">Import crea eventi via API e ricarica.</small>
      </section>

      <section id="statsPanel" class="sidebar__section">
        <div class="sidebar__section-title">
          <span>Stats</span>
          <small id="statsMeta">—</small>
        </div>

        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-card__label">Saldo attuale (fino a oggi)</div>
            <div id="statCurrentBalance" class="stat-card__value">—</div>
            <div id="statCurrentBalanceMeta" class="stat-card__sub">—</div>
          </div>

          <div class="stat-card">
            <div class="stat-card__label">Saldo alla data</div>
            <div id="statBalanceAtDate" class="stat-card__value">—</div>
            <div class="stat-card__sub" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px">
              <span style="color:var(--muted);font-weight:700">Data</span>
              <input id="balanceAtDate" type="date" />
            </div>
          </div>

          <div class="stat-card">
            <div class="stat-card__label">Netto (nel range visibile)</div>
            <div id="statNet" class="stat-card__value">—</div>
            <div class="stat-card__sub">
              <span id="statIncomeCount">—</span> · <span id="statExpenseCount">—</span>
            </div>
          </div>

          <div class="stat-card">
            <div class="stat-card__label">Entrate (nel range visibile)</div>
            <div id="statIncome" class="stat-card__value">—</div>
            <div class="stat-card__sub">Somma entrate nella vista</div>
          </div>

          <div class="stat-card">
            <div class="stat-card__label">Uscite (nel range visibile)</div>
            <div id="statExpense" class="stat-card__value">—</div>
            <div class="stat-card__sub">Somma uscite nella vista</div>
          </div>
        </div>

        <hr />

        <div class="sidebar__section-title" style="margin-bottom:10px;">
          <span>Snapshot</span>
          <small>ultimi 14 giorni (range visibile)</small>
        </div>

        <div id="snapshotList" class="snapshot-list" role="list"></div>
      </section>
    </aside>

    <main id="main" class="main">
      <header class="main__header">
        <h1 id="calendarTitle">Calendario</h1>
        <p id="calendarSubtitle">—</p>
      </header>

      <section id="calendarView" class="calendar" data-view="month" data-density="comfort"></section>
    </main>

    <aside id="eventDrawer" class="drawer" aria-hidden="true">
      <div class="drawer__header">
        <h2 id="drawerTitle" style="margin:0;font-size:var(--fs-5);letter-spacing:.2px;">Evento</h2>
        <div class="drawer__actions">
          <button id="btnEditEvent" class="btn btn--ghost" type="button">Modifica</button>
          <button id="btnDeleteEvent" class="btn btn--ghost" type="button">Elimina</button>
          <button id="btnCloseDrawer" class="btn btn--icon btn--ghost" type="button" aria-label="Chiudi">✕</button>
        </div>
      </div>
      <div id="eventDetail" class="drawer__body"></div>
    </aside>

    <dialog id="eventModal">
      <div class="modal__header">
        <h2 id="eventModalTitle" style="margin:0;font-size:var(--fs-5);letter-spacing:.2px;">Evento</h2>
        <button id="btnCloseModal" class="btn btn--icon btn--ghost" type="button" aria-label="Chiudi">✕</button>
      </div>

      <form id="eventForm" method="dialog" autocomplete="off">
        <div class="form-field">
          <label class="label" for="evtTitle">Titolo *</label>
          <input id="evtTitle" type="text" required />
        </div>

        <div class="form-field">
          <label class="label" for="evtCategory">Categoria</label>
          <input id="evtCategory" type="text" list="categoryList" />
          <datalist id="categoryList"></datalist>
        </div>

        <div class="form-field">
          <label class="label" for="evtType">Tipo</label>
          <select id="evtType">
            <option value="income">Entrata</option>
            <option value="expense">Uscita</option>
            <option value="other">Altro</option>
          </select>
        </div>

        <div class="form-field">
          <label class="label" for="evtAmount">Importo</label>
          <input id="evtAmount" type="number" step="0.01" />
        </div>

        <div class="form-field">
          <label class="label" for="evtStart">Data *</label>
          <input id="evtStart" type="date" required />
        </div>

        <div class="form-field">
          <label class="label" for="evtTime">Ora</label>
          <input id="evtTime" type="time" />
        </div>

        <div class="form-field">
          <label class="label" for="evtRecurrence">Ricorrenza</label>
          <select id="evtRecurrence">
            <option value="none">Nessuna</option>
            <option value="monthly">Mensile</option>
            <option value="yearly">Annuale</option>
            <option value="custom_days">Ogni N giorni</option>
          </select>
        </div>

        <div id="recDaysField" class="form-field" style="display:none;">
          <label class="label" for="evtRecurrenceDays">Ogni quanti giorni</label>
          <input id="evtRecurrenceDays" type="number" min="1" step="1" />
        </div>

        <div class="form-field" style="grid-column:1 / -1;">
          <label class="label" style="display:flex;align-items:center;gap:10px;margin:0;">
            <input id="evtPinned" type="checkbox" />
            <span>In evidenza</span>
          </label>
        </div>

        <div class="form-field" style="grid-column:1 / -1;">
          <label class="label" for="evtNotes">Note</label>
          <textarea id="evtNotes"></textarea>
        </div>
      </form>

      <div class="modal__footer">
        <button id="btnCancelEvent" class="btn btn--ghost" type="button">Annulla</button>
        <button class="btn btn--primary" type="submit" form="eventForm">Salva</button>
      </div>
    </dialog>
  </div>

  <script>
    (() => {
      "use strict";

      const $ = (s, r = document) => r.querySelector(s);
      const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));

      const pad2 = (n) => String(n).padStart(2, "0");
      const toISODate = (d) => {
        const dt = (d instanceof Date) ? d : new Date(d);
        return `${dt.getFullYear()}-${pad2(dt.getMonth() + 1)}-${pad2(dt.getDate())}`;
      };
      const fromISODate = (iso) => {
        const [y, m, d] = iso.split("-").map(Number);
        return new Date(y, m - 1, d);
      };
      const startOfDay = (d) => new Date(d.getFullYear(), d.getMonth(), d.getDate());
      const endOfDay = (d) => new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);
      const addDays = (d, n) => {
        const x = new Date(d);
        x.setDate(x.getDate() + n);
        return x;
      };
      const addMonths = (d, n) => {
        const x = new Date(d);
        const day = x.getDate();
        x.setMonth(x.getMonth() + n);
        while (x.getDate() !== day && x.getDate() > 1) x.setDate(x.getDate() - 1);
        return x;
      };
      const addYears = (d, n) => {
        const x = new Date(d);
        x.setFullYear(x.getFullYear() + n);
        return x;
      };
      const formatMoney = (val, currency = "EUR") =>
        new Intl.NumberFormat("it-IT", { style: "currency", currency }).format(Number(val || 0));
      const formatDateHuman = (d) =>
        new Intl.DateTimeFormat("it-IT", { weekday: "short", year: "numeric", month: "long", day: "2-digit" }).format(d);
      const formatMonthHuman = (d) =>
        new Intl.DateTimeFormat("it-IT", { year: "numeric", month: "long" }).format(d);
      const formatRangeLabel = (start, end, view) => {
        if (view === "day") return formatDateHuman(start);
        if (view === "week") return `${formatDateHuman(start)} – ${formatDateHuman(end)}`;
        if (view === "month") return formatMonthHuman(start);
        if (view === "year") return String(start.getFullYear());
        return `${formatDateHuman(start)} – ${formatDateHuman(end)}`;
      };
      const startOfWeek = (d) => {
        const x = startOfDay(d);
        const day = (x.getDay() + 6) % 7;
        return addDays(x, -day);
      };
      const endOfWeek = (d) => endOfDay(addDays(startOfWeek(d), 6));
      const startOfMonth = (d) => new Date(d.getFullYear(), d.getMonth(), 1);
      const endOfMonth = (d) => endOfDay(new Date(d.getFullYear(), d.getMonth() + 1, 0));
      const startOfYear = (d) => new Date(d.getFullYear(), 0, 1);
      const endOfYear = (d) => endOfDay(new Date(d.getFullYear(), 11, 31));
      const clampDateToRange = (d, min, max) =>
        new Date(Math.min(Math.max(d.getTime(), min.getTime()), max.getTime()));
      const uid = () => crypto.randomUUID?.() || `id_${Math.random().toString(16).slice(2)}_${Date.now()}`;

      const API_BASE = "https://iamemanuele.pythonanywhere.com/api";
      const API = {
        async request(path, { method = "GET", body } = {}) {
          const res = await fetch(`${API_BASE}${path}`, {
            method,
            headers: body === undefined ? { "Accept": "application/json" } : { "Accept": "application/json", "Content-Type": "application/json" },
            credentials: "omit",
            body: body === undefined ? undefined : JSON.stringify(body)
          });
          const ct = res.headers.get("content-type") || "";
          const data = ct.includes("application/json") ? await res.json().catch(() => null) : await res.text().catch(() => null);
          if (!res.ok) throw new Error((data && data.error) ? data.error : `HTTP ${res.status}`);
          return data;
        },
        listEvents(params = {}) {
          const qs = new URLSearchParams(params).toString();
          return this.request(`/events${qs ? `?${qs}` : ""}`);
        },
        createEvent(payload) { return this.request(`/events`, { method: "POST", body: payload }); },
        updateEvent(id, payload) { return this.request(`/events/${encodeURIComponent(id)}`, { method: "PUT", body: payload }); },
        deleteEvent(id) { return this.request(`/events/${encodeURIComponent(id)}`, { method: "DELETE" }); },
        deleteSeries(seriesId) { return this.request(`/series/${encodeURIComponent(seriesId)}`, { method: "DELETE" }); },
        deleteSeriesFrom(seriesId, fromISO) { return this.request(`/series/${encodeURIComponent(seriesId)}/from/${encodeURIComponent(fromISO)}`, { method: "DELETE" }); },
        getSettings() { return this.request(`/settings`); },
        saveSettings(payload) { return this.request(`/settings`, { method: "PUT", body: payload }); }
      };

      const defaultSettings = {
        view: "month",
        density: "comfort",
        rangeMode: "all",
        fromDate: "",
        toDate: "",
        search: "",
        category: "all",
        includeIncome: true,
        includeExpense: true,
        includeOther: true,
        sidebarOpen: true,
        initialBalance: 3412,
        currency: "EUR",
        balanceAtDate: ""
      };

      const state = {
        settings: structuredClone(defaultSettings),
        events: [],
        anchorDate: startOfDay(new Date()),
        selectedEventId: null,
        draftEventId: null
      };

      let settingsTimer = null;
      const saveSettings = () => {
        clearTimeout(settingsTimer);
        settingsTimer = setTimeout(() => API.saveSettings(state.settings).catch(() => {}), 250);
      };

      const normalizeEvent = (e) => ({
        ...e,
        time: e.time || "",
        notes: e.notes || "",
        pinned: !!e.pinned,
        recurrence: e.recurrence || "none",
        recurrenceDays: e.recurrenceDays ?? null,
        seriesId: e.seriesId ?? null,
        seriesMaster: !!e.seriesMaster
      });

      const loadEventsFromBackend = async () => {
        const data = await API.listEvents();
        const arr = Array.isArray(data) ? data : (data?.events || []);
        return arr.map(normalizeEvent);
      };

      const getTrackingBounds = (events) => {
        const dates = events.map(e => e?.date).filter(Boolean).sort();
        if (!dates.length) {
          const t = startOfDay(new Date());
          return [t, t];
        }
        return [fromISODate(dates[0]), fromISODate(dates[dates.length - 1])];
      };

      const getEffectiveRangeForView = () => {
        const v = state.settings.view;
        const a = state.anchorDate;
        if (v === "day") return [startOfDay(a), endOfDay(a)];
        if (v === "week") return [startOfWeek(a), endOfWeek(a)];
        if (v === "month") return [startOfMonth(a), endOfMonth(a)];
        if (v === "year") return [startOfYear(a), endOfYear(a)];
        return [startOfMonth(a), endOfMonth(a)];
      };

      const getUserRangeConstraints = () => {
        const { rangeMode, fromDate, toDate } = state.settings;
        const [minTrack, maxTrack] = getTrackingBounds(state.events);
        if (rangeMode === "all") return [minTrack, maxTrack];
        if (rangeMode === "from") {
          const from = fromDate ? fromISODate(fromDate) : minTrack;
          return [startOfDay(from), maxTrack];
        }
        if (rangeMode === "between") {
          const from = fromDate ? fromISODate(fromDate) : minTrack;
          const to = toDate ? fromISODate(toDate) : maxTrack;
          const a = startOfDay(from);
          const b = endOfDay(to);
          return a <= b ? [a, b] : [b, a];
        }
        return [minTrack, maxTrack];
      };

      const passesTypeFilter = (e) => {
        if (e.type === "income" && !state.settings.includeIncome) return false;
        if (e.type === "expense" && !state.settings.includeExpense) return false;
        if (e.type === "other" && !state.settings.includeOther) return false;
        return true;
      };

      const passesCategoryFilter = (e) => {
        const cat = (state.settings.category || "all").toLowerCase();
        if (cat === "all") return true;
        return (e.category || "").toLowerCase() === cat;
      };

      const passesSearchFilter = (e) => {
        const q = (state.settings.search || "").trim().toLowerCase();
        if (!q) return true;
        const hay = `${e.title} ${e.category} ${e.notes}`.toLowerCase();
        return hay.includes(q);
      };

      const passesUserRange = (e) => {
        const [uStart, uEnd] = getUserRangeConstraints();
        const d = fromISODate(e.date);
        return d >= uStart && d <= uEnd;
      };

      const getFilteredEvents = () =>
        state.events
          .filter(e => e?.date)
          .filter(passesTypeFilter)
          .filter(passesCategoryFilter)
          .filter(passesSearchFilter)
          .filter(passesUserRange)
          .sort((a, b) => (a.date + (a.time || "")) < (b.date + (b.time || "")) ? -1 : 1);

      const signedAmount = (e) => {
        const amt = Number(e.amount || 0);
        if (!amt) return 0;
        if (e.type === "income") return +amt;
        if (e.type === "expense") return -amt;
        return 0;
      };

      const computeBalanceUpTo = (events, initialBalance, dateISO) => {
        const cutoff = fromISODate(dateISO);
        let bal = Number(initialBalance || 0);
        for (const e of events) {
          if (!e?.date) continue;
          const d = fromISODate(e.date);
          if (d <= endOfDay(cutoff)) bal += signedAmount(e);
        }
        return bal;
      };

      const computeSnapshots = (eventsInRange, initialBalance, rangeStart, rangeEnd) => {
        const days = [];
        const map = new Map();
        for (const e of eventsInRange) map.set(e.date, (map.get(e.date) || 0) + signedAmount(e));
        let bal = Number(initialBalance || 0);
        let cur = startOfDay(rangeStart);
        const last = startOfDay(rangeEnd);
        while (cur <= last) {
          const iso = toISODate(cur);
          bal += (map.get(iso) || 0);
          days.push({ date: iso, balance: bal });
          cur = addDays(cur, 1);
        }
        return days;
      };

      const computeVisibleStats = (filtered) => {
        const [viewStart, viewEnd] = getEffectiveRangeForView();
        const [userStart, userEnd] = getUserRangeConstraints();
        const rangeStart = new Date(Math.max(viewStart.getTime(), userStart.getTime()));
        const rangeEnd = new Date(Math.min(viewEnd.getTime(), userEnd.getTime()));
        const inVisible = filtered.filter(e => {
          const d = fromISODate(e.date);
          return d >= startOfDay(rangeStart) && d <= endOfDay(rangeEnd);
        });
        const incomeEvents = inVisible.filter(e => e.type === "income");
        const expenseEvents = inVisible.filter(e => e.type === "expense");
        const incomeSum = incomeEvents.reduce((s, e) => s + Number(e.amount || 0), 0);
        const expenseSum = expenseEvents.reduce((s, e) => s + Number(e.amount || 0), 0);
        const net = incomeSum - expenseSum;
        const snapshots = computeSnapshots(inVisible, state.settings.initialBalance, startOfDay(rangeStart), startOfDay(rangeEnd));
        return { rangeStart, rangeEnd, incomeSum, expenseSum, net, incomeCount: incomeEvents.length, expenseCount: expenseEvents.length, snapshots };
      };

      const daysInMonth = (y, m) => new Date(y, m + 1, 0).getDate();

      const addMonthsKeepingDay = (baseDate, monthsToAdd, anchorDay) => {
        const y0 = baseDate.getFullYear();
        const m0 = baseDate.getMonth();
        const targetMonth = m0 + monthsToAdd;
        const y = y0 + Math.floor(targetMonth / 12);
        const m = ((targetMonth % 12) + 12) % 12;
        const dim = daysInMonth(y, m);
        const day = Math.min(anchorDay, dim);
        return new Date(y, m, day);
      };

      const addYearsKeepingDay = (baseDate, yearsToAdd, anchorMonthIndex0, anchorDay) => {
        const y = baseDate.getFullYear() + yearsToAdd;
        const m = anchorMonthIndex0;
        const dim = daysInMonth(y, m);
        const day = Math.min(anchorDay, dim);
        return new Date(y, m, day);
      };

      const RECURRENCE_DEFAULTS = { monthlyMonths: 24, yearlyYears: 5, customDaysSpan: 365 };

      const defaultRecurrenceUntilISO = (startISO, mode) => {
        const start = fromISODate(startISO);
        const anchorDay = start.getDate();
        const anchorMonth = start.getMonth();
        if (mode === "monthly") return toISODate(addMonthsKeepingDay(start, RECURRENCE_DEFAULTS.monthlyMonths, anchorDay));
        if (mode === "yearly") return toISODate(addYearsKeepingDay(start, RECURRENCE_DEFAULTS.yearlyYears, anchorMonth, anchorDay));
        if (mode === "custom_days") return toISODate(addDays(start, Math.max(1, Number(RECURRENCE_DEFAULTS.customDaysSpan || 365))));
        return startISO;
      };

      const buildOccurrenceDates = (master, untilISO) => {
        const out = [];
        const mode = master.recurrence || "none";
        if (mode === "none") return out;
        const anchor = fromISODate(master.date);
        const anchorDay = anchor.getDate();
        const anchorMonth = anchor.getMonth();
        const until = fromISODate(untilISO);
        let guard = 0;

        if (mode === "custom_days") {
          const stepDays = Number(master.recurrenceDays || 0);
          if (!stepDays || stepDays < 1) return out;
          let cur = addDays(anchor, stepDays);
          while (cur <= until && guard < 20000) {
            out.push(toISODate(cur));
            cur = addDays(cur, stepDays);
            guard++;
          }
          return out;
        }

        if (mode === "monthly") {
          let k = 1;
          while (guard < 20000) {
            const cur = addMonthsKeepingDay(anchor, k, anchorDay);
            if (cur > until) break;
            out.push(toISODate(cur));
            k++; guard++;
          }
          return out;
        }

        if (mode === "yearly") {
          let k = 1;
          while (guard < 20000) {
            const cur = addYearsKeepingDay(anchor, k, anchorMonth, anchorDay);
            if (cur > until) break;
            out.push(toISODate(cur));
            k++; guard++;
          }
          return out;
        }

        return out;
      };

      const materializeRecurrenceSeries = async (masterEvent, untilISO) => {
        const seriesId = masterEvent.seriesId || masterEvent.id;
        const dates = buildOccurrenceDates(masterEvent, untilISO);
        const createdChildren = [];
        for (const iso of dates) {
          const payload = {
            title: masterEvent.title,
            category: masterEvent.category,
            type: masterEvent.type,
            amount: masterEvent.amount,
            date: iso,
            time: masterEvent.time || "",
            notes: masterEvent.notes || "",
            pinned: !!masterEvent.pinned,
            recurrence: "none",
            recurrenceDays: null,
            seriesId,
            seriesMaster: false
          };
          const res = await API.createEvent(payload);
          const child = normalizeEvent(res?.event || res);
          if (child?.id) createdChildren.push(child);
        }
        return { seriesId, children: createdChildren };
      };

      const el = (tag, attrs = {}, children = []) => {
        const node = document.createElement(tag);
        for (const [k, v] of Object.entries(attrs)) {
          if (k === "className") node.className = v;
          else if (k === "textContent") node.textContent = v;
          else node.setAttribute(k, v);
        }
        if (!Array.isArray(children)) children = [children];
        for (const ch of children) {
          if (ch == null) continue;
          node.appendChild(ch.nodeType ? ch : document.createTextNode(String(ch)));
        }
        return node;
      };

      const emptyState = (text, className = "") =>
        el("div", { className: `empty-state ${className}`.trim() }, [
          el("div", { className: "empty-state__text", textContent: text || "" })
        ]);

      const categorySlug = (cat) => (cat || "uncategorized").trim().toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9\-_]/g, "");

      const eventBlock = (evt) => {
        const amt = evt.amount != null && evt.amount !== "" ? formatMoney(Number(evt.amount), state.settings.currency) : "";
        const cat = evt.category || "Senza categoria";
        const root = el("button", {
          type: "button",
          className: [
            "event-block",
            `event-block--type-${evt.type}`,
            `event-block--cat-${categorySlug(cat)}`,
            evt.pinned ? "is-pinned" : "",
            state.settings.density === "compact" ? "is-compact" : "is-comfort"
          ].filter(Boolean).join(" "),
          id: `evt_${evt.id}`,
          "data-event-id": evt.id,
          "data-category": cat,
          "data-type": evt.type
        });

        const top = el("div", { className: "event-block__top" }, [
          el("span", { className: "event-block__title", textContent: evt.title }),
          evt.pinned ? el("span", { className: "event-block__pin", textContent: "★", "aria-hidden": "true" }) : null
        ].filter(Boolean));

        const meta = el("div", { className: "event-block__meta" }, [
          el("span", { className: "event-block__cat", textContent: cat }),
          evt.time ? el("span", { className: "event-block__time", textContent: evt.time }) : null
        ].filter(Boolean));

        root.append(top, meta);
        if (amt) root.append(el("div", { className: "event-block__amount", textContent: amt }));

        root.addEventListener("click", () => openEventDrawer(evt.id));
        return root;
      };

      const kv = (k, v) => el("div", { className: "kv" }, [
        el("div", { className: "kv__k", textContent: k }),
        el("div", { className: "kv__v", textContent: v })
      ]);

      const renderEventDetail = (evt) => {
        const cat = evt.category || "Senza categoria";
        const amt = evt.amount != null && evt.amount !== "" ? formatMoney(Number(evt.amount), state.settings.currency) : "—";
        const rec = evt.recurrence === "custom_days" ? `Ogni ${evt.recurrenceDays || "?"} giorni` : (evt.recurrence || "none");

        const root = el("article", { className: "event-detail" }, [
          el("div", { className: "event-detail__row" }, [
            kv("Categoria", cat),
            kv("Tipo", evt.type),
            kv("Ricorrenza", rec)
          ]),
          el("div", { className: "event-detail__row" }, [
            kv("Data", evt.date),
            kv("Ora", evt.time || "—"),
            kv("Importo", amt)
          ]),
          el("div", { className: "event-detail__notes" }, [
            el("h3", { className: "event-detail__notes-title", textContent: "Note" }),
            el("p", { className: "event-detail__notes-text", textContent: evt.notes || "—" })
          ])
        ]);

        return root;
      };

      const renderDayView = (events) => {
        const [start] = getEffectiveRangeForView();
        const dayISO = toISODate(start);
        const container = el("div", { className: "view view--day", id: "viewDayHost" });

        const list = el("div", { className: "event-list event-list--day", role: "list" });
        const dayEvents = events.filter(e => e.date === dayISO);

        if (!dayEvents.length) list.appendChild(emptyState("Nessun evento in questo giorno.", "event-empty event-empty--day"));
        else for (const e of dayEvents) list.appendChild(el("div", {}, [eventBlock(e)]));

        container.appendChild(list);
        return container;
      };

      const renderWeekView = (events) => {
        const [start] = getEffectiveRangeForView();
        const container = el("div", { className: "view view--week", id: "viewWeekHost" });
        const grid = el("div", { className: "calendar-grid calendar-grid--week", id: "weekGrid" });

        for (let i = 0; i < 7; i++) {
          const d = addDays(start, i);
          const iso = toISODate(d);

          const col = el("section", { className: "day-col day-col--week", "data-date": iso });
          const colHeader = el("header", { className: "day-col__header" }, [
            el("div", { className: "day-col__dow", textContent: new Intl.DateTimeFormat("it-IT", { weekday: "short" }).format(d) }),
            el("div", { className: "day-col__date", textContent: `${pad2(d.getDate())}/${pad2(d.getMonth() + 1)}` })
          ]);
          const colBody = el("div", { className: "day-col__body", role: "list" });

          const dayEvents = events.filter(e => e.date === iso);
          if (!dayEvents.length) colBody.appendChild(emptyState("—", "event-empty event-empty--tiny"));
          else for (const e of dayEvents) colBody.appendChild(eventBlock(e));

          col.append(colHeader, colBody);
          grid.appendChild(col);
        }

        container.appendChild(grid);
        return container;
      };

      const renderMonthView = (events) => {
        const [start] = getEffectiveRangeForView();
        const container = el("div", { className: "view view--month", id: "viewMonthHost" });
        const grid = el("div", { className: "calendar-grid calendar-grid--month", id: "monthGrid" });

        const dowRow = el("div", { className: "dow-row", id: "monthDowRow" });
        for (const name of ["Lun", "Mar", "Mer", "Gio", "Ven", "Sab", "Dom"]) {
          dowRow.appendChild(el("div", { className: "dow-cell", textContent: name }));
        }
        grid.appendChild(dowRow);

        const gridStart = startOfWeek(startOfMonth(start));
        const gridEnd = endOfWeek(endOfMonth(start));

        let cur = gridStart;
        while (cur <= gridEnd) {
          const weekRow = el("div", { className: "week-row", role: "row" });

          for (let i = 0; i < 7; i++) {
            const d = addDays(cur, i);
            const iso = toISODate(d);
            const inMonth = d.getMonth() === start.getMonth();

            const cell = el("section", {
              className: `day-cell day-cell--month ${inMonth ? "is-in-month" : "is-out-month"}`,
              id: `monthDay_${iso}`,
              "data-date": iso,
              role: "gridcell"
            });

            const cellHeader = el("header", { className: "day-cell__header" }, [
              el("div", { className: "day-cell__num", textContent: String(d.getDate()) }),
              el("button", {
                className: "btn btn--icon btn--cell-add",
                type: "button",
                "data-action": "quick-add",
                "data-date": iso,
                "aria-label": `Aggiungi evento il ${formatDateHuman(d)}`,
                textContent: "+"
              })
            ]);

            const cellBody = el("div", { className: "day-cell__body", role: "list" });
            const dayEvents = events.filter(e => e.date === iso);

            if (!dayEvents.length) cellBody.appendChild(emptyState("", "event-empty event-empty--month"));
            else for (const e of dayEvents) cellBody.appendChild(eventBlock(e));

            cell.append(cellHeader, cellBody);
            weekRow.appendChild(cell);
          }

          grid.appendChild(weekRow);
          cur = addDays(cur, 7);
        }

        container.appendChild(grid);
        return container;
      };

      const renderYearView = (events) => {
        const [start] = getEffectiveRangeForView();
        const container = el("div", { className: "view view--year", id: "viewYearHost" });
        const wrap = el("div", { className: "year-grid", id: "yearGrid" });

        for (let m = 0; m < 12; m++) {
          const monthDate = new Date(start.getFullYear(), m, 1);
          const monthBox = el("section", {
            className: "month-mini",
            "data-month": String(m),
            "data-year": String(start.getFullYear()),
            role: "button",
            tabindex: "0"
          });

          const inThisMonth = events.filter(e => {
            const d = fromISODate(e.date);
            return d.getFullYear() === start.getFullYear() && d.getMonth() === m;
          });

          monthBox.append(
            el("div", { className: "month-mini__header" }, [
              el("div", { className: "month-mini__title", textContent: new Intl.DateTimeFormat("it-IT", { month: "long" }).format(monthDate) }),
              el("div", { className: "month-mini__count", textContent: `${inThisMonth.length} evt` })
            ])
          );

          wrap.appendChild(monthBox);
        }

        container.appendChild(wrap);
        return container;
      };

      const renderCalendar = () => {
        const filtered = getFilteredEvents();
        const view = state.settings.view;

        const host = $("#calendarView");
        host.innerHTML = "";
        host.dataset.view = view;
        host.dataset.density = state.settings.density;

        const [vs, ve] = getEffectiveRangeForView();
        $("#calendarTitle").textContent = `Calendario · ${formatRangeLabel(vs, ve, view)}`;
        $("#calendarSubtitle").textContent = `${filtered.length} eventi (filtrati)`;
        $("#rangeLabel").textContent = formatRangeLabel(vs, ve, view);

        if (view === "day") host.appendChild(renderDayView(filtered));
        else if (view === "week") host.appendChild(renderWeekView(filtered));
        else if (view === "month") host.appendChild(renderMonthView(filtered));
        else host.appendChild(renderYearView(filtered));
      };

      const renderCategoryOptions = () => {
        const set = new Set(state.events.map(e => (e.category || "").trim()).filter(Boolean));
        const cats = Array.from(set).sort((a, b) => a.localeCompare(b, "it"));
        const sel = $("#categorySelect");
        const prev = state.settings.category || "all";
        sel.innerHTML = "";
        sel.appendChild(el("option", { value: "all", textContent: "Tutte" }));
        for (const c of cats) sel.appendChild(el("option", { value: c.toLowerCase(), textContent: c }));
        sel.value = prev;

        const list = $("#categoryList");
        list.innerHTML = "";
        for (const c of cats) list.appendChild(el("option", { value: c }));
      };

      const syncControlsFromState = () => {
        $("#sidebar").setAttribute("data-open", state.settings.sidebarOpen ? "true" : "false");

        $$("#viewSwitch button").forEach(b => b.setAttribute("aria-pressed", b.dataset.view === state.settings.view ? "true" : "false"));
        $$("#densitySwitch button").forEach(b => b.setAttribute("aria-pressed", b.dataset.density === state.settings.density ? "true" : "false"));
        $$("#rangePresets button").forEach(b => b.setAttribute("aria-pressed", b.dataset.preset === state.settings.rangeMode ? "true" : "false"));

        $("#searchInput").value = state.settings.search || "";
        $("#toggleIncome").checked = !!state.settings.includeIncome;
        $("#toggleExpense").checked = !!state.settings.includeExpense;
        $("#toggleOther").checked = !!state.settings.includeOther;

        $("#fromDate").value = state.settings.fromDate || "";
        $("#toDate").value = state.settings.toDate || "";

        const todayISO = toISODate(new Date());
        $("#balanceAtDate").value = state.settings.balanceAtDate || todayISO;
      };

      const renderStats = () => {
        const filtered = getFilteredEvents();
        const vis = computeVisibleStats(filtered);

        $("#statsMeta").textContent = `${formatRangeLabel(vis.rangeStart, vis.rangeEnd, "custom")} · visibile`;

        $("#statIncome").textContent = formatMoney(vis.incomeSum, state.settings.currency);
        $("#statExpense").textContent = formatMoney(vis.expenseSum, state.settings.currency);
        $("#statNet").textContent = formatMoney(vis.net, state.settings.currency);
        $("#statIncomeCount").textContent = `${vis.incomeCount} eventi`;
        $("#statExpenseCount").textContent = `${vis.expenseCount} eventi`;

        const todayISO = toISODate(new Date());
        const balToday = computeBalanceUpTo(state.events, state.settings.initialBalance, todayISO);
        $("#statCurrentBalance").textContent = formatMoney(balToday, state.settings.currency);
        $("#statCurrentBalanceMeta").textContent = `Fino a ${todayISO}`;

        const atISO = state.settings.balanceAtDate || todayISO;
        const balAt = computeBalanceUpTo(state.events, state.settings.initialBalance, atISO);
        $("#statBalanceAtDate").textContent = formatMoney(balAt, state.settings.currency);

        const netEl = $("#statNet");
        netEl.classList.toggle("positive", vis.net > 0);
        netEl.classList.toggle("negative", vis.net < 0);

        const list = $("#snapshotList");
        list.innerHTML = "";
        const tail = vis.snapshots.slice(-14);
        for (const s of tail) {
          list.appendChild(el("div", { className: "snapshot-item", role: "listitem" }, [
            el("div", { className: "snapshot-item__date", textContent: s.date }),
            el("div", { className: "snapshot-item__value", textContent: formatMoney(s.balance, state.settings.currency) })
          ]));
        }
        if (!tail.length) list.appendChild(emptyState("Nessuno snapshot nel range corrente.", "snapshot-empty"));
      };

      const render = () => {
        syncControlsFromState();
        renderCategoryOptions();
        renderCalendar();
        renderStats();
      };

      const getEventById = (id) => state.events.find(e => e.id === id) || null;

      const openEventDrawer = (id) => {
        const evt = getEventById(id);
        if (!evt) return;
        state.selectedEventId = id;
        $("#eventDrawer").setAttribute("aria-hidden", "false");
        $("#drawerTitle").textContent = evt.title;
        const detail = $("#eventDetail");
        detail.innerHTML = "";
        detail.appendChild(renderEventDetail(evt));
      };

      const closeEventDrawer = () => {
        state.selectedEventId = null;
        $("#eventDrawer").setAttribute("aria-hidden", "true");
        $("#eventDetail").innerHTML = "";
      };

      const syncRecurrenceDaysUI = () => {
        const mode = $("#evtRecurrence").value;
        const wrap = $("#recDaysField");
        if (mode === "custom_days") {
          wrap.style.display = "";
          if (!$("#evtRecurrenceDays").value) $("#evtRecurrenceDays").value = "7";
        } else {
          wrap.style.display = "none";
          $("#evtRecurrenceDays").value = "";
        }
      };

      const openEventModal = (mode, eventId = null, prefillISO = null) => {
        state.draftEventId = mode === "edit" ? eventId : null;
        $("#eventModalTitle").textContent = mode === "edit" ? "Modifica evento" : "Nuovo evento";

        if (mode === "edit") {
          const evt = getEventById(eventId);
          if (!evt) return;
          $("#evtTitle").value = evt.title || "";
          $("#evtCategory").value = evt.category || "";
          $("#evtType").value = evt.type || "other";
          $("#evtAmount").value = (evt.amount ?? "");
          $("#evtStart").value = evt.date || "";
          $("#evtTime").value = evt.time || "";
          $("#evtNotes").value = evt.notes || "";
          $("#evtRecurrence").value = evt.recurrence || "none";
          $("#evtRecurrenceDays").value = evt.recurrenceDays != null ? String(evt.recurrenceDays) : "";
          $("#evtPinned").checked = !!evt.pinned;
          syncRecurrenceDaysUI();
        } else {
          $("#eventForm").reset();
          $("#evtType").value = "expense";
          $("#evtStart").value = prefillISO || toISODate(new Date());
          $("#evtRecurrence").value = "none";
          $("#evtRecurrenceDays").value = "";
          $("#evtPinned").checked = false;
          syncRecurrenceDaysUI();
        }

        $("#eventModal").showModal();
      };

      const closeEventModal = () => $("#eventModal").close();

      const upsertEventFromForm = async () => {
        const rec = $("#evtRecurrence").value;
        const recDays = rec === "custom_days" ? Math.max(1, parseInt($("#evtRecurrenceDays").value || "0", 10) || 0) : null;

        const data = {
          title: $("#evtTitle").value.trim(),
          category: $("#evtCategory").value.trim() || "Senza categoria",
          type: $("#evtType").value,
          amount: $("#evtAmount").value === "" ? null : Number($("#evtAmount").value),
          date: $("#evtStart").value,
          time: $("#evtTime").value,
          notes: $("#evtNotes").value.trim(),
          pinned: $("#evtPinned").checked,
          recurrence: rec,
          recurrenceDays: recDays
        };

        if (state.draftEventId) {
          const updated = await API.updateEvent(state.draftEventId, data);
          const evt = normalizeEvent(updated?.event || updated || { id: state.draftEventId, ...data });
          const idx = state.events.findIndex(e => e.id === state.draftEventId);
          if (idx >= 0) state.events[idx] = evt;
        } else {
          if ((data.recurrence || "none") === "none") {
            const created = await API.createEvent({
              ...data,
              recurrence: "none",
              recurrenceDays: null,
              seriesId: null,
              seriesMaster: false
            });
            state.events.push(normalizeEvent(created?.event || created));
          } else {
            const seriesId = uid();
            const created = await API.createEvent({
              ...data,
              seriesId,
              seriesMaster: true
            });
            const master = normalizeEvent(created?.event || created);
            const untilISO = defaultRecurrenceUntilISO(master.date, master.recurrence);
            const { children } = await materializeRecurrenceSeries(master, untilISO);
            state.events.push(master, ...children);
          }
        }

        closeEventModal();
        render();
      };

      const deleteSelectedEvent = async () => {
        const id = state.selectedEventId;
        if (!id) return;
        const evt = getEventById(id);
        if (!evt) return;

        if (!evt.seriesId) {
          await API.deleteEvent(evt.id);
          state.events = state.events.filter(e => e.id !== evt.id);
          closeEventDrawer();
          render();
          return;
        }

        const c = prompt("1=Solo questo\n2=Da questa data in poi\n3=Tutta la serie", "1");
        if (c === "1") {
          await API.deleteEvent(evt.id);
          state.events = state.events.filter(e => e.id !== evt.id);
        } else if (c === "2") {
          await API.deleteSeriesFrom(evt.seriesId, evt.date);
          state.events = state.events.filter(e => !(e.seriesId === evt.seriesId && e.date >= evt.date));
        } else if (c === "3") {
          await API.deleteSeries(evt.seriesId);
          state.events = state.events.filter(e => e.seriesId !== evt.seriesId);
        } else {
          return;
        }

        closeEventDrawer();
        render();
      };

      const moveAnchor = (delta) => {
        const v = state.settings.view;
        if (v === "day") state.anchorDate = addDays(state.anchorDate, delta);
        else if (v === "week") state.anchorDate = addDays(state.anchorDate, 7 * delta);
        else if (v === "month") state.anchorDate = addMonths(state.anchorDate, delta);
        else state.anchorDate = addYears(state.anchorDate, delta);
      };

      const exportJSON = () => {
        const payload = { exportedAt: new Date().toISOString(), settings: state.settings, events: state.events };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `calendar_finance_export_${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };

      const importJSON = async (file) => {
        const payload = JSON.parse(await file.text());
        const events = Array.isArray(payload.events) ? payload.events : [];
        for (const e of events) {
          const { id, ...rest } = e;
          await API.createEvent(rest);
        }
        state.events = await loadEventsFromBackend();
        if (payload.settings) {
          state.settings = { ...state.settings, ...payload.settings };
          saveSettings();
        }
        render();
      };

      const wireUI = () => {
        $("#btnSidebarToggle").addEventListener("click", () => { state.settings.sidebarOpen = !state.settings.sidebarOpen; saveSettings(); render(); });
        $("#btnPrev").addEventListener("click", () => { moveAnchor(-1); render(); });
        $("#btnNext").addEventListener("click", () => { moveAnchor(1); render(); });
        $("#btnToday").addEventListener("click", () => { state.anchorDate = startOfDay(new Date()); render(); });

        $$("#viewSwitch button").forEach(btn => btn.addEventListener("click", () => { state.settings.view = btn.dataset.view; saveSettings(); render(); }));
        $$("#densitySwitch button").forEach(btn => btn.addEventListener("click", () => { state.settings.density = btn.dataset.density; saveSettings(); render(); }));

        $("#btnNewEvent").addEventListener("click", () => openEventModal("new"));
        $("#evtRecurrence").addEventListener("change", syncRecurrenceDaysUI);

        $("#searchInput").addEventListener("input", (e) => { state.settings.search = e.target.value; saveSettings(); render(); });
        $("#categorySelect").addEventListener("change", (e) => { state.settings.category = e.target.value; saveSettings(); render(); });
        $("#toggleIncome").addEventListener("change", (e) => { state.settings.includeIncome = e.target.checked; saveSettings(); render(); });
        $("#toggleExpense").addEventListener("change", (e) => { state.settings.includeExpense = e.target.checked; saveSettings(); render(); });
        $("#toggleOther").addEventListener("change", (e) => { state.settings.includeOther = e.target.checked; saveSettings(); render(); });

        $$("#rangePresets button").forEach(btn => btn.addEventListener("click", () => {
          state.settings.rangeMode = btn.dataset.preset;
          const [minTrack, maxTrack] = getTrackingBounds(state.events);
          if (state.settings.rangeMode === "from" && !state.settings.fromDate) state.settings.fromDate = toISODate(minTrack);
          if (state.settings.rangeMode === "between") {
            if (!state.settings.fromDate) state.settings.fromDate = toISODate(minTrack);
            if (!state.settings.toDate) state.settings.toDate = toISODate(maxTrack);
          }
          saveSettings(); render();
        }));

        $("#fromDate").addEventListener("change", (e) => { state.settings.fromDate = e.target.value; saveSettings(); render(); });
        $("#toDate").addEventListener("change", (e) => { state.settings.toDate = e.target.value; saveSettings(); render(); });

        $("#balanceAtDate").addEventListener("change", (e) => { state.settings.balanceAtDate = e.target.value || toISODate(new Date()); saveSettings(); renderStats(); });

        $("#btnClearFilters").addEventListener("click", () => {
          const keepView = state.settings.view;
          const keepDensity = state.settings.density;
          const keepSidebar = state.settings.sidebarOpen;
          const keepBalance = state.settings.balanceAtDate || toISODate(new Date());
          state.settings = { ...structuredClone(defaultSettings), view: keepView, density: keepDensity, sidebarOpen: keepSidebar, balanceAtDate: keepBalance };
          saveSettings();
          render();
        });

        $("#btnApplyFilters").addEventListener("click", () => render());

        $("#calendarView").addEventListener("click", (e) => {
          const addBtn = e.target.closest("[data-action='quick-add']");
          if (addBtn) openEventModal("new", null, addBtn.getAttribute("data-date"));

          const mini = e.target.closest(".month-mini");
          if (mini) {
            const y = Number(mini.dataset.year);
            const m = Number(mini.dataset.month);
            state.anchorDate = new Date(y, m, 1);
            state.settings.view = "month";
            saveSettings(); render();
          }
        });

        $("#btnCloseDrawer").addEventListener("click", closeEventDrawer);
        $("#btnEditEvent").addEventListener("click", () => { if (state.selectedEventId) openEventModal("edit", state.selectedEventId); });
        $("#btnDeleteEvent").addEventListener("click", () => deleteSelectedEvent());

        $("#btnCloseModal").addEventListener("click", closeEventModal);
        $("#btnCancelEvent").addEventListener("click", closeEventModal);
        $("#eventForm").addEventListener("submit", (e) => { e.preventDefault(); upsertEventFromForm(); });

        $("#btnExport").addEventListener("click", exportJSON);
        $("#importFile").addEventListener("change", async (e) => {
          const f = e.target.files?.[0];
          if (f) await importJSON(f);
          e.target.value = "";
        });

        document.addEventListener("keydown", (e) => {
          if (e.key !== "Escape") return;
          if ($("#eventModal").open) { closeEventModal(); return; }
          if ($("#eventDrawer").getAttribute("aria-hidden") === "false") closeEventDrawer();
        });
      };

      const init = async () => {
        wireUI();

        const s = await API.getSettings().catch(() => null);
        const incoming = s?.settings ? s.settings : (s || {});
        state.settings = { ...structuredClone(defaultSettings), ...incoming };

        const todayISO = toISODate(new Date());
        if (!state.settings.balanceAtDate) state.settings.balanceAtDate = todayISO;

        state.events = await loadEventsFromBackend();

        const [minTrack, maxTrack] = getTrackingBounds(state.events);
        state.anchorDate = clampDateToRange(startOfDay(new Date()), minTrack, maxTrack);

        if (!state.settings.fromDate) state.settings.fromDate = toISODate(minTrack);
        if (!state.settings.toDate) state.settings.toDate = toISODate(maxTrack);

        syncRecurrenceDaysUI();
        render();
      };

      init();
    })();
  </script>
</body>
</html>
