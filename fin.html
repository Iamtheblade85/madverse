<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <title>Finance Calendar</title>
</head>
<body>
  <div id="app">
    <header id="topbar">
      <div>
        <button id="btnSidebarToggle" type="button">☰ Filtri</button>
        <button id="btnPrev" type="button">‹</button>
        <button id="btnToday" type="button">Oggi</button>
        <button id="btnNext" type="button">›</button>
        <span id="rangeLabel">—</span>
      </div>
      <div>
        <span id="viewSwitch">
          <button type="button" data-view="day">Giorno</button>
          <button type="button" data-view="week">Settimana</button>
          <button type="button" data-view="month">Mese</button>
          <button type="button" data-view="year">Anno</button>
        </span>
        <span id="densitySwitch">
          <button type="button" data-density="comfort">Comfort</button>
          <button type="button" data-density="compact">Compatta</button>
        </span>
        <button id="btnNewEvent" type="button">＋ Nuovo</button>
      </div>
    </header>

    <aside id="sidebar" data-open="true">
      <h2>Filtri</h2>

      <section>
        <label for="searchInput">Cerca</label>
        <input id="searchInput" type="search" autocomplete="off" />
      </section>

      <section>
        <label for="categorySelect">Categoria</label>
        <select id="categorySelect">
          <option value="all">Tutte</option>
        </select>
      </section>

      <section>
        <label><input id="toggleIncome" type="checkbox" checked /> Entrate</label><br />
        <label><input id="toggleExpense" type="checkbox" checked /> Uscite</label><br />
        <label><input id="toggleOther" type="checkbox" checked /> Altro</label>
      </section>

      <section>
        <div id="rangePresets">
          <button type="button" data-preset="all">Da inizio</button>
          <button type="button" data-preset="from">Da data</button>
          <button type="button" data-preset="between">Tra date</button>
        </div>
        <label for="fromDate">Da</label>
        <input id="fromDate" type="date" />
        <label for="toDate">A</label>
        <input id="toDate" type="date" />
      </section>

      <section>
        <button id="btnApplyFilters" type="button">Applica</button>
        <button id="btnClearFilters" type="button">Reset</button>
      </section>

      <section>
        <button id="btnExport" type="button">Esporta JSON</button>
        <label for="importFile">Importa JSON</label>
        <input id="importFile" type="file" accept="application/json" />
      </section>

      <hr />

      <section id="statsPanel">
        <div>
          <strong>Stats</strong> <small id="statsMeta">—</small>
        </div>

        <div>
          <div>Saldo attuale (fino a oggi)</div>
          <div id="statCurrentBalance">—</div>
          <small id="statCurrentBalanceMeta">—</small>
        </div>

        <div style="margin-top:10px;">
          <div>Saldo alla data</div>
          <div id="statBalanceAtDate">—</div>
          <label for="balanceAtDate">Data</label>
          <input id="balanceAtDate" type="date" />
        </div>

        <div style="margin-top:10px;">
          <div>Netto (nel range visibile)</div>
          <div id="statNet">—</div>
          <small><span id="statIncomeCount">—</span> · <span id="statExpenseCount">—</span></small>
        </div>

        <div style="margin-top:10px;">
          <div>Entrate (nel range visibile)</div>
          <div id="statIncome">—</div>
        </div>

        <div style="margin-top:10px;">
          <div>Uscite (nel range visibile)</div>
          <div id="statExpense">—</div>
        </div>

        <hr />
        <div>Snapshot (ultimi 14 giorni del range visibile)</div>
        <div id="snapshotList"></div>
      </section>
    </aside>

    <main id="main">
      <header>
        <h1 id="calendarTitle">Calendario</h1>
        <p id="calendarSubtitle">—</p>
      </header>
      <section id="calendarView"></section>
    </main>

    <aside id="eventDrawer" aria-hidden="true">
      <div>
        <h2 id="drawerTitle">Evento</h2>
        <div>
          <button id="btnEditEvent" type="button">Modifica</button>
          <button id="btnDeleteEvent" type="button">Elimina</button>
          <button id="btnCloseDrawer" type="button">✕</button>
        </div>
      </div>
      <div id="eventDetail"></div>
    </aside>

    <dialog id="eventModal">
      <div>
        <h2 id="eventModalTitle">Evento</h2>
        <button id="btnCloseModal" type="button">✕</button>
      </div>

      <form id="eventForm" method="dialog" autocomplete="off">
        <div>
          <label for="evtTitle">Titolo *</label>
          <input id="evtTitle" type="text" required />
        </div>

        <div>
          <label for="evtCategory">Categoria</label>
          <input id="evtCategory" type="text" list="categoryList" />
          <datalist id="categoryList"></datalist>
        </div>

        <div>
          <label for="evtType">Tipo</label>
          <select id="evtType">
            <option value="income">Entrata</option>
            <option value="expense">Uscita</option>
            <option value="other">Altro</option>
          </select>
        </div>

        <div>
          <label for="evtAmount">Importo</label>
          <input id="evtAmount" type="number" step="0.01" />
        </div>

        <div>
          <label for="evtStart">Data *</label>
          <input id="evtStart" type="date" required />
        </div>

        <div>
          <label for="evtTime">Ora</label>
          <input id="evtTime" type="time" />
        </div>

        <div>
          <label for="evtRecurrence">Ricorrenza</label>
          <select id="evtRecurrence">
            <option value="none">Nessuna</option>
            <option value="monthly">Mensile</option>
            <option value="yearly">Annuale</option>
            <option value="custom_days">Ogni N giorni</option>
          </select>
        </div>

        <div id="recDaysField" style="display:none;">
          <label for="evtRecurrenceDays">Ogni quanti giorni</label>
          <input id="evtRecurrenceDays" type="number" min="1" step="1" />
        </div>

        <div>
          <label><input id="evtPinned" type="checkbox" /> In evidenza</label>
        </div>

        <div>
          <label for="evtNotes">Note</label>
          <textarea id="evtNotes"></textarea>
        </div>
      </form>

      <div>
        <button id="btnCancelEvent" type="button">Annulla</button>
        <button type="submit" form="eventForm">Salva</button>
      </div>
    </dialog>
  </div>

  <script>
    (() => {
      "use strict";

      const $ = (s, r = document) => r.querySelector(s);
      const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));

      const pad2 = (n) => String(n).padStart(2, "0");
      const toISODate = (d) => {
        const dt = (d instanceof Date) ? d : new Date(d);
        return `${dt.getFullYear()}-${pad2(dt.getMonth() + 1)}-${pad2(dt.getDate())}`;
      };
      const fromISODate = (iso) => {
        const [y, m, d] = iso.split("-").map(Number);
        return new Date(y, m - 1, d);
      };
      const startOfDay = (d) => new Date(d.getFullYear(), d.getMonth(), d.getDate());
      const endOfDay = (d) => new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);
      const addDays = (d, n) => {
        const x = new Date(d);
        x.setDate(x.getDate() + n);
        return x;
      };
      const addMonths = (d, n) => {
        const x = new Date(d);
        const day = x.getDate();
        x.setMonth(x.getMonth() + n);
        while (x.getDate() !== day && x.getDate() > 1) x.setDate(x.getDate() - 1);
        return x;
      };
      const addYears = (d, n) => {
        const x = new Date(d);
        x.setFullYear(x.getFullYear() + n);
        return x;
      };
      const formatMoney = (val, currency = "EUR") =>
        new Intl.NumberFormat("it-IT", { style: "currency", currency }).format(Number(val || 0));
      const formatDateHuman = (d) =>
        new Intl.DateTimeFormat("it-IT", { weekday: "short", year: "numeric", month: "long", day: "2-digit" }).format(d);
      const formatMonthHuman = (d) =>
        new Intl.DateTimeFormat("it-IT", { year: "numeric", month: "long" }).format(d);
      const formatRangeLabel = (start, end, view) => {
        if (view === "day") return formatDateHuman(start);
        if (view === "week") return `${formatDateHuman(start)} – ${formatDateHuman(end)}`;
        if (view === "month") return formatMonthHuman(start);
        if (view === "year") return String(start.getFullYear());
        return `${formatDateHuman(start)} – ${formatDateHuman(end)}`;
      };
      const startOfWeek = (d) => {
        const x = startOfDay(d);
        const day = (x.getDay() + 6) % 7;
        return addDays(x, -day);
      };
      const endOfWeek = (d) => endOfDay(addDays(startOfWeek(d), 6));
      const startOfMonth = (d) => new Date(d.getFullYear(), d.getMonth(), 1);
      const endOfMonth = (d) => endOfDay(new Date(d.getFullYear(), d.getMonth() + 1, 0));
      const startOfYear = (d) => new Date(d.getFullYear(), 0, 1);
      const endOfYear = (d) => endOfDay(new Date(d.getFullYear(), 11, 31));
      const clampDateToRange = (d, min, max) =>
        new Date(Math.min(Math.max(d.getTime(), min.getTime()), max.getTime())));
      const uid = () => crypto.randomUUID?.() || `id_${Math.random().toString(16).slice(2)}_${Date.now()}`;

      const API_BASE = "https://iamemanuele.pythonanywhere.com/api";
      const API = {
        async request(path, { method = "GET", body } = {}) {
          const res = await fetch(`${API_BASE}${path}`, {
            method,
            headers: body === undefined ? { "Accept": "application/json" } : { "Accept": "application/json", "Content-Type": "application/json" },
            credentials: "omit",
            body: body === undefined ? undefined : JSON.stringify(body)
          });
          const ct = res.headers.get("content-type") || "";
          const data = ct.includes("application/json") ? await res.json().catch(() => null) : await res.text().catch(() => null);
          if (!res.ok) throw new Error((data && data.error) ? data.error : `HTTP ${res.status}`);
          return data;
        },
        listEvents(params = {}) {
          const qs = new URLSearchParams(params).toString();
          return this.request(`/events${qs ? `?${qs}` : ""}`);
        },
        createEvent(payload) { return this.request(`/events`, { method: "POST", body: payload }); },
        updateEvent(id, payload) { return this.request(`/events/${encodeURIComponent(id)}`, { method: "PUT", body: payload }); },
        deleteEvent(id) { return this.request(`/events/${encodeURIComponent(id)}`, { method: "DELETE" }); },
        deleteSeries(seriesId) { return this.request(`/series/${encodeURIComponent(seriesId)}`, { method: "DELETE" }); },
        deleteSeriesFrom(seriesId, fromISO) { return this.request(`/series/${encodeURIComponent(seriesId)}/from/${encodeURIComponent(fromISO)}`, { method: "DELETE" }); },
        getSettings() { return this.request(`/settings`); },
        saveSettings(payload) { return this.request(`/settings`, { method: "PUT", body: payload }); }
      };

      const defaultSettings = {
        view: "month",
        density: "comfort",
        rangeMode: "all",
        fromDate: "",
        toDate: "",
        search: "",
        category: "all",
        includeIncome: true,
        includeExpense: true,
        includeOther: true,
        sidebarOpen: true,
        initialBalance: 3412,
        currency: "EUR",
        balanceAtDate: ""
      };

      const state = {
        settings: structuredClone(defaultSettings),
        events: [],
        anchorDate: startOfDay(new Date()),
        selectedEventId: null,
        draftEventId: null
      };

      let settingsTimer = null;
      const saveSettings = () => {
        clearTimeout(settingsTimer);
        settingsTimer = setTimeout(() => API.saveSettings(state.settings).catch(() => {}), 250);
      };

      const normalizeEvent = (e) => ({
        ...e,
        time: e.time || "",
        notes: e.notes || "",
        pinned: !!e.pinned,
        recurrence: e.recurrence || "none",
        recurrenceDays: e.recurrenceDays ?? null,
        seriesId: e.seriesId ?? null,
        seriesMaster: !!e.seriesMaster
      });

      const loadEventsFromBackend = async () => {
        const data = await API.listEvents();
        const arr = Array.isArray(data) ? data : (data?.events || []);
        return arr.map(normalizeEvent);
      };

      const getTrackingBounds = (events) => {
        const dates = events.map(e => e?.date).filter(Boolean).sort();
        if (!dates.length) {
          const t = startOfDay(new Date());
          return [t, t];
        }
        return [fromISODate(dates[0]), fromISODate(dates[dates.length - 1])];
      };

      const getEffectiveRangeForView = () => {
        const v = state.settings.view;
        const a = state.anchorDate;
        if (v === "day") return [startOfDay(a), endOfDay(a)];
        if (v === "week") return [startOfWeek(a), endOfWeek(a)];
        if (v === "month") return [startOfMonth(a), endOfMonth(a)];
        if (v === "year") return [startOfYear(a), endOfYear(a)];
        return [startOfMonth(a), endOfMonth(a)];
      };

      const getUserRangeConstraints = () => {
        const { rangeMode, fromDate, toDate } = state.settings;
        const [minTrack, maxTrack] = getTrackingBounds(state.events);
        if (rangeMode === "all") return [minTrack, maxTrack];
        if (rangeMode === "from") {
          const from = fromDate ? fromISODate(fromDate) : minTrack;
          return [startOfDay(from), maxTrack];
        }
        if (rangeMode === "between") {
          const from = fromDate ? fromISODate(fromDate) : minTrack;
          const to = toDate ? fromISODate(toDate) : maxTrack;
          const a = startOfDay(from);
          const b = endOfDay(to);
          return a <= b ? [a, b] : [b, a];
        }
        return [minTrack, maxTrack];
      };

      const passesTypeFilter = (e) => {
        if (e.type === "income" && !state.settings.includeIncome) return false;
        if (e.type === "expense" && !state.settings.includeExpense) return false;
        if (e.type === "other" && !state.settings.includeOther) return false;
        return true;
      };

      const passesCategoryFilter = (e) => {
        const cat = (state.settings.category || "all").toLowerCase();
        if (cat === "all") return true;
        return (e.category || "").toLowerCase() === cat;
      };

      const passesSearchFilter = (e) => {
        const q = (state.settings.search || "").trim().toLowerCase();
        if (!q) return true;
        const hay = `${e.title} ${e.category} ${e.notes}`.toLowerCase();
        return hay.includes(q);
      };

      const passesUserRange = (e) => {
        const [uStart, uEnd] = getUserRangeConstraints();
        const d = fromISODate(e.date);
        return d >= uStart && d <= uEnd;
      };

      const getFilteredEvents = () =>
        state.events
          .filter(e => e?.date)
          .filter(passesTypeFilter)
          .filter(passesCategoryFilter)
          .filter(passesSearchFilter)
          .filter(passesUserRange)
          .sort((a, b) => (a.date + (a.time || "")) < (b.date + (b.time || "")) ? -1 : 1);

      const signedAmount = (e) => {
        const amt = Number(e.amount || 0);
        if (!amt) return 0;
        if (e.type === "income") return +amt;
        if (e.type === "expense") return -amt;
        return 0;
      };

      const computeBalanceUpTo = (events, initialBalance, dateISO) => {
        const cutoff = fromISODate(dateISO);
        let bal = Number(initialBalance || 0);
        for (const e of events) {
          if (!e?.date) continue;
          const d = fromISODate(e.date);
          if (d <= endOfDay(cutoff)) bal += signedAmount(e);
        }
        return bal;
      };

      const computeSnapshots = (eventsInRange, initialBalance, rangeStart, rangeEnd) => {
        const days = [];
        const map = new Map();
        for (const e of eventsInRange) map.set(e.date, (map.get(e.date) || 0) + signedAmount(e));
        let bal = Number(initialBalance || 0);
        let cur = startOfDay(rangeStart);
        const last = startOfDay(rangeEnd);
        while (cur <= last) {
          const iso = toISODate(cur);
          bal += (map.get(iso) || 0);
          days.push({ date: iso, balance: bal });
          cur = addDays(cur, 1);
        }
        return days;
      };

      const computeVisibleStats = (filtered) => {
        const [viewStart, viewEnd] = getEffectiveRangeForView();
        const [userStart, userEnd] = getUserRangeConstraints();
        const rangeStart = new Date(Math.max(viewStart.getTime(), userStart.getTime()));
        const rangeEnd = new Date(Math.min(viewEnd.getTime(), userEnd.getTime()));
        const inVisible = filtered.filter(e => {
          const d = fromISODate(e.date);
          return d >= startOfDay(rangeStart) && d <= endOfDay(rangeEnd);
        });
        const incomeEvents = inVisible.filter(e => e.type === "income");
        const expenseEvents = inVisible.filter(e => e.type === "expense");
        const incomeSum = incomeEvents.reduce((s, e) => s + Number(e.amount || 0), 0);
        const expenseSum = expenseEvents.reduce((s, e) => s + Number(e.amount || 0), 0);
        const net = incomeSum - expenseSum;
        const snapshots = computeSnapshots(inVisible, state.settings.initialBalance, startOfDay(rangeStart), startOfDay(rangeEnd));
        return { rangeStart, rangeEnd, incomeSum, expenseSum, net, incomeCount: incomeEvents.length, expenseCount: expenseEvents.length, snapshots };
      };

      const daysInMonth = (y, m) => new Date(y, m + 1, 0).getDate();

      const addMonthsKeepingDay = (baseDate, monthsToAdd, anchorDay) => {
        const y0 = baseDate.getFullYear();
        const m0 = baseDate.getMonth();
        const targetMonth = m0 + monthsToAdd;
        const y = y0 + Math.floor(targetMonth / 12);
        const m = ((targetMonth % 12) + 12) % 12;
        const dim = daysInMonth(y, m);
        const day = Math.min(anchorDay, dim);
        return new Date(y, m, day);
      };

      const addYearsKeepingDay = (baseDate, yearsToAdd, anchorMonthIndex0, anchorDay) => {
        const y = baseDate.getFullYear() + yearsToAdd;
        const m = anchorMonthIndex0;
        const dim = daysInMonth(y, m);
        const day = Math.min(anchorDay, dim);
        return new Date(y, m, day);
      };

      const RECURRENCE_DEFAULTS = { monthlyMonths: 24, yearlyYears: 5, customDaysSpan: 365 };

      const defaultRecurrenceUntilISO = (startISO, mode, recurrenceDays) => {
        const start = fromISODate(startISO);
        const anchorDay = start.getDate();
        const anchorMonth = start.getMonth();
        if (mode === "monthly") return toISODate(addMonthsKeepingDay(start, RECURRENCE_DEFAULTS.monthlyMonths, anchorDay));
        if (mode === "yearly") return toISODate(addYearsKeepingDay(start, RECURRENCE_DEFAULTS.yearlyYears, anchorMonth, anchorDay));
        if (mode === "custom_days") return toISODate(addDays(start, Math.max(1, Number(RECURRENCE_DEFAULTS.customDaysSpan || 365))));
        return startISO;
      };

      const buildOccurrenceDates = (master, untilISO) => {
        const out = [];
        const mode = master.recurrence || "none";
        if (mode === "none") return out;
        const anchor = fromISODate(master.date);
        const anchorDay = anchor.getDate();
        const anchorMonth = anchor.getMonth();
        const until = fromISODate(untilISO);
        let guard = 0;

        if (mode === "custom_days") {
          const stepDays = Number(master.recurrenceDays || 0);
          if (!stepDays || stepDays < 1) return out;
          let cur = addDays(anchor, stepDays);
          while (cur <= until && guard < 20000) {
            out.push(toISODate(cur));
            cur = addDays(cur, stepDays);
            guard++;
          }
          return out;
        }

        if (mode === "monthly") {
          let k = 1;
          while (guard < 20000) {
            const cur = addMonthsKeepingDay(anchor, k, anchorDay);
            if (cur > until) break;
            out.push(toISODate(cur));
            k++; guard++;
          }
          return out;
        }

        if (mode === "yearly") {
          let k = 1;
          while (guard < 20000) {
            const cur = addYearsKeepingDay(anchor, k, anchorMonth, anchorDay);
            if (cur > until) break;
            out.push(toISODate(cur));
            k++; guard++;
          }
          return out;
        }

        return out;
      };

      const materializeRecurrenceSeries = async (masterEvent, untilISO) => {
        const seriesId = masterEvent.seriesId || masterEvent.id;
        const dates = buildOccurrenceDates(masterEvent, untilISO);
        const createdChildren = [];
        for (const iso of dates) {
          const payload = {
            title: masterEvent.title,
            category: masterEvent.category,
            type: masterEvent.type,
            amount: masterEvent.amount,
            date: iso,
            time: masterEvent.time || "",
            notes: masterEvent.notes || "",
            pinned: !!masterEvent.pinned,
            recurrence: "none",
            recurrenceDays: null,
            seriesId,
            seriesMaster: false
          };
          const res = await API.createEvent(payload);
          const child = normalizeEvent(res?.event || res);
          if (child?.id) createdChildren.push(child);
        }
        return { seriesId, children: createdChildren };
      };

      const el = (tag, attrs = {}, children = []) => {
        const node = document.createElement(tag);
        for (const [k, v] of Object.entries(attrs)) {
          if (k === "className") node.className = v;
          else if (k === "textContent") node.textContent = v;
          else node.setAttribute(k, v);
        }
        if (!Array.isArray(children)) children = [children];
        for (const ch of children) {
          if (ch == null) continue;
          node.appendChild(ch.nodeType ? ch : document.createTextNode(String(ch)));
        }
        return node;
      };

      const emptyState = (text) => el("div", { textContent: text || "" });

      const categorySlug = (cat) => (cat || "uncategorized").trim().toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9\-_]/g, "");

      const eventBlock = (evt) => {
        const amt = evt.amount != null && evt.amount !== "" ? formatMoney(Number(evt.amount), state.settings.currency) : "";
        const cat = evt.category || "Senza categoria";
        const root = el("button", {
          type: "button",
          "data-event-id": evt.id,
          className: `evt evt--${evt.type} evt--cat-${categorySlug(cat)}`
        });
        root.appendChild(el("div", { textContent: evt.title }));
        root.appendChild(el("div", { textContent: `${cat}${evt.time ? " · " + evt.time : ""}` }));
        if (amt) root.appendChild(el("div", { textContent: amt }));
        if (evt.seriesId) root.appendChild(el("div", { textContent: evt.seriesMaster ? "serie: master" : "serie" }));
        root.addEventListener("click", () => openEventDrawer(evt.id));
        return root;
      };

      const kv = (k, v) => el("div", {}, [el("strong", { textContent: k + ": " }), el("span", { textContent: v })]);

      const renderEventDetail = (evt) => {
        const cat = evt.category || "Senza categoria";
        const amt = evt.amount != null && evt.amount !== "" ? formatMoney(Number(evt.amount), state.settings.currency) : "—";
        const rec = evt.recurrence === "custom_days" ? `Ogni ${evt.recurrenceDays || "?"} giorni` : (evt.recurrence || "none");
        const root = el("div");
        root.appendChild(kv("Titolo", evt.title));
        root.appendChild(kv("Categoria", cat));
        root.appendChild(kv("Tipo", evt.type));
        root.appendChild(kv("Data", evt.date));
        root.appendChild(kv("Ora", evt.time || "—"));
        root.appendChild(kv("Importo", amt));
        root.appendChild(kv("Ricorrenza", rec));
        root.appendChild(kv("Serie", evt.seriesId ? (evt.seriesMaster ? "Master" : "Occorrenza") : "—"));
        root.appendChild(kv("Pinned", evt.pinned ? "sì" : "no"));
        root.appendChild(kv("Note", evt.notes || "—"));
        return root;
      };

      const renderDayView = (events) => {
        const [start] = getEffectiveRangeForView();
        const dayISO = toISODate(start);
        const wrap = el("div");
        wrap.appendChild(el("h3", { textContent: formatDateHuman(start) }));
        const list = el("div");
        const dayEvents = events.filter(e => e.date === dayISO);
        if (!dayEvents.length) list.appendChild(emptyState("Nessun evento."));
        else for (const e of dayEvents) list.appendChild(eventBlock(e));
        wrap.appendChild(list);
        return wrap;
      };

      const renderWeekView = (events) => {
        const [start, end] = getEffectiveRangeForView();
        const wrap = el("div");
        wrap.appendChild(el("h3", { textContent: `${formatDateHuman(start)} – ${formatDateHuman(end)}` }));
        const grid = el("div");
        for (let i = 0; i < 7; i++) {
          const d = addDays(start, i);
          const iso = toISODate(d);
          const col = el("div");
          col.appendChild(el("strong", { textContent: new Intl.DateTimeFormat("it-IT", { weekday: "short" }).format(d) + " " + `${pad2(d.getDate())}/${pad2(d.getMonth() + 1)}` }));
          const dayEvents = events.filter(e => e.date === iso);
          if (!dayEvents.length) col.appendChild(emptyState("—"));
          else for (const e of dayEvents) col.appendChild(eventBlock(e));
          grid.appendChild(col);
        }
        wrap.appendChild(grid);
        return wrap;
      };

      const renderMonthView = (events) => {
        const [start] = getEffectiveRangeForView();
        const wrap = el("div");
        wrap.appendChild(el("h3", { textContent: formatMonthHuman(start) }));

        const grid = el("div");
        const gridStart = startOfWeek(startOfMonth(start));
        const gridEnd = endOfWeek(endOfMonth(start));

        const header = el("div");
        for (const name of ["Lun", "Mar", "Mer", "Gio", "Ven", "Sab", "Dom"]) header.appendChild(el("strong", { textContent: name }));
        grid.appendChild(header);

        let cur = gridStart;
        while (cur <= gridEnd) {
          const row = el("div");
          for (let i = 0; i < 7; i++) {
            const d = addDays(cur, i);
            const iso = toISODate(d);
            const cell = el("div");
            const top = el("div");
            top.appendChild(el("strong", { textContent: String(d.getDate()) }));
            const addBtn = el("button", { type: "button", "data-action": "quick-add", "data-date": iso, textContent: "+" });
            top.appendChild(addBtn);
            cell.appendChild(top);

            const dayEvents = events.filter(e => e.date === iso);
            if (!dayEvents.length) cell.appendChild(emptyState(""));
            else for (const e of dayEvents) cell.appendChild(eventBlock(e));
            row.appendChild(cell);
          }
          grid.appendChild(row);
          cur = addDays(cur, 7);
        }

        wrap.appendChild(grid);
        return wrap;
      };

      const renderYearView = (events) => {
        const [start] = getEffectiveRangeForView();
        const wrap = el("div");
        wrap.appendChild(el("h3", { textContent: String(start.getFullYear()) }));
        const grid = el("div");
        for (let m = 0; m < 12; m++) {
          const monthDate = new Date(start.getFullYear(), m, 1);
          const box = el("button", { type: "button", className: "month-mini", "data-month": String(m), "data-year": String(start.getFullYear()) });
          const inThisMonth = events.filter(e => {
            const d = fromISODate(e.date);
            return d.getFullYear() === start.getFullYear() && d.getMonth() === m;
          });
          box.appendChild(el("div", { textContent: new Intl.DateTimeFormat("it-IT", { month: "long" }).format(monthDate) }));
          box.appendChild(el("small", { textContent: `${inThisMonth.length} evt` }));
          grid.appendChild(box);
        }
        wrap.appendChild(grid);
        return wrap;
      };

      const renderCalendar = () => {
        const filtered = getFilteredEvents();
        const view = state.settings.view;
        const host = $("#calendarView");
        host.innerHTML = "";
        const [vs, ve] = getEffectiveRangeForView();
        $("#calendarTitle").textContent = `Calendario · ${formatRangeLabel(vs, ve, view)}`;
        $("#calendarSubtitle").textContent = `${filtered.length} eventi (filtrati)`;
        $("#rangeLabel").textContent = formatRangeLabel(vs, ve, view);

        if (view === "day") host.appendChild(renderDayView(filtered));
        else if (view === "week") host.appendChild(renderWeekView(filtered));
        else if (view === "month") host.appendChild(renderMonthView(filtered));
        else host.appendChild(renderYearView(filtered));
      };

      const renderCategoryOptions = () => {
        const set = new Set(state.events.map(e => (e.category || "").trim()).filter(Boolean));
        const cats = Array.from(set).sort((a, b) => a.localeCompare(b, "it"));
        const sel = $("#categorySelect");
        const prev = state.settings.category || "all";
        sel.innerHTML = "";
        sel.appendChild(el("option", { value: "all", textContent: "Tutte" }));
        for (const c of cats) sel.appendChild(el("option", { value: c.toLowerCase(), textContent: c }));
        sel.value = prev;

        const list = $("#categoryList");
        list.innerHTML = "";
        for (const c of cats) list.appendChild(el("option", { value: c }));
      };

      const syncControlsFromState = () => {
        $("#sidebar").setAttribute("data-open", state.settings.sidebarOpen ? "true" : "false");

        $$("#viewSwitch button").forEach(b => b.setAttribute("aria-pressed", b.dataset.view === state.settings.view ? "true" : "false"));
        $$("#densitySwitch button").forEach(b => b.setAttribute("aria-pressed", b.dataset.density === state.settings.density ? "true" : "false"));
        $$("#rangePresets button").forEach(b => b.setAttribute("aria-pressed", b.dataset.preset === state.settings.rangeMode ? "true" : "false"));

        $("#searchInput").value = state.settings.search || "";
        $("#toggleIncome").checked = !!state.settings.includeIncome;
        $("#toggleExpense").checked = !!state.settings.includeExpense;
        $("#toggleOther").checked = !!state.settings.includeOther;

        $("#fromDate").value = state.settings.fromDate || "";
        $("#toDate").value = state.settings.toDate || "";

        const todayISO = toISODate(new Date());
        $("#balanceAtDate").value = state.settings.balanceAtDate || todayISO;
      };

      const renderStats = () => {
        const filtered = getFilteredEvents();
        const vis = computeVisibleStats(filtered);
        $("#statsMeta").textContent = `${formatRangeLabel(vis.rangeStart, vis.rangeEnd, "custom")} · visibile`;
        $("#statIncome").textContent = formatMoney(vis.incomeSum, state.settings.currency);
        $("#statExpense").textContent = formatMoney(vis.expenseSum, state.settings.currency);
        $("#statNet").textContent = formatMoney(vis.net, state.settings.currency);
        $("#statIncomeCount").textContent = `${vis.incomeCount} eventi`;
        $("#statExpenseCount").textContent = `${vis.expenseCount} eventi`;

        const allEvents = state.events;
        const todayISO = toISODate(new Date());
        const balToday = computeBalanceUpTo(allEvents, state.settings.initialBalance, todayISO);
        $("#statCurrentBalance").textContent = formatMoney(balToday, state.settings.currency);
        $("#statCurrentBalanceMeta").textContent = `Fino a ${todayISO}`;

        const atISO = state.settings.balanceAtDate || todayISO;
        const balAt = computeBalanceUpTo(allEvents, state.settings.initialBalance, atISO);
        $("#statBalanceAtDate").textContent = formatMoney(balAt, state.settings.currency);

        const list = $("#snapshotList");
        list.innerHTML = "";
        const tail = vis.snapshots.slice(-14);
        for (const s of tail) {
          list.appendChild(el("div", {}, [
            el("span", { textContent: s.date + " " }),
            el("strong", { textContent: formatMoney(s.balance, state.settings.currency) })
          ]));
        }
        if (!tail.length) list.appendChild(emptyState("Nessuno snapshot nel range corrente."));
      };

      const render = () => {
        syncControlsFromState();
        renderCategoryOptions();
        renderCalendar();
        renderStats();
      };

      const getEventById = (id) => state.events.find(e => e.id === id) || null;

      const openEventDrawer = (id) => {
        const evt = getEventById(id);
        if (!evt) return;
        state.selectedEventId = id;
        $("#eventDrawer").setAttribute("aria-hidden", "false");
        $("#drawerTitle").textContent = evt.title;
        const detail = $("#eventDetail");
        detail.innerHTML = "";
        detail.appendChild(renderEventDetail(evt));
      };

      const closeEventDrawer = () => {
        state.selectedEventId = null;
        $("#eventDrawer").setAttribute("aria-hidden", "true");
        $("#eventDetail").innerHTML = "";
      };

      const syncRecurrenceDaysUI = () => {
        const mode = $("#evtRecurrence").value;
        const wrap = $("#recDaysField");
        if (mode === "custom_days") {
          wrap.style.display = "";
          if (!$("#evtRecurrenceDays").value) $("#evtRecurrenceDays").value = "7";
        } else {
          wrap.style.display = "none";
          $("#evtRecurrenceDays").value = "";
        }
      };

      const openEventModal = (mode, eventId = null, prefillISO = null) => {
        state.draftEventId = mode === "edit" ? eventId : null;
        $("#eventModalTitle").textContent = mode === "edit" ? "Modifica evento" : "Nuovo evento";

        if (mode === "edit") {
          const evt = getEventById(eventId);
          if (!evt) return;
          $("#evtTitle").value = evt.title || "";
          $("#evtCategory").value = evt.category || "";
          $("#evtType").value = evt.type || "other";
          $("#evtAmount").value = (evt.amount ?? "");
          $("#evtStart").value = evt.date || "";
          $("#evtTime").value = evt.time || "";
          $("#evtNotes").value = evt.notes || "";
          $("#evtRecurrence").value = evt.recurrence || "none";
          $("#evtRecurrenceDays").value = evt.recurrenceDays != null ? String(evt.recurrenceDays) : "";
          $("#evtPinned").checked = !!evt.pinned;
          syncRecurrenceDaysUI();
        } else {
          $("#eventForm").reset();
          $("#evtType").value = "expense";
          $("#evtStart").value = prefillISO || toISODate(new Date());
          $("#evtRecurrence").value = "none";
          $("#evtRecurrenceDays").value = "";
          $("#evtPinned").checked = false;
          syncRecurrenceDaysUI();
        }

        $("#eventModal").showModal();
      };

      const closeEventModal = () => $("#eventModal").close();

      const upsertEventFromForm = async () => {
        const rec = $("#evtRecurrence").value;
        const recDays = rec === "custom_days" ? Math.max(1, parseInt($("#evtRecurrenceDays").value || "0", 10) || 0) : null;

        const data = {
          title: $("#evtTitle").value.trim(),
          category: $("#evtCategory").value.trim() || "Senza categoria",
          type: $("#evtType").value,
          amount: $("#evtAmount").value === "" ? null : Number($("#evtAmount").value),
          date: $("#evtStart").value,
          time: $("#evtTime").value,
          notes: $("#evtNotes").value.trim(),
          pinned: $("#evtPinned").checked,
          recurrence: rec,
          recurrenceDays: recDays
        };

        if (state.draftEventId) {
          const updated = await API.updateEvent(state.draftEventId, data);
          const evt = normalizeEvent(updated?.event || updated || { id: state.draftEventId, ...data });
          const idx = state.events.findIndex(e => e.id === state.draftEventId);
          if (idx >= 0) state.events[idx] = evt;
        } else {
          if ((data.recurrence || "none") === "none") {
            const created = await API.createEvent({
              ...data,
              recurrence: "none",
              recurrenceDays: null,
              seriesId: null,
              seriesMaster: false
            });
            state.events.push(normalizeEvent(created?.event || created));
          } else {
            const seriesId = uid();
            const created = await API.createEvent({
              ...data,
              seriesId,
              seriesMaster: true
            });
            const master = normalizeEvent(created?.event || created);
            const untilISO = defaultRecurrenceUntilISO(master.date, master.recurrence, master.recurrenceDays);
            const { children } = await materializeRecurrenceSeries(master, untilISO);
            state.events.push(master, ...children);
          }
        }

        closeEventModal();
        render();
      };

      const deleteSelectedEvent = async () => {
        const id = state.selectedEventId;
        if (!id) return;
        const evt = getEventById(id);
        if (!evt) return;

        if (!evt.seriesId) {
          await API.deleteEvent(evt.id);
          state.events = state.events.filter(e => e.id !== evt.id);
          closeEventDrawer();
          render();
          return;
        }

        const c = prompt("1=Solo questo\n2=Da questa data in poi\n3=Tutta la serie", "1");
        if (c === "1") {
          await API.deleteEvent(evt.id);
          state.events = state.events.filter(e => e.id !== evt.id);
        } else if (c === "2") {
          await API.deleteSeriesFrom(evt.seriesId, evt.date);
          state.events = state.events.filter(e => !(e.seriesId === evt.seriesId && e.date >= evt.date));
        } else if (c === "3") {
          await API.deleteSeries(evt.seriesId);
          state.events = state.events.filter(e => e.seriesId !== evt.seriesId);
        } else {
          return;
        }

        closeEventDrawer();
        render();
      };

      const moveAnchor = (delta) => {
        const v = state.settings.view;
        if (v === "day") state.anchorDate = addDays(state.anchorDate, delta);
        else if (v === "week") state.anchorDate = addDays(state.anchorDate, 7 * delta);
        else if (v === "month") state.anchorDate = addMonths(state.anchorDate, delta);
        else state.anchorDate = addYears(state.anchorDate, delta);
      };

      const exportJSON = () => {
        const payload = { exportedAt: new Date().toISOString(), settings: state.settings, events: state.events };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `calendar_finance_export_${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };

      const importJSON = async (file) => {
        const payload = JSON.parse(await file.text());
        const events = Array.isArray(payload.events) ? payload.events : [];
        for (const e of events) {
          const { id, ...rest } = e;
          await API.createEvent(rest);
        }
        state.events = await loadEventsFromBackend();
        if (payload.settings) {
          state.settings = { ...state.settings, ...payload.settings };
          saveSettings();
        }
        render();
      };

      const wireUI = () => {
        $("#btnSidebarToggle").addEventListener("click", () => { state.settings.sidebarOpen = !state.settings.sidebarOpen; saveSettings(); render(); });
        $("#btnPrev").addEventListener("click", () => { moveAnchor(-1); render(); });
        $("#btnNext").addEventListener("click", () => { moveAnchor(1); render(); });
        $("#btnToday").addEventListener("click", () => { state.anchorDate = startOfDay(new Date()); render(); });

        $$("#viewSwitch button").forEach(btn => btn.addEventListener("click", () => { state.settings.view = btn.dataset.view; saveSettings(); render(); }));
        $$("#densitySwitch button").forEach(btn => btn.addEventListener("click", () => { state.settings.density = btn.dataset.density; saveSettings(); render(); }));

        $("#btnNewEvent").addEventListener("click", () => openEventModal("new"));
        $("#evtRecurrence").addEventListener("change", syncRecurrenceDaysUI);

        $("#searchInput").addEventListener("input", (e) => { state.settings.search = e.target.value; saveSettings(); render(); });
        $("#categorySelect").addEventListener("change", (e) => { state.settings.category = e.target.value; saveSettings(); render(); });
        $("#toggleIncome").addEventListener("change", (e) => { state.settings.includeIncome = e.target.checked; saveSettings(); render(); });
        $("#toggleExpense").addEventListener("change", (e) => { state.settings.includeExpense = e.target.checked; saveSettings(); render(); });
        $("#toggleOther").addEventListener("change", (e) => { state.settings.includeOther = e.target.checked; saveSettings(); render(); });

        $$("#rangePresets button").forEach(btn => btn.addEventListener("click", () => {
          state.settings.rangeMode = btn.dataset.preset;
          const [minTrack, maxTrack] = getTrackingBounds(state.events);
          if (state.settings.rangeMode === "from" && !state.settings.fromDate) state.settings.fromDate = toISODate(minTrack);
          if (state.settings.rangeMode === "between") {
            if (!state.settings.fromDate) state.settings.fromDate = toISODate(minTrack);
            if (!state.settings.toDate) state.settings.toDate = toISODate(maxTrack);
          }
          saveSettings(); render();
        }));

        $("#fromDate").addEventListener("change", (e) => { state.settings.fromDate = e.target.value; saveSettings(); render(); });
        $("#toDate").addEventListener("change", (e) => { state.settings.toDate = e.target.value; saveSettings(); render(); });

        $("#balanceAtDate").addEventListener("change", (e) => { state.settings.balanceAtDate = e.target.value || toISODate(new Date()); saveSettings(); renderStats(); });

        $("#btnClearFilters").addEventListener("click", () => {
          const keepView = state.settings.view;
          const keepDensity = state.settings.density;
          const keepSidebar = state.settings.sidebarOpen;
          const keepBalance = state.settings.balanceAtDate || toISODate(new Date());
          state.settings = { ...structuredClone(defaultSettings), view: keepView, density: keepDensity, sidebarOpen: keepSidebar, balanceAtDate: keepBalance };
          saveSettings();
          render();
        });

        $("#btnApplyFilters").addEventListener("click", () => render());

        $("#calendarView").addEventListener("click", (e) => {
          const addBtn = e.target.closest("[data-action='quick-add']");
          if (addBtn) openEventModal("new", null, addBtn.getAttribute("data-date"));
          const mini = e.target.closest(".month-mini");
          if (mini) {
            const y = Number(mini.dataset.year);
            const m = Number(mini.dataset.month);
            state.anchorDate = new Date(y, m, 1);
            state.settings.view = "month";
            saveSettings(); render();
          }
        });

        $("#btnCloseDrawer").addEventListener("click", closeEventDrawer);
        $("#btnEditEvent").addEventListener("click", () => { if (state.selectedEventId) openEventModal("edit", state.selectedEventId); });
        $("#btnDeleteEvent").addEventListener("click", () => deleteSelectedEvent());

        $("#btnCloseModal").addEventListener("click", closeEventModal);
        $("#btnCancelEvent").addEventListener("click", closeEventModal);
        $("#eventForm").addEventListener("submit", (e) => { e.preventDefault(); upsertEventFromForm(); });

        $("#btnExport").addEventListener("click", exportJSON);
        $("#importFile").addEventListener("change", async (e) => {
          const f = e.target.files?.[0];
          if (f) await importJSON(f);
          e.target.value = "";
        });

        document.addEventListener("keydown", (e) => {
          if (e.key !== "Escape") return;
          if ($("#eventModal").open) { closeEventModal(); return; }
          if ($("#eventDrawer").getAttribute("aria-hidden") === "false") closeEventDrawer();
        });
      };

      const init = async () => {
        wireUI();

        const s = await API.getSettings().catch(() => null);
        const incoming = s?.settings ? s.settings : (s || {});
        state.settings = { ...structuredClone(defaultSettings), ...incoming };

        const todayISO = toISODate(new Date());
        if (!state.settings.balanceAtDate) state.settings.balanceAtDate = todayISO;

        state.events = await loadEventsFromBackend();

        const [minTrack, maxTrack] = getTrackingBounds(state.events);
        state.anchorDate = clampDateToRange(startOfDay(new Date()), minTrack, maxTrack);

        if (!state.settings.fromDate) state.settings.fromDate = toISODate(minTrack);
        if (!state.settings.toDate) state.settings.toDate = toISODate(maxTrack);

        syncRecurrenceDaysUI();
        render();
      };

      init();
    })();
  </script>
</body>
</html>
