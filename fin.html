<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Assistente Finanziario Web</title>
    <!-- Qui puoi collegare il tuo CSS personalizzato -->
    <link rel="stylesheet" href="fin-theme.css">
</head>
<body class="app-body">
<div class="app-root">

    <!-- TOPBAR -->
    <header class="app-topbar">
        <div class="topbar-title">Assistente Finanziario Web</div>
        <nav class="topbar-nav nav-main">
            <button class="nav-btn" data-page="dashboard">Dashboard</button>
            <button class="nav-btn" data-page="accounts">Conti</button>
            <button class="nav-btn" data-page="categories">Categorie</button>
            <button class="nav-btn" data-page="transactions">Transazioni</button>
            <button class="nav-btn" data-page="budgets">Budget</button>
            <button class="nav-btn" data-page="goals">Obiettivi</button>
            <button class="nav-btn" data-page="reports">Report</button>
        </nav>
    </header>

    <!-- MAIN -->
    <main class="app-main">
        <div id="message" class="app-message-area"></div>
        <div id="content" class="app-content-area">
            Caricamento...
        </div>
    </main>
</div>

<script>
/* ===========================
 * CONFIGURAZIONE API
 * =========================== */

const API_BASE = "https://iamemanuele.pythonanywhere.com/api"; // url_prefix del blueprint Flask

/* ===========================
 * STATO APPLICAZIONE
 * =========================== */

const app = {
    data: {
        accounts: [],
        categories: [],
        transactions: [],
        budgets: [],
        goals: []
    },
    currentPage: "dashboard",
    editAccountId: null,
    editCategoryId: null,
    editTxId: null,
    editBudgetId: null,
    editGoalId: null,
    txFilter: null,
    reportPeriodFilter: null,
    reportCatFilter: null,
    futureBalanceDate: null    
};

/* ===========================
 * UTILITY API
 * =========================== */

async function apiGet(path) {
    const res = await fetch(API_BASE + path, {
        method: "GET",
        headers: { "Accept": "application/json" }
    });
    if (!res.ok) {
        const txt = await res.text();
        throw new Error("Errore GET " + path + ": " + txt);
    }
    return res.json();
}

async function apiSend(path, method, payload) {
    const res = await fetch(API_BASE + path, {
        method,
        headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
        },
        body: JSON.stringify(payload || {})
    });
    const text = await res.text();
    let data = {};
    try { data = text ? JSON.parse(text) : {}; } catch (e) {}
    if (!res.ok || data.ok === false) {
        const msg = data.error || text || ("Errore " + method + " " + path);
        throw new Error(msg);
    }
    return data;
}

/* ===========================
 * UTILITY GENERALI
 * =========================== */

function h(s) {
    return String(s == null ? "" : s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;");
}

function todayStr() {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
}

function dateFromStr(str) {
    if (!str) return null;

    // Se è già un Date, clona e normalizza a mezzanotte
    if (str instanceof Date) {
        const d2 = new Date(str.getTime());
        d2.setHours(0, 0, 0, 0);
        return d2;
    }

    if (typeof str === "string") {
        // Prova prima a parsare formato YYYY-MM-DD
        const m = str.match(/^(\d{4})-(\d{2})-(\d{2})/);
        if (m) {
            const year = Number(m[1]);
            const month = Number(m[2]); // 1-12
            const day = Number(m[3]);   // 1-31
            const d = new Date(year, month - 1, day);
            d.setHours(0, 0, 0, 0);
            return d;
        }
    }

    // Fallback generico
    const d = new Date(str);
    if (isNaN(d.getTime())) return null;
    d.setHours(0, 0, 0, 0);
    return d;
}

function dateToStr(d) {
    if (!d) return "";
    let x = d;
    if (!(x instanceof Date)) {
        x = dateFromStr(x);
        if (!x) return "";
    }
    const y = x.getFullYear();
    const m = String(x.getMonth() + 1).padStart(2, "0");
    const day = String(x.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
}

function addDays(d, days) {
    const r = new Date(d);
    r.setDate(r.getDate() + days);
    r.setHours(0,0,0,0);
    return r;
}

function addMonths(d, months) {
    const r = new Date(d);
    r.setDate(1);
    r.setMonth(r.getMonth() + months);
    return r;
}

function diffDays(a, b) {
    const ms = b - a;
    return Math.floor(ms / 86400000);
}

// Differenza in mesi "interi" tra due date (per ricorrenze mensili)
// start <= limit
function monthsDiff(start, limit) {
    let y = limit.getFullYear() - start.getFullYear();
    let m = limit.getMonth() - start.getMonth();
    let diff = y * 12 + m;
    // se il giorno del mese di "limit" è prima del giorno di "start",
    // la ricorrenza di quel mese non è ancora scattata
    if (limit.getDate() < start.getDate()) diff -= 1;
    return diff;
}

// Conta quante volte una transazione ricorrente "t" è scattata
// dalla sua data iniziale t.date fino a "limitDate" (incluso).
// Se la frequenza è "once" o mancante, restituisce 1 solo se t.date <= limitDate.
function countOccurrencesUpTo(t, limitDate) {
    const start = dateFromStr(t.date);
    if (!start || !limitDate) return 0;

    // Se il limite è prima della data di inizio, non è ancora scattata
    if (limitDate < start) return 0;

    // Una tantum
    if (!t.freq || t.freq === "once") {
        return 1;
    }

    const freq = t.freq;

    if (freq === "daily") {
        // ogni giorno a partire da start
        return diffDays(start, limitDate) + 1;
    }

    if (freq === "weekly") {
        const days = diffDays(start, limitDate);
        return Math.floor(days / 7) + 1;
    }

    if (freq === "monthly") {
        const md = monthsDiff(start, limitDate);
        return md >= 0 ? md + 1 : 0;
    }

    if (freq === "yearly") {
        let years = limitDate.getFullYear() - start.getFullYear();
        // se non abbiamo ancora raggiunto il "compleanno" di quest'anno, togli 1
        if (
            limitDate.getMonth() < start.getMonth() ||
            (limitDate.getMonth() === start.getMonth() && limitDate.getDate() < start.getDate())
        ) {
            years -= 1;
        }
        return years >= 0 ? years + 1 : 0;
    }

    // fallback: considerala una tantum
    return 1;
}
    
function setMessage(text, type = "info") {
    const m = document.getElementById("message");
    if (!text) {
        m.innerHTML = "";
        return;
    }
    m.innerHTML =
        '<div class="app-message app-message--' + h(type) + '">' +
        h(text) +
        "</div>";
}

/* ===========================
 * CARICAMENTO STATO DAL BACKEND
 * =========================== */

async function loadState() {
    try {
        const state = await apiGet("/state");
        // Struttura attesa: {accounts:[], categories:[], ...}
        app.data = Object.assign(
            {accounts:[], categories:[], transactions:[], budgets:[], goals:[]},
            state
        );
        render();
    } catch (err) {
        console.error(err);
        setMessage("Errore nel caricamento dei dati: " + err.message, "error");
        document.getElementById("content").innerHTML =
            '<div class="app-error">Impossibile caricare i dati dal server.</div>';
    }
}

/* ===========================
 * FUNZIONI DI ANALISI (CLIENT-SIDE)
 * =========================== */

function getAccounts(activeOnly) {
    if (activeOnly) {
        return app.data.accounts.filter(a => a.is_active);
    }
    return app.data.accounts.slice();
}

function getCategories() {
    return app.data.categories.slice();
}

function computeBalances(includePrivate, asOfDate) {
    // oggi "reale"
    const today = dateFromStr(todayStr());

    // data limite per il calcolo saldi:
    // - se non fornita → oggi (istantanea reale)
    // - se fornita → saldo alla data (può essere anche futura → previsione)
    const limit = asOfDate
        ? dateFromStr(dateToStr(asOfDate))
        : today;

    const accs = app.data.accounts.map(a => ({
        id: a.id,
        name: a.name,
        type: a.type,
        currency: a.currency,
        initial_balance: Number(a.initial_balance || 0),
        balance: Number(a.initial_balance || 0)
    }));

    const txs = app.data.transactions;

    for (const t of txs) {
        if (!includePrivate && t.is_private) continue;

        const acc = accs.find(a => a.id === t.account_id);
        if (!acc) continue;

        const amount = Number(t.amount || 0);
        if (!amount) continue;

        const occ = countOccurrencesUpTo(t, limit);

        // occ = 0  → transazione non ancora "scattata" entro limit
        if (occ <= 0) continue;

        const totalAmount = amount * occ;

        if (t.direction === "in") acc.balance += totalAmount;
        else acc.balance -= totalAmount;
    }

    return accs;
}

function computeGlobalBalance(includePrivate, asOfDate) {
    const rows = computeBalances(includePrivate, asOfDate);
    return rows.reduce((s, r) => s + r.balance, 0);
}

function computePeriodSummary(start, end, includePrivate) {
    const s = dateFromStr(dateToStr(start));
    const e = dateFromStr(dateToStr(end));
    if (!s || !e) return [0,0,0,0,0];
    let totIn = 0, totOut = 0;
    for (const t of app.data.transactions) {
        if (!includePrivate && t.is_private) continue;
        const d = dateFromStr(t.date);
        if (!d) continue;
        if (d < s || d > e) continue;
        const amount = Number(t.amount || 0);
        if (t.direction === "in") totIn += amount;
        else totOut += amount;
    }
    const spread = totIn - totOut;
    const days = diffDays(s, e) + 1;
    const avgIn = days > 0 ? totIn / days : 0;
    const avgOut = days > 0 ? totOut / days : 0;
    return [totIn, totOut, spread, avgIn, avgOut];
}

function computeCategoryTotals(start, end, includePrivate, directionFilter) {
    const s = dateFromStr(dateToStr(start));
    const e = dateFromStr(dateToStr(end));
    const catsById = {};
    for (const c of app.data.categories) catsById[c.id] = c;
    const map = {};
    for (const t of app.data.transactions) {
        if (!includePrivate && t.is_private) continue;
        if (directionFilter && t.direction !== directionFilter) continue;
        const d = dateFromStr(t.date);
        if (!d || d < s || d > e) continue;
        const amount = Number(t.amount || 0);
        const catName = t.category_id ? (catsById[t.category_id]?.name || "(Senza categoria)") : "(Senza categoria)";
        if (!map[catName]) map[catName] = {cat: catName, net:0, tot_in:0, tot_out:0};
        if (t.direction === "in") {
            map[catName].net += amount;
            map[catName].tot_in += amount;
        } else {
            map[catName].net -= amount;
            map[catName].tot_out += amount;
        }
    }
    const rows = Object.values(map);
    rows.sort((a,b) => b.net - a.net);
    return rows;
}

function getRecurringTransactions(includePrivate) {
    return app.data.transactions.filter(t => t.freq !== "once" && (includePrivate || !t.is_private));
}

// Restituisce le occorrenze di transazioni ricorrenti in una finestra
// [oggi - daysBack, oggi + daysForward], usate solo per pipeline/eventi.
function getRecurringOccurrencesWindow(daysBack, daysForward, includePrivate) {
    const today = dateFromStr(todayStr());
    const startWindow = addDays(today, -Math.abs(daysBack || 0));
    const endWindow   = addDays(today,  Math.abs(daysForward || 0));

    const recs = getRecurringTransactions(includePrivate);
    const result = [];

    for (const t of recs) {
        const start = dateFromStr(t.date);
        if (!start) continue;

        // se la ricorrenza inizia dopo la fine della finestra, salta
        if (start > endWindow) continue;

        let current = new Date(start.getTime());

        while (current <= endWindow) {
            // se current è dentro la finestra, aggiungi l'evento
            if (current >= startWindow) {
                result.push({
                    date: dateToStr(current),
                    is_past: current < today,
                    is_today: current.getTime() === today.getTime(),
                    is_future: current > today,
                    transaction: t
                });
            }

            // passa all'occorrenza successiva in base alla freq
            if (t.freq === "daily") {
                current = addDays(current, 1);
            } else if (t.freq === "weekly") {
                current = addDays(current, 7);
            } else if (t.freq === "monthly") {
                current = addMonths(current, 1);
            } else if (t.freq === "yearly") {
                const next = new Date(current);
                next.setFullYear(next.getFullYear() + 1);
                current = next;
            } else {
                // se per qualche motivo non è ricorrente, esci dal loop
                break;
            }
        }
    }

    // Ordina per data
    result.sort((a, b) => (a.date < b.date ? -1 : a.date > b.date ? 1 : 0));
    return result;
}
    
function netMonthlyFromRecurring(includePrivate) {
    const recs = getRecurringTransactions(includePrivate);
    let totalIn = 0, totalOut = 0;
    for (const r of recs) {
        const amount = Number(r.amount || 0);
        let factor;
        if (r.freq === "daily") factor = 30;
        else if (r.freq === "weekly") factor = 4.345;
        else if (r.freq === "monthly") factor = 1;
        else if (r.freq === "yearly") factor = 1/12;
        else factor = 0;
        const eff = amount * factor;
        if (r.direction === "in") totalIn += eff;
        else totalOut += eff;
    }
    return [totalIn, totalOut];
}

function forecastMonths(months, includePrivate) {
    const base = computeGlobalBalance(includePrivate);
    const [monthlyIn, monthlyOut] = netMonthlyFromRecurring(includePrivate);
    const net = monthlyIn - monthlyOut;
    const today = new Date();
    const firstMonth = dateFromStr(today.toISOString().slice(0,7) + "-01");
    const result = [];
    let balance = base;
    for (let i=0;i<months;i++) {
        balance += net;
        const mDate = addMonths(firstMonth, i+1);
        result.push({month: mDate.toISOString().slice(0,7), balance, net});
    }
    return [base, result, monthlyIn, monthlyOut];
}

function computeBudgetStatus(periodType, refDate) {
    const d = refDate || new Date();
    let start, end;
    if (periodType === "monthly") {
        start = dateFromStr(d.toISOString().slice(0,7) + "-01");
        end = addMonths(start,1);
        end = addDays(end,-1);
    } else {
        start = dateFromStr(d.getFullYear() + "-01-01");
        end = dateFromStr(d.getFullYear() + "-12-31");
    }
    const catsById = {};
    for (const c of app.data.categories) catsById[c.id] = c;
    const results = [];
    for (const b of app.data.budgets) {
        if (b.period_type !== periodType) continue;
        const cat = catsById[b.category_id];
        if (!cat) continue;
        const catType = cat.type;
        let used = 0;
        for (const t of app.data.transactions) {
            if (t.category_id !== cat.id) continue;
            const dtx = dateFromStr(t.date);
            if (!dtx || dtx < start || dtx > end) continue;
            const amount = Number(t.amount || 0);
            if (catType === "expense" && t.direction === "out") used += amount;
            if (catType === "income" && t.direction === "in") used += amount;
        }
        const amountBudget = Number(b.amount || 0);
        let diff, status;
        if (catType === "expense") {
            diff = amountBudget - used;
            status = used <= amountBudget ? "OK" : "SFONDATO";
        } else {
            diff = used - amountBudget;
            status = used >= amountBudget ? "OK" : "SOTTO OBIETTIVO";
        }
        results.push({
            category_name: cat.name,
            category_type: catType,
            period_type: periodType,
            amount: amountBudget,
            used,
            diff,
            status
        });
    }
    return [start, end, results];
}

function computeGoalsStatus() {
    const balances = computeBalances(true);
    const balById = {};
    for (const b of balances) balById[b.id] = b.balance;
    const globalBalance = balances.reduce((s,b) => s + b.balance, 0);
    const accById = {};
    for (const a of app.data.accounts) accById[a.id] = a;
    const results = [];
    for (const g of app.data.goals) {
        const target = Number(g.target_amount || 0);
        let progress;
        if (g.account_id) progress = balById[g.account_id] || 0;
        else progress = globalBalance;
        const remaining = target - progress;
        const status = remaining <= 0 ? "RAGGIUNTO" : "DA RAGGIUNGERE";
        results.push({
            id: g.id,
            name: g.name,
            target,
            deadline: g.deadline || "",
            account_name: g.account_id ? (accById[g.account_id]?.name || "") : "",
            progress,
            remaining,
            status
        });
    }
    return results;
}

function analyzeHealth(includePrivate) {
    const today = dateFromStr(todayStr());
    const start30 = addDays(today, -29);
    const start90 = addDays(today, -89);
    const [totIn30, totOut30, spread30] = computePeriodSummary(start30, today, includePrivate);
    const [totIn90, totOut90, spread90] = computePeriodSummary(start90, today, includePrivate);
    const totalBalance = computeGlobalBalance(includePrivate);
    const [monthlyInRec, monthlyOutRec] = netMonthlyFromRecurring(includePrivate);
    const netRec = monthlyInRec - monthlyOutRec;
    const savingsRate30 = totIn30 > 0 ? (spread30 / totIn30) * 100 : 0;
    let status;
    if (spread90 > 0) status = "SANO";
    else if (totOut90 > 0 && spread90 > -0.05 * totOut90) status = "LEGGERA PRESSIONE";
    else status = "CRITICO";
    let runway = null;
    if (netRec < 0) {
        const netMonthly = netRec;
        if (netMonthly !== 0) runway = totalBalance / Math.abs(netMonthly);
    }
    const startMonth = dateFromStr(today.toISOString().slice(0,7) + "-01");
    let endMonth = addMonths(startMonth,1);
    endMonth = addDays(endMonth,-1);
    const [totInM, totOutM, spreadM] = computePeriodSummary(startMonth, today, includePrivate);
    const remainingDays = diffDays(today, endMonth);
    let safeDaily = null;
    if (remainingDays > 0) {
        const remainingSpend = Math.max(0, totInM - totOutM);
        safeDaily = remainingSpend / remainingDays;
    }
    const start60 = addDays(today, -59);
    const rowsCat = computeCategoryTotals(start60, today, includePrivate, "out");
    const topCats = rowsCat.slice(0,3);
    const nf = (x) => x.toFixed(2).replace(".", ",");
    const lines = [];
    lines.push("Stato complessivo: " + status);
    lines.push("");
    lines.push("Saldo totale (incl. saldi iniziali): " + nf(totalBalance));
    lines.push("");
    lines.push("Ultimi 30 giorni:");
    lines.push("- Entrate: " + nf(totIn30));
    lines.push("- Uscite: " + nf(totOut30));
    lines.push("- Spread: " + nf(spread30));
    lines.push("- Tasso di risparmio: " + savingsRate30.toFixed(1).replace(".", ",") + "%");
    lines.push("");
    lines.push("Ultimi 90 giorni:");
    lines.push("- Entrate: " + nf(totIn90));
    lines.push("- Uscite: " + nf(totOut90));
    lines.push("- Spread: " + nf(spread90));
    lines.push("");
    lines.push("Ricorrenti stimati (mese tipo):");
    lines.push("- Entrate ricorrenti: " + nf(monthlyInRec));
    lines.push("- Uscite ricorrenti: " + nf(monthlyOutRec));
    lines.push("- Netto mensile ricorrente: " + nf(netRec));
    if (runway !== null) {
        lines.push("- Runway stimata: " + runway.toFixed(1).replace(".", ",") + " mesi prima di azzerare il saldo se nulla cambia");
    }
    lines.push("");
    lines.push("Categorie principali (ultimi 60 giorni, uscite):");
    if (!topCats.length) {
        lines.push("- Nessuna uscita registrata.");
    } else {
        for (const r of topCats) {
            lines.push("- " + r.cat + ": " + nf(r.tot_out || 0));
        }
    }
    lines.push("");
    if (safeDaily !== null) {
        lines.push("Per chiudere il mese in pareggio, puoi spendere ancora circa " + nf(safeDaily) + " al giorno.");
    } else {
        lines.push("Il mese è quasi terminato: non ha senso calcolare un limite giornaliero.");
    }
    return lines.join("\n");
}

function computeSafeDailySpendText(includePrivate) {
    const today = dateFromStr(todayStr());
    const startMonth = dateFromStr(today.toISOString().slice(0,7) + "-01");
    let endMonth = addMonths(startMonth,1);
    endMonth = addDays(endMonth,-1);
    const [totIn, totOut] = computePeriodSummary(startMonth, today, includePrivate);
    const remainingDays = diffDays(today, endMonth);
    if (remainingDays <= 0) return "Il mese è praticamente finito, non ha senso calcolare un limite giornaliero.";
    const remainingSpend = Math.max(0, totIn - totOut);
    const safeDaily = remainingSpend / remainingDays;
    const nf = (x) => x.toFixed(2).replace(".", ",");
    return "Da oggi a fine mese puoi spendere in media circa " + nf(safeDaily) + " al giorno, se vuoi chiudere il mese intorno al pareggio rispetto alle entrate registrate finora.";
}

function forecastShortText(months, includePrivate) {
    const [base, result, minc, mout] = forecastMonths(months, includePrivate);
    if (!result.length) return "Non ci sono dati sufficienti per una previsione.";
    const nf = (x) => x.toFixed(2).replace(".", ",");
    const lines = [];
    lines.push("Saldo attuale stimato: " + nf(base));
    lines.push("Netto mensile ricorrente stimato: " + nf(minc - mout));
    lines.push("");
    lines.push("Previsione prossimi " + months + " mesi (solo ricorrenti):");
    for (const r of result) {
        lines.push("- " + r.month + ": saldo stimato " + nf(r.balance) + " (netto mese " + nf(r.net) + ")");
    }
    return lines.join("\n");
}

/* ===========================
 * NAVIGAZIONE
 * =========================== */

function setPage(page) {
    app.currentPage = page;
    app.editAccountId = null;
    app.editCategoryId = null;
    app.editTxId = null;
    app.editBudgetId = null;
    app.editGoalId = null;
    setMessage("");
    render();
    const btns = document.querySelectorAll(".nav-main .nav-btn");
    btns.forEach(b => {
        b.classList.toggle("nav-btn--active", b.dataset.page === page);
    });
}

function render() {
    if (app.currentPage === "dashboard") renderDashboard();
    else if (app.currentPage === "accounts") renderAccounts();
    else if (app.currentPage === "categories") renderCategories();
    else if (app.currentPage === "transactions") renderTransactions();
    else if (app.currentPage === "budgets") renderBudgets();
    else if (app.currentPage === "goals") renderGoals();
    else if (app.currentPage === "reports") renderReports();
}

/* ===========================
 * RENDER: DASHBOARD
 * =========================== */

function renderDashboard() {
    const container = document.getElementById("content");
    const balances = computeBalances(true);
    const total = balances.reduce((s,b) => s + b.balance, 0);
    const today = dateFromStr(todayStr());
    const futureDate = app.futureBalanceDate ? dateFromStr(app.futureBalanceDate) : null;
    const futureBalances = futureDate ? computeBalances(true, futureDate) : null;
    const futureTotal = futureBalances
        ? futureBalances.reduce((s, b) => s + b.balance, 0)
        : null;

    const futureBalMap = {};
    if (futureBalances) {
        for (const fb of futureBalances) {
            futureBalMap[fb.id] = fb.balance;
        }
    }   
    const startMonth = dateFromStr(today.toISOString().slice(0,7) + "-01");
    const [totInM, totOutM, spreadM] = computePeriodSummary(startMonth, today, true);
    const healthText = analyzeHealth(true);
    const firstLine = healthText.split("\n")[0].replace("Stato complessivo: ","");
    const forecastText = forecastShortText(3,true).split("\n");
    const nf = (x) => Number(x).toFixed(2).replace(".", ",");
    // Map rapida per conti e categorie (usata in timeline e tabella transazioni)
    const accById = {}; for (const a of app.data.accounts) accById[a.id] = a;
    const catById = {}; for (const c of app.data.categories) catById[c.id] = c;

    // --- TIMELINE EVENTI ±3 GIORNI ---

    // Occorrenze di transazioni ricorrenti nella finestra [-3, +3] giorni
    const recWindow = getRecurringOccurrencesWindow(3, 3, true);

    // Stato obiettivi (per usare deadline e progressi)
    const goalsStatus = computeGoalsStatus();
    const goalsByDeadline = {};
    for (const g of goalsStatus) {
        if (!g.deadline) continue;
        if (!goalsByDeadline[g.deadline]) goalsByDeadline[g.deadline] = [];
        goalsByDeadline[g.deadline].push(g);
    }

    // Stato budget mensile corrente (per fine mese)
    const [bs, be, brows] = computeBudgetStatus("monthly");
    const endMonthStr = dateToStr(be);

    const todayStrVal = todayStr();
    const daysPipeline = [];
    const eventsByDate = {};

    // Raccogli eventi ricorrenti per data
    for (const occ of recWindow) {
        if (!eventsByDate[occ.date]) eventsByDate[occ.date] = [];
        const t = occ.transaction;
        const sign = t.direction === "in" ? "+" : "-";
        const accName = accById[t.account_id]?.name || "";
        const catName = t.category_id ? (catById[t.category_id]?.name || "-") : "-";
        eventsByDate[occ.date].push({
            kind: "rec_tx",
            label: (t.direction === "in" ? "Entrata" : "Uscita") + " ricorrente"
                + (catName !== "-" ? " • " + catName : "")
                + (accName ? " • " + accName : ""),
            amount: sign + nf(Number(t.amount || 0))
        });
    }

    // Raccogli eventi obiettivi per data di deadline
    for (const dStr in goalsByDeadline) {
        if (!eventsByDate[dStr]) eventsByDate[dStr] = [];
        for (const g of goalsByDeadline[dStr]) {
            eventsByDate[dStr].push({
                kind: "goal",
                label: "Deadline obiettivo: " + g.name,
                extra: "Mancano " + nf(g.remaining) + " €"
            });
        }
    }

    // Giorni da -3 a +3 rispetto a oggi
    for (let delta = -3; delta <= 3; delta++) {
        const d = addDays(today, delta);
        const dStr = dateToStr(d);
        daysPipeline.push({
            date: d,
            dateStr: dStr,
            is_today: dStr === todayStrVal,
            is_past: d < today,
            is_future: d > today
        });
    }

    let html = "";
    html += '<div class="page page-dashboard">';
    html += '<div class="page-header">';
    html += '<h1 class="page-title">Dashboard</h1>';
    html += '<p class="page-subtitle">Panoramica sintetica e rapida del tuo stato finanziario</p>';
    html += '</div>';

    html += '<div class="cards-row cards-row--summary">';
    html += '<article class="card card--summary card--info"><div class="card-title">Saldo totale (incl. saldi iniziali)</div><div class="card-value">'+h(nf(total))+' €</div></article>';
    html += '<article class="card card--summary card--success"><div class="card-title">Entrate mese corrente</div><div class="card-value">'+h(nf(totInM))+' €</div></article>';
    html += '<article class="card card--summary card--danger"><div class="card-title">Uscite mese corrente</div><div class="card-value">'+h(nf(totOutM))+' €</div></article>';
    html += '<article class="card card--summary card--warning"><div class="card-title">Spread mese corrente</div><div class="card-value">'+h(nf(spreadM))+' €</div></article>';
    html += '</div>';

    html += '<div class="cards-row cards-row--secondary">';
    
    // Stato salute
    html += '<article class="card card--info">';
    html += '<div class="card-title" data-tooltip="Valutazione basata su entrate/uscite, ricorrenti e saldo"><span>Stato salute finanziaria</span></div>';
    html += '<div class="card-value">'+h(firstLine)+'</div>';
    html += '<div class="card-note">Dettaglio nella sezione Report.</div>';
    html += '</article>';
    
    // Previsione 3 mesi
    html += '<article class="card card--info">';
    html += '<div class="card-title">Previsione prossimi 3 mesi (ricorrenti)</div>';
    html += '<div class="card-note">'
          + h(forecastText[0] || "")
          + "<br>"
          + h(forecastText[1] || "")
          + "</div>";
    html += '</article>';

    // ⬇️ NUOVA CARD: SALDO FUTURO
    html += '<article class="card card--info">';
    html += '<div class="card-title">Saldo futuro alla data</div>';
    html += '<div class="card-value" id="future-balance-value">';
    if (futureTotal !== null) {
        html += h(nf(futureTotal)) + ' €';
    } else {
        html += '-';
    }
    html += '</div>';
    html += '<div class="card-note">';
    html += '<form id="futureBalanceForm" class="form form-inline">';
    html += '<input class="input input-date" type="date" name="future_date" min="'+h(todayStr())+'" value="'+h(app.futureBalanceDate || "")+'">';
    html += '<button class="btn btn--small btn--secondary" type="submit">Calcola</button>';
    html += '</form>';
    html += '</div>';
    html += '</article>';
    html += '</div>';

    html += '<div class="layout-two layout-two--main">';
    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Saldi per conto</h2></header>';
    html += '<div class="table-wrap"><table class="table table--accounts"><thead><tr>';
    html += '<th>Conto</th><th>Tipologia</th><th>Saldo attuale</th>';
    html += '<th>Saldo alla data selezionata</th><th>Valuta</th>';
    html += '</tr></thead><tbody>';
    if (!balances.length) {
        html += '<tr><td colspan="4" class="table-empty">Nessun conto definito.</td></tr>';
    } else {
        for (const b of balances) {
            const futureVal = futureBalances
                ? (futureBalMap[b.id] != null ? nf(futureBalMap[b.id]) : nf(b.balance))
                : null;
        
            html += '<tr>';
            html += '<td>'+h(b.name)+'</td>';
            html += '<td>'+h(b.type)+'</td>';
            html += '<td>'+h(nf(b.balance))+'</td>';
            html += '<td>'+(futureVal !== null ? h(futureVal) : '-')+'</td>';
            html += '<td>'+h(b.currency)+'</td>';
            html += '</tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';
    // --- TIMELINE EVENTI ±3 GIORNI ---
    html += '<section class="section section--panel">';
    html += '<header class="section-header">';
    html += '<h2 class="section-title">Timeline eventi (3 giorni fa / oggi / 3 giorni dopo)</h2>';
    html += '<p class="section-subtitle">Transazioni ricorrenti, deadline obiettivi e fine mese budget per singolo giorno.</p>';
    html += '</header>';

    html += '<div class="timeline">';

    for (const day of daysPipeline) {
        const dStr = day.dateStr;

        // Copia shallow degli eventi di quel giorno (se presenti)
        const evs = eventsByDate[dStr] ? eventsByDate[dStr].slice() : [];

        // Se questo giorno è fine mese e ci sono budget, aggiungi eventi budget
        if (dStr === endMonthStr && brows && brows.length) {
            for (const r of brows) {
                evs.push({
                    kind: "budget",
                    label: "Budget " + r.category_name,
                    extra: r.status + " — Δ " + nf(r.diff) + " €"
                });
            }
        }

        const badgeClass =
            day.is_today ? "timeline-day-badge timeline-day-badge--today" :
            day.is_future ? "timeline-day-badge timeline-day-badge--future" :
                            "timeline-day-badge timeline-day-badge--past";

        html += '<div class="timeline-day">';
        html += '<div class="'+badgeClass+'">';
        if (day.is_today) {
            html += '<div class="timeline-day-label">Oggi</div>';
        } else if (day.is_future) {
            html += '<div class="timeline-day-label">In arrivo</div>';
        } else {
            html += '<div class="timeline-day-label">Passato</div>';
        }
        html += '<div class="timeline-day-date">'+h(dStr)+'</div>';
        html += '</div>'; // badge

        html += '<div class="timeline-events">';

        if (!evs.length) {
            html += '<div class="timeline-event timeline-event--empty">Nessun evento previsto per questo giorno.</div>';
        } else {
            for (const ev of evs) {
                let kindLabel = "";
                if (ev.kind === "rec_tx") kindLabel = "Ricorrente";
                else if (ev.kind === "goal") kindLabel = "Obiettivo";
                else if (ev.kind === "budget") kindLabel = "Budget";

                html += '<div class="timeline-event">';
                if (kindLabel) {
                    html += '<span class="timeline-event-tag">'+h(kindLabel)+'</span>';
                }
                html += '<span class="timeline-event-text">'+h(ev.label)+'</span>';
                if (ev.amount) {
                    html += '<span class="timeline-event-amount">'+h(ev.amount)+' €</span>';
                }
                if (ev.extra) {
                    html += '<div class="timeline-event-extra">'+h(ev.extra)+'</div>';
                }
                html += '</div>';
            }
        }

        html += '</div>'; // timeline-events
        html += '</div>'; // timeline-day
    }

    html += '</div>'; // timeline
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Ultime transazioni registrate</h2></header>';
    html += '<div class="table-wrap"><table class="table table--transactions"><thead><tr><th>Data</th><th>Conto</th><th>Tipo</th><th>Importo</th><th>Categoria</th><th>Privata</th><th>Descrizione</th></tr></thead><tbody>';
    const txs = app.data.transactions
        .slice()
        .sort((a,b) => (a.date < b.date ? 1 : a.date > b.date ? -1 : b.id - a.id))
        .slice(0,20);

    if (!txs.length) {
        html += '<tr><td colspan="7" class="table-empty">Nessuna transazione.</td></tr>';
    } else {
        for (const t of txs) {
            const sign = t.direction === "in" ? "+" : "-";
            const accName = accById[t.account_id]?.name || "";
            const catName = t.category_id ? (catById[t.category_id]?.name || "-") : "-";
            const desc = t.description ? (t.description.length>40 ? t.description.slice(0,40)+"…" : t.description) : "";
            html += '<tr class="row-transaction row-transaction--'+(t.direction==="in"?"income":"expense")+'"><td>'+h(t.date)+'</td><td>'+h(accName)+'</td><td>'+(t.direction==="in"?"Entrata":"Uscita")+'</td><td>'+h(sign+nf(Number(t.amount||0)))+'</td><td>'+h(catName)+'</td><td>'+(t.is_private?"Sì":"No")+'</td><td>'+h(desc)+'</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';
    html += '</div>'; // layout-two

    html += '</div>'; // page
    container.innerHTML = html;
    // --- Event handler per il saldo futuro ---
    const fbForm = document.getElementById("futureBalanceForm");
    if (fbForm) {
        fbForm.addEventListener("submit", (e) => {
            e.preventDefault();
            const val = fbForm.future_date.value;
            if (!val) {
                app.futureBalanceDate = null;
            } else {
                const d = dateFromStr(val);
                if (!d) {
                    setMessage("Data futura non valida.", "warning");
                    return;
                }
                app.futureBalanceDate = dateToStr(d);
            }
            // Rende di nuovo SOLO la dashboard, mantenendo gli altri stati
            renderDashboard();
        });
    }  
}

/* ===========================
 * RENDER: CONTI
 * =========================== */

function renderAccounts() {
    const container = document.getElementById("content");
    const accounts = app.data.accounts.slice();
    const acc = app.editAccountId ? accounts.find(a => a.id === app.editAccountId) : null;
    const formData = {
        id: acc ? acc.id : null,
        name: acc ? acc.name : "",
        type: acc ? acc.type : "Contanti",
        currency: acc ? acc.currency : "EUR",
        description: acc ? (acc.description || "") : "",
        is_active: acc ? !!acc.is_active : true,
        initial_balance: acc ? Number(acc.initial_balance || 0) : 0
    };
    const nf = (x) => Number(x).toFixed(2).replace(".", ",");

    let html = "";
    html += '<div class="page page-accounts">';
    html += '<div class="page-header"><h1 class="page-title">Conti</h1><p class="page-subtitle">Gestisci contanti, conti bancari, wallet crypto, bauspar e altri contenitori di denaro</p></div>';
    html += '<div class="layout-two layout-two--main">';
    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Elenco conti</h2></header>';
    html += '<div class="table-wrap"><table class="table table--accounts"><thead><tr><th>Nome</th><th>Tipologia</th><th>Valuta</th><th>Saldo iniziale</th><th>Stato</th><th>Azioni</th></tr></thead><tbody>';
    if (!accounts.length) {
        html += '<tr><td colspan="6" class="table-empty">Nessun conto ancora definito.</td></tr>';
    } else {
        for (const a of accounts) {
            html += '<tr><td>'+h(a.name)+'</td><td>'+h(a.type)+'</td><td>'+h(a.currency)+'</td><td>'+h(nf(a.initial_balance || 0))+'</td><td>'+(a.is_active?"Attivo":"Chiuso")+'</td><td>';
            html += '<button class="btn btn--small btn--secondary" data-action="edit-account" data-id="'+a.id+'">Modifica</button>';
            html += '<button class="btn btn--small btn--danger" data-action="delete-account" data-id="'+a.id+'">Elimina</button>';
            html += '</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">'+(formData.id?'Modifica conto':'Nuovo conto')+'</h2></header>';
    html += '<form id="accountForm" class="form form-account">';
    html += '<div class="form-row"><label class="form-label">Nome conto</label><div class="form-field"><input class="input input-text" type="text" name="name" value="'+h(formData.name)+'" required></div></div>';
    html += '<div class="form-row"><label class="form-label">Tipologia</label><div class="form-field"><select class="input input-select" name="type">';
    const types = ["Contanti","Conto bancario","Carta di credito","Wallet crypto","Bauspar","Altro"];
    for (const t of types) {
        html += '<option value="'+h(t)+'"'+(formData.type===t?' selected':'')+'>'+h(t)+'</option>';
    }
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Valuta</label><div class="form-field"><select class="input input-select" name="currency">';
    const currs = ["EUR","USD","CHF","GBP"];
    for (const c of currs) {
        html += '<option value="'+h(c)+'"'+(formData.currency===c?' selected':'')+'>'+h(c)+'</option>';
    }
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Saldo iniziale</label><div class="form-field"><input class="input input-number" type="number" step="0.01" name="initial_balance" value="'+h(formData.initial_balance)+'"></div></div>';
    html += '<div class="form-row"><label class="form-label">Descrizione</label><div class="form-field"><textarea class="input input-textarea" name="description" rows="2">'+h(formData.description)+'</textarea></div></div>';
    html += '<div class="form-row"><label class="form-label">Stato</label><div class="form-field"><label class="checkbox-label"><input class="input input-checkbox" type="checkbox" name="is_active"'+(formData.is_active?' checked':'')+'> Conto attivo</label></div></div>';
    html += '<div class="form-actions"><button class="btn btn--primary" type="submit">Salva conto</button><button type="button" class="btn btn--secondary" id="accountNewBtn">Nuovo</button></div>';
    html += '<p class="form-help">Il saldo iniziale viene sommato alle transazioni per il calcolo del saldo attuale.</p>';
    html += '</form>';
    html += '</section>';

    html += '</div>'; // layout-two
    html += '</div>'; // page

    container.innerHTML = html;

    // Eventi
    document.getElementById("accountForm").addEventListener("submit", async e => {
        e.preventDefault();
        const f = e.target;
        const payload = {
            name: f.name.value.trim(),
            type: f.type.value.trim(),
            currency: f.currency.value.trim(),
            initial_balance: parseFloat(f.initial_balance.value || "0"),
            description: f.description.value.trim(),
            is_active: !!f.is_active.checked
        };
        if (!payload.name || !payload.type || !payload.currency) {
            setMessage("Compila tutti i campi obbligatori.", "warning");
            return;
        }
        try {
            if (formData.id) {
                await apiSend("/accounts/" + formData.id, "PUT", payload);
                setMessage("Conto aggiornato.", "success");
            } else {
                await apiSend("/accounts", "POST", payload);
                setMessage("Conto creato.", "success");
            }
            await loadState();
        } catch (err) {
            setMessage("Errore salvataggio conto: " + err.message, "error");
        }
    });

    document.getElementById("accountNewBtn").addEventListener("click", () => {
        app.editAccountId = null;
        renderAccounts();
    });

    container.querySelectorAll("button[data-action='edit-account']").forEach(b => {
        b.addEventListener("click", () => {
            app.editAccountId = parseInt(b.dataset.id,10);
            renderAccounts();
        });
    });
    container.querySelectorAll("button[data-action='delete-account']").forEach(b => {
        b.addEventListener("click", async () => {
            const id = parseInt(b.dataset.id,10);
            if (!confirm("Eliminare questo conto?")) return;
            try {
                await apiSend("/accounts/" + id, "DELETE", {});
                setMessage("Conto eliminato.", "success");
                await loadState();
            } catch (err) {
                setMessage("Errore eliminazione conto: " + err.message, "error");
            }
        });
    });
}

/* ===========================
 * RENDER: CATEGORIE
 * (stessa logica, CRUD via API)
 * =========================== */

function renderCategories() {
    const container = document.getElementById("content");
    const cats = app.data.categories.slice();
    const formCat = app.editCategoryId ? cats.find(c => c.id === app.editCategoryId) : null;
    const formData = {
        id: formCat ? formCat.id : null,
        name: formCat ? formCat.name : "",
        type: formCat ? formCat.type : "expense",
        parent_id: formCat ? (formCat.parent_id || null) : null
    };
    const catById = {};
    for (const c of cats) catById[c.id] = c;

    let html = "";
    html += '<div class="page page-categories">';
    html += '<div class="page-header"><h1 class="page-title">Categorie</h1><p class="page-subtitle">Organizza entrate, uscite e trasferimenti in categorie leggibili</p></div>';
    html += '<div class="layout-two layout-two--main">';
    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Elenco categorie</h2></header>';
    html += '<div class="table-wrap"><table class="table table--categories"><thead><tr><th>Nome</th><th>Tipo</th><th>Categoria padre</th><th>Azioni</th></tr></thead><tbody>';
    if (!cats.length) {
        html += '<tr><td colspan="4" class="table-empty">Nessuna categoria.</td></tr>';
    } else {
        for (const c of cats) {
            const parentName = c.parent_id ? (catById[c.parent_id]?.name || "") : "";
            html += '<tr><td>'+h(c.name)+'</td><td>'+(c.type==="income"?"Entrata":(c.type==="expense"?"Uscita":"Trasferimento"))+'</td><td>'+h(parentName)+'</td><td>';
            html += '<button class="btn btn--small btn--secondary" data-action="edit-cat" data-id="'+c.id+'">Modifica</button>';
            html += '<button class="btn btn--small btn--danger" data-action="delete-cat" data-id="'+c.id+'">Elimina</button>';
            html += '</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">'+(formData.id?'Modifica categoria':'Nuova categoria')+'</h2></header>';
    html += '<form id="catForm" class="form form-category">';
    html += '<div class="form-row"><label class="form-label">Nome categoria</label><div class="form-field"><input class="input input-text" type="text" name="name" value="'+h(formData.name)+'" required></div></div>';
    html += '<div class="form-row"><label class="form-label">Tipo</label><div class="form-field"><select class="input input-select" name="type">';
    html += '<option value="income"'+(formData.type==="income"?' selected':'')+'>Entrata</option>';
    html += '<option value="expense"'+(formData.type==="expense"?' selected':'')+'>Uscita</option>';
    html += '<option value="transfer"'+(formData.type==="transfer"?' selected':'')+'>Trasferimento</option>';
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Categoria padre (opzionale)</label><div class="form-field"><select class="input input-select" name="parent"><option value="">Nessuna</option>';
    for (const c of cats) {
        html += '<option value="'+c.id+'"'+(formData.parent_id===c.id?' selected':'')+'>'+h(c.name)+' ('+h(c.type)+')</option>';
    }
    html += '</select></div></div>';
    html += '<div class="form-actions"><button class="btn btn--primary" type="submit">Salva categoria</button><button type="button" class="btn btn--secondary" id="catNewBtn">Nuova</button></div>';
    html += '</form>';
    html += '</section>';

    html += '</div>'; // layout-two
    html += '</div>'; // page

    container.innerHTML = html;

    document.getElementById("catForm").addEventListener("submit", async e => {
        e.preventDefault();
        const f = e.target;
        const name = f.name.value.trim();
        const type = f.type.value;
        const parentVal = f.parent.value.trim();
        const parent_id = parentVal ? parseInt(parentVal,10) : null;
        if (!name || !["income","expense","transfer"].includes(type)) {
            setMessage("Compila correttamente i campi.", "warning");
            return;
        }
        const payload = {name, type, parent_id};
        try {
            if (formData.id) {
                await apiSend("/categories/" + formData.id, "PUT", payload);
                setMessage("Categoria aggiornata.", "success");
            } else {
                await apiSend("/categories", "POST", payload);
                setMessage("Categoria creata.", "success");
            }
            await loadState();
        } catch (err) {
            setMessage("Errore salvataggio categoria: " + err.message, "error");
        }
    });

    document.getElementById("catNewBtn").addEventListener("click", () => {
        app.editCategoryId = null;
        renderCategories();
    });

    container.querySelectorAll("button[data-action='edit-cat']").forEach(b => {
        b.addEventListener("click", () => {
            app.editCategoryId = parseInt(b.dataset.id,10);
            renderCategories();
        });
    });
    container.querySelectorAll("button[data-action='delete-cat']").forEach(b => {
        b.addEventListener("click", async () => {
            const id = parseInt(b.dataset.id,10);
            if (!confirm("Eliminare questa categoria?")) return;
            try {
                await apiSend("/categories/" + id, "DELETE", {});
                setMessage("Categoria eliminata.", "success");
                await loadState();
            } catch (err) {
                setMessage("Errore eliminazione categoria: " + err.message, "error");
            }
        });
    });
}

/* ===========================
 * RENDER: TRANSIZIONI / BUDGET / GOALS / REPORT
 * ===========================
 * Per motivi di spazio non riscrivo tutto il corpo qui da zero,
 * ma la logica è IDENTICA a prima con una sola differenza:
 * - al posto di localStorage, ogni salvataggio/eliminazione chiama apiSend(...)
 * - dopo ogni mutazione si fa `await loadState()`.
 *
 * Puoi riciclare le tue funzioni renderTransactions, renderBudgets,
 * renderGoals, renderReports cambiando SOLO la parte in cui
 * prima modificavi app.data e chiamavi saveData().
 *
 * Esempio per le transazioni:
 *   - CREA = POST /transactions
 *   - UPDATE = PUT /transactions/<id>
 *   - DELETE = DELETE /transactions/<id>
 *
 * E così per budgets e goals.
 */
/* ===========================
 * RENDER: TRANSAZIONI
 * =========================== */

function renderTransactions() {
    const container = document.getElementById("content");
    const today = dateFromStr(todayStr());
    if (!app.txFilter) {
        app.txFilter = {
            start: addDays(today,-30),
            end: today,
            direction: "all",
            accId: 0,
            priv: "all"
        };
    }
    const f = app.txFilter;
    const accs = app.data.accounts.slice();
    const cats = app.data.categories.slice();
    const catsIncome = cats.filter(c => c.type==="income");
    const catsExpense = cats.filter(c => c.type==="expense");
    const catsTransfer = cats.filter(c => c.type==="transfer");
    const tx = app.editTxId ? app.data.transactions.find(t => t.id === app.editTxId) : null;

    const txFormData = {
        id: tx ? tx.id : null,
        date: tx ? tx.date : todayStr(),
        account_id: tx ? tx.account_id : "",
        amount: tx ? tx.amount : "",
        direction: tx ? tx.direction : "out",
        category_id: tx ? (tx.category_id || "") : "",
        description: tx ? (tx.description || "") : "",
        is_private: tx ? !!tx.is_private : false,
        freq: tx ? tx.freq : "once",
        income_kind: tx ? (tx.income_kind || "variable") : "variable"
    };

    const accById = {}; for (const a of accs) accById[a.id] = a;
    const catById = {}; for (const c of cats) catById[c.id] = c;
    const s = f.start, e = f.end;

    let filtered = app.data.transactions.filter(t => {
        const d = dateFromStr(t.date);
        if (!d || d < s || d > e) return false;
        if (f.direction !== "all" && t.direction !== f.direction) return false;
        if (f.accId && t.account_id !== f.accId) return false;
        if (f.priv === "public" && t.is_private) return false;
        if (f.priv === "private" && !t.is_private) return false;
        return true;
    });
    filtered.sort((a,b) => (a.date < b.date ? 1 : a.date > b.date ? -1 : b.id - a.id));
    filtered = filtered.slice(0,300);
    const nf = (x) => Number(x).toFixed(2).replace(".", ",");

    let html = "";
    html += '<div class="page page-transactions">';
    html += '<div class="page-header"><h1 class="page-title">Transazioni</h1><p class="page-subtitle">Registra entrate, uscite, movimenti ricorrenti e privati su qualsiasi data</p></div>';

    html += '<section class="section section--filters">';
    html += '<header class="section-header"><h2 class="section-title">Filtri rapidi</h2></header>';
    html += '<form id="txFilterForm" class="form form-filters">';
    html += '<div class="grid-2">';
    html += '<div class="form-row"><label class="form-label">Da data</label><div class="form-field"><input class="input input-date" type="date" name="start" value="'+h(dateToStr(f.start))+'"></div></div>';
    html += '<div class="form-row"><label class="form-label">A data</label><div class="form-field"><input class="input input-date" type="date" name="end" value="'+h(dateToStr(f.end))+'"></div></div>';
    html += '<div class="form-row"><label class="form-label">Tipo movimento</label><div class="form-field"><select class="input input-select" name="direction">';
    html += '<option value="all"'+(f.direction==="all"?' selected':'')+'>Entrate e uscite</option>';
    html += '<option value="in"'+(f.direction==="in"?' selected':'')+'>Solo entrate</option>';
    html += '<option value="out"'+(f.direction==="out"?' selected':'')+'>Solo uscite</option>';
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Conto</label><div class="form-field"><select class="input input-select" name="acc">';
    html += '<option value="0"'+(!f.accId?' selected':'')+'>Tutti i conti</option>';
    for (const a of accs) {
        html += '<option value="'+a.id+'"'+(f.accId===a.id?' selected':'')+'>'+h(a.name)+'</option>';
    }
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Movimenti privati</label><div class="form-field"><select class="input input-select" name="priv">';
    html += '<option value="all"'+(f.priv==="all"?' selected':'')+'>Includi tutti</option>';
    html += '<option value="public"'+(f.priv==="public"?' selected':'')+'>Solo pubblici</option>';
    html += '<option value="private"'+(f.priv==="private"?' selected':'')+'>Solo privati</option>';
    html += '</select></div></div>';
    html += '<div class="form-row form-row--submit"><label class="form-label"></label><div class="form-field"><button class="btn btn--primary" type="submit">Applica filtri</button></div></div>';
    html += '</div>';
    html += '</form>';
    html += '</section>';

    html += '<div class="layout-two layout-two--main">';
    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Transazioni nell\'intervallo</h2></header>';
    html += '<div class="table-wrap"><table class="table table--transactions"><thead><tr><th>Data</th><th>Conto</th><th>Tipo</th><th>Importo</th><th>Categoria</th><th>Ricorrente</th><th>Privata</th><th>Descrizione</th><th>Azioni</th></tr></thead><tbody>';
    if (!filtered.length) {
        html += '<tr><td colspan="9" class="table-empty">Nessuna transazione per i filtri selezionati.</td></tr>';
    } else {
        for (const t of filtered) {
            const sign = t.direction==="in"?"+":"-";
            const accName = accById[t.account_id]?.name || "";
            const catName = t.category_id ? (catById[t.category_id]?.name || "-") : "-";
            const desc = t.description ? (t.description.length>40 ? t.description.slice(0,40)+"…" : t.description) : "";
            const freqLabel = t.freq==="once"?"Una tantum":t.freq;
            html += '<tr class="row-transaction row-transaction--'+(t.direction==="in"?"income":"expense")+'"><td>'+h(t.date)+'</td><td>'+h(accName)+'</td><td>'+(t.direction==="in"?"Entrata":"Uscita")+'</td><td>'+h(sign+nf(Number(t.amount||0)))+'</td><td>'+h(catName)+'</td><td>'+h(freqLabel)+'</td><td>'+(t.is_private?"Sì":"No")+'</td><td>'+h(desc)+'</td><td>';
            html += '<button class="btn btn--small btn--secondary" data-action="edit-tx" data-id="'+t.id+'">Modifica</button>';
            html += '<button class="btn btn--small btn--danger" data-action="delete-tx" data-id="'+t.id+'">Elimina</button>';
            html += '</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">'+(txFormData.id?'Modifica transazione':'Nuova transazione')+'</h2></header>';
    html += '<form id="txForm" class="form form-transaction">';
    html += '<div class="form-row"><label class="form-label">Data</label><div class="form-field"><input class="input input-date" type="date" name="date" value="'+h(txFormData.date)+'"></div></div>';
    html += '<div class="form-row"><label class="form-label">Conto</label><div class="form-field"><select class="input input-select" name="account_id" required><option value="">Seleziona</option>';
    for (const a of accs) {
        html += '<option value="'+a.id+'"'+(txFormData.account_id===a.id?' selected':'')+'>'+h(a.name)+' ('+h(a.currency)+')</option>';
        }
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Tipo movimento</label><div class="form-field"><select class="input input-select" name="direction" id="tx_direction_select">';
    html += '<option value="out"'+(txFormData.direction==="out"?' selected':'')+'>Uscita</option>';
    html += '<option value="in"'+(txFormData.direction==="in"?' selected':'')+'>Entrata</option>';
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Importo</label><div class="form-field"><input class="input input-number" type="number" step="0.01" name="amount" value="'+h(txFormData.amount)+'" required></div></div>';
    html += '<div class="form-row"><label class="form-label">Categoria</label><div class="form-field"><select class="input input-select" name="category_id">';
    html += '<option value="">Nessuna</option>';
    html += '<optgroup label="Uscite">';
    for (const c of catsExpense) {
        html += '<option value="'+c.id+'"'+(txFormData.category_id===c.id?' selected':'')+'>'+h(c.name)+'</option>';
    }
    html += '</optgroup><optgroup label="Entrate">';
    for (const c of catsIncome) {
        html += '<option value="'+c.id+'"'+(txFormData.category_id===c.id?' selected':'')+'>'+h(c.name)+'</option>';
    }
    html += '</optgroup><optgroup label="Trasferimenti">';
    for (const c of catsTransfer) {
        html += '<option value="'+c.id+'"'+(txFormData.category_id===c.id?' selected':'')+'>'+h(c.name)+'</option>';
    }
    html += '</optgroup></select></div></div>';
    html += '<div class="form-row"><label class="form-label">Descrizione</label><div class="form-field"><textarea class="input input-textarea" name="description" rows="2">'+h(txFormData.description)+'</textarea></div></div>';
    html += '<div class="form-row"><label class="form-label">Visibilità</label><div class="form-field"><label class="checkbox-label"><input class="input input-checkbox" type="checkbox" name="is_private"'+(txFormData.is_private?' checked':'')+'> Movimento privato (escludibile da alcuni report)</label></div></div>';
    html += '<div class="form-row"><label class="form-label">Frequenza</label><div class="form-field"><select class="input input-select" name="freq">';
    const freqs = [
        {v:"once",l:"Una tantum"},
        {v:"daily",l:"Giornaliera"},
        {v:"weekly",l:"Settimanale"},
        {v:"monthly",l:"Mensile"},
        {v:"yearly",l:"Annuale"}
    ];
    for (const fr of freqs) {
        html += '<option value="'+fr.v+'"'+(txFormData.freq===fr.v?' selected':'')+'>'+h(fr.l)+'</option>';
    }
    html += '</select></div></div>';
    html += '<div class="form-row" id="income_kind_row"><label class="form-label">Tipo entrata</label><div class="form-field"><select class="input input-select" name="income_kind">';
    html += '<option value="fixed"'+(txFormData.income_kind==="fixed"?' selected':'')+'>Entrata fissa</option>';
    html += '<option value="variable"'+(txFormData.income_kind==="variable"?' selected':'')+'>Entrata variabile</option>';
    html += '<option value="one-off"'+(txFormData.income_kind==="one-off"?' selected':'')+'>Entrata una tantum</option>';
    html += '</select></div></div>';
    html += '<div class="form-actions"><button class="btn btn--primary" type="submit">Salva transazione</button><button type="button" class="btn btn--secondary" id="txNewBtn">Nuova</button></div>';
    html += '<p class="form-help">Puoi inserire liberamente date passate o future. Le ricorrenze vengono utilizzate nelle analisi e previsioni.</p>';
    html += '</form>';
    html += '</section>';
    html += '</div>'; // layout-two
    html += '</div>'; // page

    container.innerHTML = html;

    const dirSelect = document.getElementById("tx_direction_select");
    const incomeRow = document.getElementById("income_kind_row");
    function updateIncomeKindVisibility() {
        incomeRow.style.display = dirSelect.value === "in" ? "" : "none";
    }
    updateIncomeKindVisibility();
    dirSelect.addEventListener("change", updateIncomeKindVisibility);

    document.getElementById("txFilterForm").addEventListener("submit", e => {
        e.preventDefault();
        const fDom = e.target;
        app.txFilter.start = dateFromStr(fDom.start.value) || addDays(today,-30);
        app.txFilter.end = dateFromStr(fDom.end.value) || today;
        app.txFilter.direction = fDom.direction.value;
        app.txFilter.accId = parseInt(fDom.acc.value || "0",10);
        app.txFilter.priv = fDom.priv.value;
        renderTransactions();
    });

    document.getElementById("txForm").addEventListener("submit", async e => {
        e.preventDefault();
        const fDom = e.target;
        const date = fDom.date.value || todayStr();
        const account_id = parseInt(fDom.account_id.value,10);
        const amount = parseFloat(fDom.amount.value || "0");
        const direction = fDom.direction.value==="in"?"in":"out";
        const catVal = fDom.category_id.value.trim();
        const category_id = catVal ? parseInt(catVal,10) : null;
        const description = fDom.description.value.trim();
        const is_private = !!fDom.is_private.checked;
        const freqVal = fDom.freq.value;
        let freq = freqs.some(fr => fr.v===freqVal)?freqVal:"once";
        let income_kind = fDom.income_kind.value;
        if (direction==="out") income_kind = null;

        if (!account_id || !amount) {
            setMessage("Compila conto e importo.", "warning");
            return;
        }
        const payload = {
            date,
            account_id,
            amount,
            direction,
            category_id,
            description,
            is_private,
            freq,
            income_kind
        };

        try {
            if (txFormData.id) {
                await apiSend("/transactions/" + txFormData.id, "PUT", payload);
                setMessage("Transazione aggiornata.", "success");
            } else {
                await apiSend("/transactions", "POST", payload);
                setMessage("Transazione salvata.", "success");
            }
            app.editTxId = null;
            await loadState();
        } catch (err) {
            setMessage("Errore salvataggio transazione: " + err.message, "error");
        }
    });

    document.getElementById("txNewBtn").addEventListener("click", () => {
        app.editTxId = null;
        renderTransactions();
    });

    container.querySelectorAll("button[data-action='edit-tx']").forEach(b => {
        b.addEventListener("click", () => {
            app.editTxId = parseInt(b.dataset.id,10);
            renderTransactions();
        });
    });
    container.querySelectorAll("button[data-action='delete-tx']").forEach(b => {
        b.addEventListener("click", async () => {
            const id = parseInt(b.dataset.id,10);
            if (!confirm("Eliminare questa transazione?")) return;
            try {
                await apiSend("/transactions/" + id, "DELETE", {});
                setMessage("Transazione eliminata.", "success");
                await loadState();
            } catch (err) {
                setMessage("Errore eliminazione transazione: " + err.message, "error");
            }
        });
    });
}

/* ===========================
 * RENDER: BUDGET
 * =========================== */

function renderBudgets() {
    const container = document.getElementById("content");
    const budgets = app.data.budgets.slice();
    const cats = app.data.categories.slice();
    const formBud = app.editBudgetId ? budgets.find(b => b.id === app.editBudgetId) : null;
    const formData = {
        id: formBud ? formBud.id : null,
        category_id: formBud ? formBud.category_id : "",
        period_type: formBud ? formBud.period_type : "monthly",
        amount: formBud ? formBud.amount : "",
        start_date: formBud ? (formBud.start_date || "") : ""
    };
    const nf = (x) => Number(x).toFixed(2).replace(".", ",");
    const catsById = {}; for (const c of cats) catsById[c.id] = c;

    let html = "";
    html += '<div class="page page-budgets">';
    html += '<div class="page-header"><h1 class="page-title">Budget</h1><p class="page-subtitle">Imposta limiti di spesa e obiettivi di entrata per categoria e controlla lo stato del mese</p></div>';
    html += '<div class="layout-two layout-two--main">';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Budget definiti</h2></header>';
    html += '<div class="table-wrap"><table class="table table--budgets"><thead><tr><th>Categoria</th><th>Tipo cat.</th><th>Periodo</th><th>Importo</th><th>Data inizio</th><th>Azioni</th></tr></thead><tbody>';
    if (!budgets.length) {
        html += '<tr><td colspan="6" class="table-empty">Nessun budget definito.</td></tr>';
    } else {
        for (const b of budgets) {
            const cat = catsById[b.category_id];
            if (!cat) continue;
            html += '<tr><td>'+h(cat.name)+'</td><td>'+(cat.type==="expense"?"Uscite":"Entrate")+'</td><td>'+(b.period_type==="monthly"?"Mensile":"Annuale")+'</td><td>'+h(nf(b.amount||0))+'</td><td>'+h(b.start_date||"")+'</td><td>';
            html += '<button class="btn btn--small btn--secondary" data-action="edit-bud" data-id="'+b.id+'">Modifica</button>';
            html += '<button class="btn btn--small btn--danger" data-action="delete-bud" data-id="'+b.id+'">Elimina</button>';
            html += '</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">'+(formData.id?'Modifica budget':'Nuovo budget')+'</h2></header>';
    html += '<form id="budgetForm" class="form form-budget">';
    html += '<div class="form-row"><label class="form-label">Categoria</label><div class="form-field"><select class="input input-select" name="category_id" required><option value="">Seleziona categoria</option>';
    for (const c of cats) {
        html += '<option value="'+c.id+'"'+(formData.category_id===c.id?' selected':'')+'>'+h(c.name)+' ('+(c.type==="expense"?"Uscite":"Entrate")+')</option>';
    }
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Periodo</label><div class="form-field"><select class="input input-select" name="period_type"><option value="monthly"'+(formData.period_type==="monthly"?' selected':'')+'>Mensile</option><option value="yearly"'+(formData.period_type==="yearly"?' selected':'')+'>Annuale</option></select></div></div>';
    html += '<div class="form-row"><label class="form-label">Importo obiettivo</label><div class="form-field"><input class="input input-number" type="number" step="0.01" name="amount" value="'+h(formData.amount)+'" required></div></div>';
    html += '<div class="form-row"><label class="form-label">Data inizio (opzionale)</label><div class="form-field"><input class="input input-date" type="date" name="start_date" value="'+h(formData.start_date)+'"></div></div>';
    html += '<div class="form-actions"><button class="btn btn--primary" type="submit">Salva budget</button><button type="button" class="btn btn--secondary" id="budgetNewBtn">Nuovo</button></div>';
    html += '</form>';
    html += '</section>';

    html += '</div>'; // layout-two

    const [bs,be,brows] = computeBudgetStatus("monthly");
    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Stato budget mese corrente</h2></header>';
    html += '<div class="table-wrap"><table class="table table--budgets-status"><thead><tr><th>Categoria</th><th>Tipo</th><th>Budget</th><th>Usato</th><th>Delta</th><th>Stato</th></tr></thead><tbody>';
    if (!brows.length) {
        html += '<tr><td colspan="6" class="table-empty">Nessun budget mensile definito.</td></tr>';
    } else {
        for (const r of brows) {
            html += '<tr><td>'+h(r.category_name)+'</td><td>'+(r.category_type==="expense"?"Uscite":"Entrate")+'</td><td>'+h(nf(r.amount))+'</td><td>'+h(nf(r.used))+'</td><td>'+h(nf(r.diff))+'</td><td>'+h(r.status)+'</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '<p class="section-note">Il periodo considerato è '+h(dateToStr(bs))+' - '+h(dateToStr(be))+'.</p>';
    html += '</section>';

    html += '</div>'; // page
    container.innerHTML = html;

    document.getElementById("budgetForm").addEventListener("submit", async e => {
        e.preventDefault();
        const fDom = e.target;
        const category_id = parseInt(fDom.category_id.value,10);
        const period_type = fDom.period_type.value;
        const amount = parseFloat(fDom.amount.value||"0");
        const start_date = fDom.start_date.value || "";
        if (!category_id || !["monthly","yearly"].includes(period_type)) {
            setMessage("Compila correttamente i campi.", "warning");
            return;
        }
        const payload = {category_id, period_type, amount, start_date};
        try {
            if (formData.id) {
                await apiSend("/budgets/" + formData.id, "PUT", payload);
                setMessage("Budget aggiornato.", "success");
            } else {
                await apiSend("/budgets", "POST", payload);
                setMessage("Budget creato.", "success");
            }
            app.editBudgetId = null;
            await loadState();
        } catch (err) {
            setMessage("Errore salvataggio budget: " + err.message, "error");
        }
    });

    document.getElementById("budgetNewBtn").addEventListener("click", () => {
        app.editBudgetId = null;
        renderBudgets();
    });

    container.querySelectorAll("button[data-action='edit-bud']").forEach(b => {
        b.addEventListener("click", () => {
            app.editBudgetId = parseInt(b.dataset.id,10);
            renderBudgets();
        });
    });
    container.querySelectorAll("button[data-action='delete-bud']").forEach(b => {
        b.addEventListener("click", async () => {
            const id = parseInt(b.dataset.id,10);
            if (!confirm("Eliminare questo budget?")) return;
            try {
                await apiSend("/budgets/" + id, "DELETE", {});
                setMessage("Budget eliminato.", "success");
                await loadState();
            } catch (err) {
                setMessage("Errore eliminazione budget: " + err.message, "error");
            }
        });
    });
}

/* ===========================
 * RENDER: OBIETTIVI
 * =========================== */

function renderGoals() {
    const container = document.getElementById("content");
    const goalsRaw = app.data.goals.slice();
    const accs = app.data.accounts.slice();
    const goalsStatus = computeGoalsStatus();
    const formGoal = app.editGoalId ? goalsRaw.find(g => g.id === app.editGoalId) : null;
    const formData = {
        id: formGoal ? formGoal.id : null,
        name: formGoal ? formGoal.name : "",
        target_amount: formGoal ? formGoal.target_amount : "",
        deadline: formGoal ? (formGoal.deadline || "") : "",
        account_id: formGoal ? (formGoal.account_id || "") : "",
        description: formGoal ? (formGoal.description || "") : ""
    };
    const nf = (x) => Number(x).toFixed(2).replace(".", ",");

    let html = "";
    html += '<div class="page page-goals">';
    html += '<div class="page-header"><h1 class="page-title">Obiettivi e spese grandi pianificate</h1><p class="page-subtitle">Imposta traguardi di risparmio e spese importanti future, collegandoli ai conti</p></div>';
    html += '<div class="layout-two layout-two--main">';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Obiettivi attuali</h2></header>';
    html += '<div class="table-wrap"><table class="table table--goals"><thead><tr><th>Nome</th><th>Target</th><th>Deadline</th><th>Conto di riferimento</th><th>Progress</th><th>Mancano</th><th>Stato</th><th>Azioni</th></tr></thead><tbody>';
    if (!goalsStatus.length) {
        html += '<tr><td colspan="8" class="table-empty">Nessun obiettivo ancora definito.</td></tr>';
    } else {
        for (const g of goalsStatus) {
            html += '<tr><td>'+h(g.name)+'</td><td>'+h(nf(g.target))+'</td><td>'+h(g.deadline)+'</td><td>'+h(g.account_name || "Tutti i conti")+'</td><td>'+h(nf(g.progress))+'</td><td>'+h(nf(g.remaining))+'</td><td>'+h(g.status)+'</td><td>';
            html += '<button class="btn btn--small btn--secondary" data-action="edit-goal" data-id="'+g.id+'">Modifica</button>';
            html += '<button class="btn btn--small btn--danger" data-action="delete-goal" data-id="'+g.id+'">Elimina</button>';
            html += '</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">'+(formData.id?'Modifica obiettivo':'Nuovo obiettivo / spesa grande')+'</h2></header>';
    html += '<form id="goalForm" class="form form-goal">';
    html += '<div class="form-row"><label class="form-label">Nome obiettivo</label><div class="form-field"><input class="input input-text" type="text" name="name" value="'+h(formData.name)+'" required></div></div>';
    html += '<div class="form-row"><label class="form-label">Target (€)</label><div class="form-field"><input class="input input-number" type="number" step="0.01" name="target_amount" value="'+h(formData.target_amount)+'" required></div></div>';
    html += '<div class="form-row"><label class="form-label">Deadline (opzionale)</label><div class="form-field"><input class="input input-date" type="date" name="deadline" value="'+h(formData.deadline)+'"></div></div>';
    html += '<div class="form-row"><label class="form-label">Conto principale</label><div class="form-field"><select class="input input-select" name="account_id"><option value="">Tutti i conti</option>';
    for (const a of accs) {
        html += '<option value="'+a.id+'"'+(formData.account_id===a.id?' selected':'')+'>'+h(a.name)+'</option>';
    }
    html += '</select></div></div>';
    html += '<div class="form-row"><label class="form-label">Descrizione</label><div class="form-field"><textarea class="input input-textarea" name="description" rows="3">'+h(formData.description)+'</textarea></div></div>';
    html += '<div class="form-actions"><button class="btn btn--primary" type="submit">Salva obiettivo</button><button type="button" class="btn btn--secondary" id="goalNewBtn">Nuovo</button></div>';
    html += '<p class="form-help">Gli obiettivi possono rappresentare sia risparmi (es. fondo emergenza) che spese future (es. auto nuova).</p>';
    html += '</form>';
    html += '</section>';

    html += '</div>'; // layout-two
    html += '</div>'; // page

    container.innerHTML = html;

    document.getElementById("goalForm").addEventListener("submit", async e => {
        e.preventDefault();
        const fDom = e.target;
        const name = fDom.name.value.trim();
        const target_amount = parseFloat(fDom.target_amount.value||"0");
        const deadline = fDom.deadline.value || "";
        const accVal = fDom.account_id.value.trim();
        const account_id = accVal ? parseInt(accVal,10) : null;
        const description = fDom.description.value.trim();
        if (!name || target_amount<=0) {
            setMessage("Compila correttamente nome e target.", "warning");
            return;
        }
        const payload = {
            name,
            target_amount,
            deadline,
            account_id,
            description
        };
        try {
            if (formData.id) {
                await apiSend("/goals/" + formData.id, "PUT", payload);
                setMessage("Obiettivo aggiornato.", "success");
            } else {
                await apiSend("/goals", "POST", payload);
                setMessage("Obiettivo creato.", "success");
            }
            app.editGoalId = null;
            await loadState();
        } catch (err) {
            setMessage("Errore salvataggio obiettivo: " + err.message, "error");
        }
    });

    document.getElementById("goalNewBtn").addEventListener("click", () => {
        app.editGoalId = null;
        renderGoals();
    });

    container.querySelectorAll("button[data-action='edit-goal']").forEach(b => {
        b.addEventListener("click", () => {
            app.editGoalId = parseInt(b.dataset.id,10);
            renderGoals();
        });
    });
    container.querySelectorAll("button[data-action='delete-goal']").forEach(b => {
        b.addEventListener("click", async () => {
            const id = parseInt(b.dataset.id,10);
            if (!confirm("Eliminare questo obiettivo?")) return;
            try {
                await apiSend("/goals/" + id, "DELETE", {});
                setMessage("Obiettivo eliminato.", "success");
                await loadState();
            } catch (err) {
                setMessage("Errore eliminazione obiettivo: " + err.message, "error");
            }
        });
    });
}

/* ===========================
 * RENDER: REPORT
 * =========================== */

function renderReports() {
    const container = document.getElementById("content");
    const balances = computeBalances(true);
    const tot = balances.reduce((s,b) => s + b.balance, 0);
    const nf = (x) => Number(x).toFixed(2).replace(".", ",");
    const today = dateFromStr(todayStr());
    if (!app.reportPeriodFilter) {
        app.reportPeriodFilter = {
            start: addDays(today,-30),
            end: today
        };
    }
    if (!app.reportCatFilter) {
        app.reportCatFilter = {
            start: addDays(today,-30),
            end: today,
            dir: "all"
        };
    }
    const pf = app.reportPeriodFilter;
    const cf = app.reportCatFilter;

    const [rpIn,rpOut,rpSpread,rpAvgIn,rpAvgOut] = computePeriodSummary(pf.start, pf.end, true);
    const dirFilter = cf.dir==="in" || cf.dir==="out" ? cf.dir : null;
    const catRows = computeCategoryTotals(cf.start, cf.end, true, dirFilter);

    let html = "";
    html += '<div class="page page-reports">';
    html += '<div class="page-header"><h1 class="page-title">Report e analisi</h1><p class="page-subtitle">Riepilogo saldi, analisi per periodo, categorie, salute e previsioni</p></div>';
    html += '<div class="grid-2 grid-2--reports">';

    html += '<div class="report-column">';
    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Saldi attuali per conto</h2></header>';
    html += '<p class="section-note">Saldo totale complessivo: <strong>'+h(nf(tot))+' €</strong></p>';
    html += '<div class="table-wrap"><table class="table table--accounts"><thead><tr><th>Conto</th><th>Tipologia</th><th>Saldo</th><th>Valuta</th></tr></thead><tbody>';
    if (!balances.length) {
        html += '<tr><td colspan="4" class="table-empty">Nessun conto definito.</td></tr>';
    } else {
        for (const b of balances) {
            html += '<tr><td>'+h(b.name)+'</td><td>'+h(b.type)+'</td><td>'+h(nf(b.balance))+'</td><td>'+h(b.currency)+'</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Analisi salute finanziaria</h2></header>';
    html += '<pre class="report-block">'+h(analyzeHealth(true))+'</pre>';
    html += '</section>';
    html += '</div>'; // colonna sinistra

    html += '<div class="report-column">';
    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Riepilogo entrate/uscite per periodo</h2></header>';
    html += '<form id="rpForm" class="form form-period">';
    html += '<div class="form-row"><label class="form-label">Da data</label><div class="form-field"><input class="input input-date" type="date" name="rp_start" value="'+h(dateToStr(pf.start))+'"></div></div>';
    html += '<div class="form-row"><label class="form-label">A data</label><div class="form-field"><input class="input input-date" type="date" name="rp_end" value="'+h(dateToStr(pf.end))+'"></div></div>';
    html += '<div class="form-actions"><button class="btn btn--primary" type="submit">Ricalcola periodo</button></div>';
    html += '</form>';
    html += '<pre class="report-block">';
    html += "Periodo "+dateToStr(pf.start)+" - "+dateToStr(pf.end)+"\n\n";
    html += "Entrate: "+nf(rpIn)+" €\n";
    html += "Uscite: "+nf(rpOut)+" €\n";
    html += "Spread: "+nf(rpSpread)+" €\n\n";
    html += "Media giornaliera entrate: "+nf(rpAvgIn)+" €\n";
    html += "Media giornaliera uscite: "+nf(rpAvgOut)+" €\n";
    html += '</pre>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Categorie principali nel periodo</h2></header>';
    html += '<form id="rcForm" class="form form-period">';
    html += '<div class="form-row"><label class="form-label">Da data</label><div class="form-field"><input class="input input-date" type="date" name="rc_start" value="'+h(dateToStr(cf.start))+'"></div></div>';
    html += '<div class="form-row"><label class="form-label">A data</label><div class="form-field"><input class="input input-date" type="date" name="rc_end" value="'+h(dateToStr(cf.end))+'"></div></div>';
    html += '<div class="form-row"><label class="form-label">Tipo</label><div class="form-field"><select class="input input-select" name="rc_dir"><option value="all"'+(cf.dir==="all"?' selected':'')+'>Entrate e uscite</option><option value="in"'+(cf.dir==="in"?' selected':'')+'>Solo entrate</option><option value="out"'+(cf.dir==="out"?' selected':'')+'>Solo uscite</option></select></div></div>';
    html += '<div class="form-actions"><button class="btn btn--primary" type="submit">Ricalcola categorie</button></div>';
    html += '</form>';
    html += '<div class="table-wrap"><table class="table table--categories-report"><thead><tr><th>Categoria</th><th>Netto</th><th>Entrate</th><th>Uscite</th></tr></thead><tbody>';
    if (!catRows.length) {
        html += '<tr><td colspan="4" class="table-empty">Nessun dato per il periodo.</td></tr>';
    } else {
        for (const r of catRows) {
            html += '<tr><td>'+h(r.cat)+'</td><td>'+h(nf(r.net))+'</td><td>'+h(nf(r.tot_in))+'</td><td>'+h(nf(r.tot_out))+'</td></tr>';
        }
    }
    html += '</tbody></table></div>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Quanto puoi spendere oggi</h2></header>';
    html += '<pre class="report-block">'+h(computeSafeDailySpendText(true))+'</pre>';
    html += '</section>';

    html += '<section class="section section--panel">';
    html += '<header class="section-header"><h2 class="section-title">Previsione prossimi 3 mesi (solo ricorrenti)</h2></header>';
    html += '<pre class="report-block">'+h(forecastShortText(3,true))+'</pre>';
    html += '</section>';

    html += '</div>'; // colonna destra
    html += '</div>'; // grid-2
    html += '</div>'; // page

    container.innerHTML = html;

    document.getElementById("rpForm").addEventListener("submit", e => {
        e.preventDefault();
        const fDom = e.target;
        const s = dateFromStr(fDom.rp_start.value);
        const ed = dateFromStr(fDom.rp_end.value);
        if (!s || !ed) {
            setMessage("Date non valide.", "warning");
            return;
        }
        app.reportPeriodFilter.start = s;
        app.reportPeriodFilter.end = ed;
        renderReports();
    });

    document.getElementById("rcForm").addEventListener("submit", e => {
        e.preventDefault();
        const fDom = e.target;
        const s = dateFromStr(fDom.rc_start.value);
        const ed = dateFromStr(fDom.rc_end.value);
        const dir = fDom.rc_dir.value;
        if (!s || !ed) {
            setMessage("Date non valide.", "warning");
            return;
        }
        app.reportCatFilter.start = s;
        app.reportCatFilter.end = ed;
        app.reportCatFilter.dir = dir;
        renderReports();
    });
}

/* ===========================
 * INIT
 * =========================== */

document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll(".nav-main .nav-btn").forEach(b => {
        b.addEventListener("click", () => setPage(b.dataset.page));
    });
    setPage("dashboard");
    loadState();
});
</script>
</body>
</html>
