<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Finance UI</title>

  <!-- Theme (tu lo creerai/affinerai dopo)        <link rel="stylesheet" href="fin-theme.css" />                -->
  

  <!-- Base layout + font grandi (minimo indispensabile; puoi spostarlo in fin-theme.css) -->
<style>
/* =========================================================
   FIN UI - PRODUCTION-READY BASE STYLE
   Constraints:
   - HTML structure MUST stay identical.
   - This style improves readability on dark background, adds weekend
     differentiation, better spacing, better focus/hover, and clearer KPIs.
   ========================================================= */

/* ---------- CSS variables (tune here) ---------- */
:root{
  /* Core */
  --bg:#0b0f14;
  --bg2:#0d131b;
  --bg3:#0f1722;
  --fg:#eef3fb;          /* brighter */
  --fg2:#d7e2f3;
  --muted:#b5c3d9;       /* brighter muted */
  --muted2:#8fa2bc;
  --line:rgba(255,255,255,.14);
  --line2:rgba(255,255,255,.08);
  --card:rgba(255,255,255,.07);
  --card2:rgba(255,255,255,.05);
  --shadow: 0 18px 42px rgba(0,0,0,.45);
  --shadow2: 0 10px 22px rgba(0,0,0,.35);

  /* Semantic */
  --good:#1fe28f;
  --bad:#ff5f6a;
  --warn:#ffd166;
  --info:#63b3ff;

  /* Accents */
  --accent:#63b3ff;
  --accent2: rgba(99,179,255,.22);
  --accentLine: rgba(99,179,255,.40);

  /* Typography */
  --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  --fs: 18px;
  --fs-sm: 16px;
  --fs-xs: 14px;
  --fs-lg: 20px;
  --fs-xl: 24px;
  --fs-xxl: 28px;
  --lh: 1.35;

  /* Spacing */
  --r: 16px;
  --r2: 20px;
  --pad: 14px;
  --pad2: 16px;
  --gap: 12px;

  /* Calendar sizing */
  --dayMinH: 128px;
  --dayPad: 12px;
}

/* High-contrast fallback if OS requests it */
@media (prefers-contrast: more){
  :root{
    --line:rgba(255,255,255,.22);
    --line2:rgba(255,255,255,.14);
    --card:rgba(255,255,255,.10);
    --muted:#c6d2e6;
  }
}

/* Reduce motion if requested */
@media (prefers-reduced-motion: reduce){
  *{transition:none!important;animation:none!important;scroll-behavior:auto!important}
}

/* ---------- Global reset & readability ---------- */
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family:var(--font);
  font-size:var(--fs);
  line-height:var(--lh);
  color:var(--fg);
  background:
    radial-gradient(1200px 800px at 15% 0%, rgba(99,179,255,.10), transparent 60%),
    radial-gradient(900px 700px at 90% 15%, rgba(31,226,143,.06), transparent 58%),
    radial-gradient(700px 500px at 50% 100%, rgba(255,209,102,.05), transparent 60%),
    linear-gradient(180deg, var(--bg), var(--bg2));
}

/* Make text selection visible */
::selection{background:rgba(99,179,255,.28);color:var(--fg)}

/* Link */
a{color:color-mix(in oklab, var(--accent), white 20%);text-decoration:none}
a:hover{text-decoration:underline}

/* Inputs and buttons inherit */
button,input,select,textarea{font:inherit}

/* Improve legibility of common “muted” text (avoid too dark on dark bg) */
.muted{color:var(--muted)!important}
.hint{color:var(--muted)!important}
.footnote{color:var(--muted)!important}

/* Monospace */
.mono{font-family:var(--mono)!important}

/* ---------- Header / Topbar / Tabs ---------- */
header{
  position:sticky;
  top:0;
  z-index:50;
  background:
    linear-gradient(to bottom, rgba(11,15,20,.98), rgba(11,15,20,.88));
  border-bottom:1px solid var(--line);
  backdrop-filter: blur(10px);
}

.topbar{
  display:flex;
  gap:var(--gap);
  align-items:center;
  justify-content:space-between;
  padding: 14px 16px;
}

.brand{
  display:flex;
  align-items:center;
  gap:12px;
  min-width:0;
}

.brand h1{
  margin:0;
  font-size: clamp(22px, 2.2vw, 30px);
  letter-spacing:.2px;
  color:var(--fg);
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
}

/* Pills: more contrast, readable */
.pill{
  padding:7px 10px;
  border:1px solid var(--line);
  border-radius:999px;
  background:
    linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  color:var(--fg2);
  box-shadow: 0 6px 16px rgba(0,0,0,.28);
  white-space:nowrap;
  max-width: 100%;
  overflow:hidden;
  text-overflow:ellipsis;
}

.pill .mono{color:var(--fg);opacity:.95}

/* Tabs: larger & clearer */
.tabs{
  display:flex;
  gap:8px;
  padding: 0 16px 12px;
  flex-wrap:wrap;
}

.tabbtn{
  padding:12px 14px;
  border-radius:999px;
  border:1px solid var(--line);
  background:
    linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  color:var(--fg);
  cursor:pointer;
  transition: transform .06s ease, border-color .12s ease, background .12s ease, box-shadow .12s ease;
  box-shadow: 0 8px 18px rgba(0,0,0,.25);
}

.tabbtn:hover{
  border-color: color-mix(in oklab, var(--accentLine), white 10%);
  box-shadow: 0 10px 22px rgba(0,0,0,.32);
}

.tabbtn:active{transform: translateY(1px)}

.tabbtn.active{
  background:
    linear-gradient(180deg, rgba(99,179,255,.25), rgba(99,179,255,.12));
  border-color: rgba(99,179,255,.55);
  box-shadow: 0 12px 26px rgba(0,0,0,.38);
}

/* ---------- Main layout improvements ---------- */
main{
  padding: 14px 16px 44px;
}

.row{
  display:flex;
  gap:var(--gap);
  flex-wrap:wrap;
  align-items:flex-start;
  min-width: 0;
}
.row > *{ min-width: 0; }


.col{
  flex: 1 1 420px;
  min-width: 360px;
}

/* Let large layouts breathe (desktop) */
@media (min-width: 1180px){
  main{padding: 18px 18px 54px}
  .row{gap:14px}
}

/* Mobile */
@media (max-width: 980px){
  .col{min-width: unset}
  .topbar{align-items:flex-start}
  .brand{flex-wrap:wrap}
  .pill{white-space:normal}
}

/* ---------- Panels / Cards ---------- */
.panel{
  background:
    radial-gradient(900px 320px at 18% 0%, rgba(99,179,255,.10), transparent 55%),
    radial-gradient(700px 260px at 88% 0%, rgba(31,226,143,.06), transparent 55%),
    linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
  border:1px solid var(--line);
  border-radius: var(--r2);
  padding: var(--pad2);
  box-shadow: var(--shadow);
}

.panel h2{
  margin:0 0 10px;
  font-size: 22px;
  color:var(--fg);
}

.panel h3{
  margin: 14px 0 10px;
  font-size: 20px;
  color: var(--fg);
}

/* Dividers */
.hr{
  height:1px;
  background: linear-gradient(90deg, transparent, var(--line), transparent);
  margin: 14px 0;
}

/* ---------- Buttons & form controls (production) ---------- */
.btn{
  padding: 11px 13px;
  border-radius: 14px;
  border: 1px solid var(--line);
  background:
    linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
  color: var(--fg);
  cursor: pointer;
  transition: transform .06s ease, border-color .12s ease, box-shadow .12s ease, background .12s ease;
  box-shadow: 0 10px 22px rgba(0,0,0,.30);
}

.btn:hover{
  border-color: color-mix(in oklab, var(--accentLine), white 12%);
  box-shadow: 0 12px 26px rgba(0,0,0,.38);
}

.btn:active{transform: translateY(1px)}

.btn.small{
  padding: 9px 11px;
  border-radius: 12px;
  font-size: var(--fs-sm);
}

.btn.primary{
  background:
    linear-gradient(180deg, rgba(31,226,143,.22), rgba(31,226,143,.12));
  border-color: rgba(31,226,143,.50);
}

.btn.danger{
  background:
    linear-gradient(180deg, rgba(255,95,106,.20), rgba(255,95,106,.10));
  border-color: rgba(255,95,106,.55);
}

.btn:disabled{
  opacity:.55;
  cursor:not-allowed;
  box-shadow:none;
}

/* Better focus visibility */
:focus-visible{
  outline: 3px solid rgba(99,179,255,.55);
  outline-offset: 2px;
  border-radius: 12px;
}

/* Field blocks */
.field{display:flex;flex-direction:column;gap:8px;margin: 10px 0}
.field label{color:var(--muted);font-size:var(--fs-sm)}
.field input,
.field select,
.field textarea{
  padding: 11px 12px;
  border-radius: 14px;
  border: 1px solid var(--line);
  background:
    linear-gradient(180deg, rgba(0,0,0,.26), rgba(0,0,0,.18));
  color: var(--fg);
  outline:none;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
}

.field input::placeholder,
.field textarea::placeholder{color:rgba(215,226,243,.55)}

.field textarea{min-height: 84px;resize:vertical}

/* Grids: clearer spacing */
.grid2{display:grid;grid-template-columns:1fr 1fr;gap: 12px}
.grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap: 12px}

@media (max-width: 980px){
  .grid2,.grid3{grid-template-columns:1fr}
}

/* ---------- KPI blocks ---------- */
.kpiwrap{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(220px,1fr));
  gap: 12px;
  min-width: 0;
}

.kpi{
  background:
    radial-gradient(300px 140px at 15% 0%, rgba(255,255,255,.06), transparent 60%),
    linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.12));
  border:1px solid var(--line2);
  border-radius: 18px;
  padding: 12px 12px 10px;
  box-shadow: 0 12px 24px rgba(0,0,0,.25);
}

.kpi .t{
  color: var(--muted);
  font-size: var(--fs-sm);
  letter-spacing:.1px;
}

.kpi .v{
  font-size: clamp(20px, 1.7vw, 26px);
  margin-top: 8px;
  color: var(--fg);
  text-shadow: 0 1px 0 rgba(0,0,0,.40);
}

.kpi .s{
  margin-top: 8px;
  color: var(--muted);
  font-size: var(--fs-xs);
}

@media (max-width: 980px){
  .kpiwrap{grid-template-columns:repeat(2, minmax(200px,1fr))}
}
@media (max-width: 520px){
  .kpiwrap{grid-template-columns:1fr}
}

/* Money colors - readable */
.money.pos{color: var(--good); text-shadow: 0 0 14px rgba(31,226,143,.12)}
.money.neg{color: var(--bad);  text-shadow: 0 0 14px rgba(255,95,106,.12)}
.money.neu{color: var(--fg)}

.delta.pos{color: var(--good)}
.delta.neg{color: var(--bad)}
.delta.neu{color: var(--muted)}

/* ---------- Calendar bar ---------- */
.calbar{
  display:flex;
  gap: 12px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
}

.calbar .left, .calbar .right{
  display:flex;
  gap: 10px;
  align-items:center;
  flex-wrap:wrap;
}

.monthTitle{
  font-size: clamp(20px, 1.8vw, 26px);
  margin:0;
  color: var(--fg);
}

/* ---------- Calendar container ---------- */
.calendar{
  margin-top: 10px;
  border: 1px solid var(--line);
  border-radius: 18px;
  overflow:hidden;
  background:
    radial-gradient(900px 300px at 22% 0%, rgba(99,179,255,.09), transparent 58%),
    linear-gradient(180deg, rgba(0,0,0,.16), rgba(0,0,0,.08));
  box-shadow: var(--shadow2);
}

.calgrid{display:grid;grid-template-columns:repeat(7,1fr)}

/* Day-of-week header */
.dow{
  padding: 12px 10px;
  border-bottom: 1px solid var(--line);
  color: var(--fg2);
  font-size: var(--fs-xs);
  letter-spacing:.6px;
  text-transform: uppercase;
  background:
    linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
}

/* Weekend labels */
.dow:nth-child(6),
.dow:nth-child(7){
  color: color-mix(in oklab, var(--warn), var(--fg) 55%);
}

/* Day cell */
.day{
  min-height: var(--dayMinH);
  padding: var(--dayPad);
  border-right: 1px solid var(--line2);
  border-bottom: 1px solid var(--line2);
  cursor:pointer;
  position:relative;
  background:
    linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
  transition: background .12s ease, transform .06s ease, outline-color .12s ease;
}

/* remove right border each row end */
.day:nth-child(7n){border-right:none}

/* Weekend differentiation:
   - Because we cannot change HTML, we infer weekend by grid columns:
   - Saturdays are column 6; Sundays column 7.
   - This holds for both header and days because .calgrid uses 7 columns.
   - Note: leading offset cells also affect index, but the visual weekend columns remain correct.
*/
.calgrid .day:nth-child(7n+6){
  background:
    linear-gradient(180deg, rgba(255,209,102,.06), rgba(255,255,255,.02));
}
.calgrid .day:nth-child(7n){
  background:
    linear-gradient(180deg, rgba(255,95,106,.06), rgba(255,255,255,.02));
}

/* Hover: more lift & clarity */
.day:hover{
  background:
    radial-gradient(280px 140px at 18% 0%, rgba(99,179,255,.10), transparent 60%),
    linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
}

/* Selected day */
.day.selected{
  outline: 3px solid rgba(99,179,255,.55);
  outline-offset: -3px;
  background:
    radial-gradient(380px 160px at 20% 0%, rgba(99,179,255,.16), transparent 60%),
    linear-gradient(180deg, rgba(99,179,255,.12), rgba(255,255,255,.02));
}

/* Day header inside cell */
.dayHead{display:flex;align-items:center;justify-content:space-between;gap:8px}
.dayNum{
  font-size: 18px;
  color: var(--fg2);
  font-weight: 650;
}

/* Badge */
.badge{
  font-size: 13px;
  color: var(--fg2);
  border:1px solid var(--line);
  border-radius:999px;
  padding: 4px 9px;
  background:
    linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  box-shadow: 0 8px 16px rgba(0,0,0,.22);
}

/* Event list in day */
.evlist{
  margin-top: 10px;
  display:flex;
  flex-direction:column;
  gap: 8px;
}

/* Event chip */
.ev{
  border:1px solid var(--line);
  border-left-width: 10px;
  border-radius: 14px;
  padding: 9px 10px;
  background:
    linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
  display:flex;
  gap: 10px;
  align-items:flex-start;
  justify-content:space-between;
  box-shadow: 0 10px 18px rgba(0,0,0,.22);
  transition: transform .06s ease, border-color .12s ease, box-shadow .12s ease, background .12s ease;
}

/* Hover & active on events */
.ev:hover{
  border-color: color-mix(in oklab, var(--accentLine), rgba(255,255,255,.14) 60%);
  box-shadow: 0 12px 24px rgba(0,0,0,.32);
}
.ev:active{transform: translateY(1px)}

/* Event text */
.ev .l{display:flex;flex-direction:column;gap:3px;min-width:0}
.ev .ttl{
  font-size: var(--fs-sm);
  color: var(--fg);
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  font-weight: 620;
}
.ev .meta{
  font-size: 13px;
  color: var(--muted);
}

/* Amount */
.ev .amt{
  font-size: var(--fs-sm);
  white-space:nowrap;
  font-weight: 650;
  letter-spacing:.1px;
}

/* Actions inside event rows (right panel) */
.ev .actions{display:flex;gap:8px;align-items:center;flex-shrink:0}

/* Tag */
.tag{
  font-size: 12px;
  padding: 4px 9px;
  border-radius: 999px;
  border: 1px solid var(--line2);
  color: var(--fg2);
  background:
    linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.10));
}

/* ---------- Details / Accordion tree ---------- */
details{
  border: 1px solid var(--line);
  border-radius: 18px;
  background:
    linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.10));
  margin: 12px 0;
  overflow:hidden;
  box-shadow: 0 10px 22px rgba(0,0,0,.26);
}

summary{
  cursor:pointer;
  list-style:none;
  padding: 13px 12px;
  font-size: 18px;
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  background:
    linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  border-bottom: 1px solid rgba(255,255,255,.06);
}

summary::-webkit-details-marker{display:none}

.treeBody{padding: 10px 12px 12px}

.treeRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 10px 0;
  border-top: 1px solid rgba(255,255,255,.06);
}

.treeRow .name{min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--fg2)}
.treeRow .amt{white-space:nowrap;font-weight:650}

/* ---------- Toast ---------- */
.toast{
  position:fixed;
  bottom: 18px;
  left: 18px;
  right: 18px;
  display:none;
  z-index:200;
}

.toast .box{
  max-width: 980px;
  margin: 0 auto;
  border: 1px solid var(--line);
  border-radius: 18px;
  background:
    linear-gradient(180deg, rgba(0,0,0,.84), rgba(0,0,0,.68));
  backdrop-filter: blur(10px);
  padding: 12px 14px;
  box-shadow: 0 16px 34px rgba(0,0,0,.45);
}

.toast .box b{display:block;margin-bottom:6px;color:var(--fg)}

/* ---------- Dialog (Event editor) ---------- */
dialog{
  width: min(900px, calc(100vw - 24px));
  border: 1px solid var(--line);
  border-radius: 20px;
  background:
    radial-gradient(900px 420px at 18% 0%, rgba(99,179,255,.10), transparent 60%),
    linear-gradient(180deg, rgba(11,15,20,.98), rgba(11,15,20,.92));
  color: var(--fg);
  padding: 0;
  box-shadow: 0 20px 46px rgba(0,0,0,.55);
}

dialog::backdrop{background: rgba(0,0,0,.62)}

.dlgHead{
  padding: 12px 14px;
  border-bottom: 1px solid var(--line);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  background:
    linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
}

.dlgHead h2{margin:0;font-size: 22px;color:var(--fg)}

.dlgBody{padding: 14px}

.dlgFoot{
  padding: 12px 14px;
  border-top: 1px solid var(--line);
  display:flex;
  gap: 10px;
  justify-content:flex-end;
  flex-wrap:wrap;
  background:
    linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
}

/* ---------- Accent wallet/category classes (dynamic) ----------
   The JS injects rules for:
   .accent-wallet-<id>
   .accent-cat-<hash>
   Here we provide baseline behavior via CSS variables.
*/
[class*="accent-wallet-"],
[class*="accent-cat-"]{
  --accent: var(--accent); /* fallback */
}

[class*="accent-wallet-"] .panel,
.panel[class*="accent-wallet-"]{
  border-color: color-mix(in oklab, var(--accent), rgba(255,255,255,.14) 55%);
}

/* For event chips and tree rows, the JS sets border-left-color via injected rules.
   We add fallback highlight & subtle glow. */
.ev[class*="accent-"]{
  box-shadow:
    0 10px 18px rgba(0,0,0,.22),
    0 0 0 1px rgba(255,255,255,.02),
    0 0 22px color-mix(in oklab, var(--accent), transparent 82%);
}

/* ---------- Make small text readable everywhere ---------- */
.dow, .ev .meta, .hint, .footnote, .kpi .s, .kpi .t, .field label{
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
}

/* ---------- Improve scrollbars (optional) ---------- */
*::-webkit-scrollbar{height:10px;width:10px}
*::-webkit-scrollbar-track{background:rgba(255,255,255,.05)}
*::-webkit-scrollbar-thumb{
  background:rgba(255,255,255,.16);
  border-radius:999px;
  border:2px solid rgba(0,0,0,.28);
}
*::-webkit-scrollbar-thumb:hover{background:rgba(255,255,255,.22)}

/* ---------- Accessibility helpers ---------- */
@media (max-width: 420px){
  :root{--fs: 17px}
  .btn{width:100%}
  .btn.small{width:auto}
}

/* ---------- Fine-tune existing elements from original HTML ---------- */
#pillStatus{
  max-width: min(52vw, 720px);
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

#pillApi{opacity:.95}
#headersWrap .panel{padding:14px}

/* Day panel event rows: make the edit button more obvious */
#dayEvents .btn.small{
  background:
    linear-gradient(180deg, rgba(99,179,255,.18), rgba(99,179,255,.10));
  border-color: rgba(99,179,255,.35);
}

/* Make select dropdowns in top bar consistent */
.calbar select.btn{
  background:
    linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
  border:1px solid var(--line);
  color:var(--fg);
}

/* Ensure dialog inputs have enough contrast */
dialog .field input,
dialog .field select,
dialog .field textarea{
  background:
    linear-gradient(180deg, rgba(0,0,0,.30), rgba(0,0,0,.20));
  border-color: rgba(255,255,255,.14);
}

/* Prevent overly low opacity on “empty leading cells” in calendar */
.day.outmonth{
  opacity: .55;
  filter: saturate(.75);
}
.day.outmonth .dayNum{ color: rgba(215,226,243,.70); }
.day.outmonth:hover{
  opacity:.80;
  filter:saturate(.95);
}


/* ---------- Production polish: subtle separators & spacing ---------- */
.panel > .row{gap: 12px}
.panel .row .btn{white-space:nowrap}

/* If you want even more separation between major sections */
#tab-calendar .panel,
#tab-overview .panel,
#tab-settings .panel{
  border-color: rgba(255,255,255,.14);
}

/* End : follow patch for bug-fixing*/
/* =========================================================
   PATCH v1 — Fix leggibilità + overflow + layout (no sidebar fissa)
   Target: questa identica versione HTML (nessuna modifica struttura)
   Incolla in FONDO allo <style>.
========================================================= */

/* ---------- A) Leggibilità generale (meno “vetro”, più contrasto) ---------- */
:root{
  --fg:#f4f7ff;
  --fg2:#e6eefc;
  --muted:#c9d6ee;
  --muted2:#a9bbd6;

  /* pannelli meno trasparenti */
  --line:rgba(255,255,255,.18);
  --line2:rgba(255,255,255,.12);
  --card:rgba(255,255,255,.10);
  --card2:rgba(255,255,255,.08);

  --lh: 1.45;
}

body{
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Pannelli più “solidi” per leggere bene */
.panel{
  background:
    linear-gradient(180deg, rgba(20,28,40,.92), rgba(12,16,22,.90)) !important;
  border-color: var(--line) !important;
}

/* Titoli più netti */
.panel h2, .panel h3, .brand h1{
  color: var(--fg) !important;
}

/* Muted meno grigio-fango */
.muted, .hint, .footnote, .kpi .t, .kpi .s, .field label{
  color: var(--muted) !important;
}

/* ---------- B) LAYOUT: Calendario a piena larghezza (no spazio bloccato a destra) ---------- */
/* Nel tab calendario: impila le colonne (calendar full width, pannelli sotto) */
#tab-calendar > .row{
  flex-direction: column !important;
}

/* Prima colonna (calendario) sempre 100% */
#tab-calendar > .row > .col:first-child{
  flex: 1 1 100% !important;
  min-width: 0 !important;
}

/* Seconda colonna (Dettaglio giorno + Azioni rapide) sotto, full width */
#tab-calendar > .row > .col:last-child{
  flex: 1 1 100% !important;
  min-width: 0 !important;
}

/* Riduci “aria” laterale e aumenta area utile calendario */
#tab-calendar .calendar{
  width: 100%;
}

/* ---------- C) OVERFLOW: testate saldi (#headersWrap) ---------- */
/* Il problema tipico: KPI e righe interne non wrappano e “spingono fuori” */
#headersWrap{
  align-items: stretch;
}

#headersWrap .panel{
  min-width: 0 !important;
  overflow: hidden !important;
}

/* KPI grid più permissiva: evita min 220 che su alcune larghezze rompe */
#headersWrap .kpiwrap{
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)) !important;
}

/* KPI: consenti wrap e taglio elegante */
#headersWrap .kpi .v,
#headersWrap .kpi .s,
#headersWrap .kpi .t{
  min-width: 0 !important;
  overflow: hidden;
  text-overflow: ellipsis;
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* Wallet name nelle testate: già ellipsis inline, ma rinforziamo */
#headersWrap [style*="font-size:22px"]{
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  max-width: 100% !important;
}

/* ---------- D) OVERFLOW: righe eventi nel pannello giorno (#dayEvents) ---------- */
/* Il problema tipico: colonna actions (importo+button) spinge fuori */
#dayEvents .ev{
  align-items: stretch !important;
}

#dayEvents .ev .l{
  min-width: 0 !important;
}

/* Titoli/meta/note devono wrappare senza uscire */
#dayEvents .ev .ttl,
#dayEvents .ev .meta{
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* Actions: impila verticalmente su spazi stretti e evita overflow */
#dayEvents .ev .actions{
  flex-direction: column !important;
  align-items: flex-end !important;
  gap: 8px !important;
  max-width: 45% !important;
}

/* Importo: non deve “sparare fuori” */
#dayEvents .ev .amt{
  max-width: 100% !important;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Bottone modifica: non deve allargare */
#dayEvents .ev .btn.small{
  white-space: nowrap;
}

/* ---------- E) OVERFLOW: chip eventi nel calendario (evlist) ---------- */
/* Evita che walletLabel o category lunghi rompano la cella */
.ev .meta, .ev .ttl{
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  overflow-wrap: anywhere;
}

/* Lista eventi in day cell: lascia respirare e taglia bene */
.day .evlist{
  min-width: 0;
}
.day .ev{
  min-width: 0;
}

/* ---------- F) OVERFLOW: Overview cards statement box ---------- */
#cardsStatementBox .panel{
  min-width: 0 !important;
  overflow: hidden !important;
}

#cardsStatementBox [style*="font-size:22px"]{
  max-width: 100% !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
}

/* ---------- G) Bottoni e select: leggibilità + hit area ---------- */
.btn, .tabbtn{
  border-color: var(--line) !important;
}

.btn{
  background:
    linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06)) !important;
}

.field input, .field select, .field textarea{
  background:
    linear-gradient(180deg, rgba(0,0,0,.38), rgba(0,0,0,.26)) !important;
  border-color: var(--line) !important;
}

/* ---------- H) Piccolo polish: badge e tag più leggibili ---------- */
.badge, .tag{
  border-color: var(--line) !important;
  color: var(--fg2) !important;
}

/* =========================================================
   PATCH v2 — “mai testo scuro su scuro” + select/option leggibili
   Incolla in FONDO allo <style>
========================================================= */

/* 1) Forza la UI nativa in dark-mode (dropdown, date picker, scrollbars, ecc.) */
:root{ color-scheme: dark; }
body{ color-scheme: dark; }

/* 2) Default text: qualsiasi testo non esplicitamente stilizzato deve restare chiaro */
body, .panel, details, summary, dialog, .kpi, .ev, .treeBody{
  color: var(--fg) !important;
}

/* 3) Qualsiasi testo “secondario” non deve mai diventare troppo scuro */
.muted, .hint, .footnote, .kpi .t, .kpi .s, .field label, .ev .meta, .dow, .tag, .badge{
  color: var(--muted) !important;
  opacity: 1 !important; /* evita “sbiadito” che su scuro diventa illeggibile */
}

/* 4) Se qualche browser rende i link troppo scuri */
a, a:visited{ color: color-mix(in oklab, var(--accent), white 25%) !important; }

/* =========================================================
   Select & option: fix “testo bianco su sfondo bianco”
========================================================= */

/* Stile del select (chiuso) */
select.btn,
.field select{
  color: var(--fg) !important;
  background-color: rgba(0,0,0,.35) !important; /* fallback solid */
  border-color: var(--line) !important;
}

/* Stile delle opzioni (menu aperto) — molti browser usano il theme del sistema */
select option{
  background-color: #111823 !important; /* scuro */
  color: #f4f7ff !important;           /* chiaro */
}

/* Alcuni browser usano optgroup */
select optgroup{
  background-color: #111823 !important;
  color: #c9d6ee !important;
}

/* Hover/selected nello dropdown (quando supportato) */
select option:checked{
  background-color: #1a2a3f !important;
  color: #ffffff !important;
}

/* =========================================================
   Autofill (Chrome): evita testo scuro / sfondo chiaro
========================================================= */
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill{
  -webkit-text-fill-color: var(--fg) !important;
  box-shadow: 0 0 0px 1000px rgba(0,0,0,.35) inset !important;
  caret-color: var(--fg) !important;
}

</style>


  <!-- dynamic rules for wallets/cards/categories created at runtime -->
  <style id="dynRules"></style>
</head>
<body>
<header>
  <div class="topbar">
    <div class="brand">
      <h1>Finance</h1>
      <span class="pill" id="pillStatus">API: <span class="mono" id="pillApi">…</span></span>
      <span class="pill">Data selezionata: <span class="mono" id="pillDate">…</span></span>
    </div>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <button class="btn small" id="btnReload">Ricarica</button>
      <button class="btn small" id="btnQuickAdd">+ Nuovo evento</button>
    </div>
  </div>
  <div class="tabs">
    <button class="tabbtn active" data-tab="calendar">Calendario</button>
    <button class="tabbtn" data-tab="overview">Panoramica</button>
    <button class="tabbtn" data-tab="settings">Impostazioni</button>
  </div>
</header>

<main>
  <!-- CALENDAR TAB -->
  <section id="tab-calendar">
    <div class="row">
      <div class="col" style="flex: 1 1 980px;">
        <div class="panel">
          <div class="calbar">
            <div class="left">
              <button class="btn small" id="btnPrevMonth">◀</button>
              <h2 class="monthTitle" id="calTitle">…</h2>
              <button class="btn small" id="btnNextMonth">▶</button>
              <span class="pill">Clicca un giorno per aggiornare i saldi e le testate</span>
            </div>
            <div class="right">
              <select id="calWalletFilter" class="btn" style="padding:10px 12px">
                <option value="">Tutti i conti/carte</option>
              </select>
              <button class="btn primary" id="btnAddOnSelected">+ Evento nel giorno selezionato</button>
            </div>
          </div>

          <div class="hr"></div>

          <!-- HEADERS for each wallet/card (auto-updated on day click) -->
          <div id="headersWrap" class="row" style="gap:12px"></div>

          <div class="hr"></div>

          <div class="calendar" id="calendar"></div>
          <div class="footnote" style="margin-top:10px">
            Suggerimento: clicca un evento per modificarlo. Puoi anche duplicare un evento in più mesi.
          </div>
        </div>
      </div>

      <div class="col" style="flex: 1 1 520px;">
        <div class="panel">
          <h2>Dettaglio giorno</h2>
          <div class="muted" id="daySummary">Seleziona un giorno nel calendario.</div>
          <div class="hr"></div>
          <div id="dayEvents"></div>
        </div>

        <div class="panel" style="margin-top:12px">
          <h2>Azioni rapide (utente non esperto)</h2>
          <div class="row">
            <button class="btn" id="btnQuickIncome">+ Entrata</button>
            <button class="btn" id="btnQuickExpense">+ Spesa</button>
            <button class="btn" id="btnQuickCardPurchase">+ Acquisto su carta</button>
            <button class="btn" id="btnQuickRepayment">+ Rimborso carta</button>
          </div>
          <div class="hint" style="margin-top:10px">
            - “Entrata/Spesa” = conto (bank/cash).<br/>
            - “Acquisto su carta” = carta (spesa su plafond).<br/>
            - “Rimborso carta” = pagamento dal conto verso la carta.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- OVERVIEW TAB -->
  <section id="tab-overview" style="display:none">
    <div class="row">
      <div class="col" style="flex: 1 1 920px">
        <div class="panel">
          <h2>Panoramica completa (albero dettagli)</h2>
          <div class="muted">
            Dati riassunti per conti e carte, con confronto mese precedente. Apri i gruppi per scendere di livello.
          </div>
          <div class="hr"></div>
          <div class="row" style="align-items:center">
            <div class="pill">Basato su data selezionata: <span class="mono" id="ovDate">…</span></div>
            <div class="pill">Mese attivo: <span class="mono" id="ovMonth">…</span></div>
          </div>
          <div id="overviewTree"></div>
        </div>
      </div>

      <div class="col" style="flex: 1 1 520px">
        <div class="panel">
          <h2>Carte: subtotali statement</h2>
          <div class="muted">
            Per ogni carta: finestra statement (es. 16→15), baseline, rate, charges/credits, addebito previsto.
          </div>
          <div class="hr"></div>
          <div id="cardsStatementBox"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- SETTINGS TAB -->
  <section id="tab-settings" style="display:none">
    <div class="row">
      <div class="col">
        <div class="panel">
          <h2>Impostazioni applicazione</h2>

          <div class="grid2">
            <div class="field">
              <label>API base (già corretta)</label>
              <input id="apiBase" value="https://iamemanuele.pythonanywhere.com/" />
              <div class="hint">Lascia così. Il frontend usa questa base senza cambiare nomi payload/response.</div>
            </div>

            <div class="field">
              <label>Auto-crea eventi “Addebito carta” (se manca)</label>
              <select id="autoRepayToggle">
                <option value="0">Disattivato</option>
                <option value="1">Attivato</option>
              </select>
              <div class="hint">
                Se attivo: quando cambia qualcosa su una carta, se il backend indica un addebito previsto e non esiste ancora, viene creato automaticamente
                usando <span class="mono">defaultSourceWalletId</span> della carta.
              </div>
            </div>
          </div>

          <div class="hr"></div>

          <h3>Impostazioni per carte (dal backend)</h3>
          <div class="muted">Seleziona una carta e modifica. (Questo scrive su <span class="mono">/finance/cards/&lt;id&gt;/settings</span>.)</div>

          <div class="grid2" style="margin-top:8px">
            <div class="field">
              <label>Carta</label>
              <select id="selCard"></select>
            </div>
            <div class="field">
              <label>Operazione</label>
              <div style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn" id="btnLoadCardSettings">Carica</button>
                <button class="btn primary" id="btnSaveCardSettings">Salva</button>
              </div>
            </div>
          </div>

          <div class="grid3">
            <div class="field"><label>Teilzahlung (importo minimo)</label><input id="csTeil" placeholder="es. 80" /></div>
            <div class="field"><label>Debit day</label><input id="csDebitDay" placeholder="es. 18 / 15" /></div>
            <div class="field"><label>Effective from</label><input id="csEffFrom" placeholder="YYYY-MM-DD" /></div>

            <div class="field"><label>Kreditlimit</label><input id="csLimit" placeholder="es. 3000" /></div>
            <div class="field"><label>Cycle start day</label><input id="csCycleStart" placeholder="es. 16" /></div>
            <div class="field"><label>Cycle end day</label><input id="csCycleEnd" placeholder="es. 15" /></div>

            <div class="field"><label>Sollzins annual</label><input id="csSoll" placeholder="es. 0.169" /></div>
            <div class="field"><label>Effektivzins annual</label><input id="csEff" placeholder="es. 0.189" /></div>
            <div class="field"><label>Debit month offset</label><input id="csOffset" placeholder="0 oppure 1" /></div>
          </div>

          <div class="hr"></div>
          <div class="hint">
            Nota: il colore di carte/categorie/azioni viene assegnato automaticamente (anche per nuove categorie) tramite hashing.
            Puoi poi rifinire in <span class="mono">fin-theme.css</span>.
          </div>
        </div>
      </div>
    </div>
  </section>
</main>

<!-- EVENT DIALOG -->
<dialog id="dlgEvent">
  <div class="dlgHead">
    <h2 id="dlgTitle">Evento</h2>
    <button class="btn small" id="dlgClose">✕</button>
  </div>
  <div class="dlgBody">
    <div class="grid2">
      <div class="field">
        <label>Tipo evento</label>
        <select id="evType">
          <option value="income">Entrata (conto)</option>
          <option value="expense">Spesa (conto)</option>
          <option value="card_purchase">Acquisto su carta</option>
          <option value="card_repayment">Rimborso carta (da conto → carta)</option>
          <option value="card_credit">Credito su carta (rimborso/nota credito)</option>
          <option value="card_charge">Addebito su carta (fee/interessi)</option>
        </select>
        <div class="hint">Scegli il tipo: il form mostra solo i campi necessari.</div>
      </div>

      <div class="field">
        <label>Data evento (calendarDate)</label>
        <input id="evCalendarDate" placeholder="YYYY-MM-DD" />
        <div class="hint">Nel calendario si usa questa data (per la carta l’acquisto usa anche purchaseDate).</div>
      </div>
    </div>

    <div class="grid2">
      <div class="field">
        <label>Titolo</label>
        <input id="evTitle" />
      </div>
      <div class="field">
        <label>Categoria</label>
        <input id="evCategory" placeholder="es. Spesa, Alimentari, Affitto..." />
      </div>
    </div>

    <div class="grid2">
      <div class="field">
        <label>Importo</label>
        <input id="evAmount" placeholder="es. 19.90" />
      </div>
      <div class="field">
        <label>Note</label>
        <input id="evNotes" />
      </div>
    </div>

    <!-- Conditional fields -->
    <div id="boxWallet" class="grid2" style="display:none">
      <div class="field">
        <label>Conto (walletId)</label>
        <select id="evWalletId"></select>
      </div>
      <div class="field">
        <label>(Opzionale) Serie mensile</label>
        <select id="evSeriesMode">
          <option value="none">Nessuna serie</option>
          <option value="monthly_12">Mensile (12 mesi)</option>
          <option value="monthly_24">Mensile (24 mesi)</option>
          <option value="monthly_forever">Mensile (lunga durata)</option>
        </select>
      </div>
    </div>

    <div id="boxCardPurchase" style="display:none">
      <div class="grid2">
        <div class="field">
          <label>Carta (cardWalletId)</label>
          <select id="evCardWalletId"></select>
        </div>
        <div class="field">
          <label>Data acquisto (purchaseDate)</label>
          <input id="evPurchaseDate" placeholder="YYYY-MM-DD" />
          <div class="hint">Per la carta, la data contabile è purchaseDate (fallback calendarDate).</div>
        </div>
      </div>

      <div class="grid2">
        <div class="field">
          <label>Pagamento</label>
          <select id="evScheduleKind">
            <option value="instant">Unica soluzione</option>
            <option value="financing_monthly">Rate mensili (importo fisso)</option>
            <option value="financing_custom">Rate personalizzate (date + importi)</option>
          </select>
        </div>
        <div class="field" id="boxFinFirst" style="display:none">
          <label>Prima rata: statement month (YYYY-MM)</label>
          <input id="evFirstStmtMonth" placeholder="es. 2026-03" />
        </div>
      </div>

      <div class="grid2" id="boxFinMonthly" style="display:none">
        <div class="field">
          <label>Numero rate (count)</label>
          <input id="evFinCount" placeholder="es. 12" />
        </div>
        <div class="field">
          <label>Importo rata (opzionale)</label>
          <input id="evFinInstAmount" placeholder="se vuoto = totale / count" />
        </div>
      </div>

      <div class="field" id="boxFinCustom" style="display:none">
        <label>Rate personalizzate</label>
        <textarea id="evFinCustomJson" class="mono" placeholder='[
  {"date":"2026-03-10","amount":50},
  {"date":"2026-04-10","amount":50}
]'></textarea>
        <div class="hint">Inserisci JSON array: ogni rata con <span class="mono">date</span> e <span class="mono">amount</span>.</div>
      </div>
    </div>

    <div id="boxRepayment" class="grid2" style="display:none">
      <div class="field">
        <label>Da conto (fromWalletId)</label>
        <select id="evFromWalletId"></select>
      </div>
      <div class="field">
        <label>A carta (toCardWalletId)</label>
        <select id="evToCardWalletId"></select>
      </div>
      <div class="field">
        <label>Data pagamento (paymentDate)</label>
        <input id="evPaymentDate" placeholder="YYYY-MM-DD" />
      </div>
      <div class="field">
        <label>Categoria (consigliata)</label>
        <input id="evRepCategory" value="Card Repayment" />
      </div>
    </div>

    <div id="boxCardCredit" class="grid2" style="display:none">
      <div class="field">
        <label>Carta (cardWalletId)</label>
        <select id="evCardCreditWalletId"></select>
      </div>
      <div class="field">
        <label>subType (opzionale)</label>
        <input id="evSubTypeCredit" placeholder="gutschrift / mapped_income / ..." />
      </div>
    </div>

    <div id="boxCardCharge" class="grid2" style="display:none">
      <div class="field">
        <label>Carta (cardWalletId)</label>
        <select id="evCardChargeWalletId"></select>
      </div>
      <div class="field">
        <label>subType</label>
        <select id="evSubTypeCharge">
          <option value="interest_card">interest_card</option>
          <option value="fee_card">fee_card</option>
          <option value="interest_financing">interest_financing</option>
        </select>
      </div>
    </div>

    <div class="hr"></div>

    <details>
      <summary>
        <span>Duplicazione (stesso evento in più mesi)</span>
        <span class="tag">Opzionale</span>
      </summary>
      <div class="treeBody">
        <div class="grid2">
          <div class="field">
            <label>Duplica per N mesi (crea copie)</label>
            <input id="dupMonths" placeholder="es. 3 (crea copie nei prossimi 3 mesi)" />
          </div>
          <div class="field">
            <label>Regola date</label>
            <select id="dupRule">
              <option value="same_day_or_last">Stesso giorno (se non esiste → ultimo giorno del mese)</option>
              <option value="first_day">Primo giorno del mese</option>
              <option value="last_day">Ultimo giorno del mese</option>
            </select>
          </div>
        </div>
        <div class="hint">
          Questo crea eventi separati (drop-in) senza cambiare backend. Per entrate/spese puoi anche usare “Serie mensile”.
        </div>
      </div>
    </details>
  </div>

  <div class="dlgFoot">
    <button class="btn danger" id="btnDeleteEvent" style="display:none">Elimina</button>
    <button class="btn" id="btnCancelEvent">Annulla</button>
    <button class="btn primary" id="btnSaveEvent">Salva</button>
  </div>
</dialog>

<div class="toast" id="toast">
  <div class="box">
    <b id="toastTitle">Info</b>
    <div id="toastMsg" class="muted"></div>
  </div>
</div>

<script>
/* =========================
   Utilities
========================= */
const $ = (id)=>document.getElementById(id);

function toast(title, msg){
  $("toastTitle").textContent = title || "Info";
  $("toastMsg").textContent = msg || "";
  $("toast").style.display = "block";
  clearTimeout(window.__toastT);
  window.__toastT = setTimeout(()=>{ $("toast").style.display="none"; }, 4200);
}

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function pad2(n){ return String(n).padStart(2,"0"); }

function isoDate(d){
  const y=d.getFullYear(), m=d.getMonth()+1, day=d.getDate();
  return `${y}-${pad2(m)}-${pad2(day)}`;
}

function parseISO(s){
  if(!s || typeof s!=="string") return null;
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s.trim());
  if(!m) return null;
  const dt = new Date(Number(m[1]), Number(m[2])-1, Number(m[3]));
  if(Number.isNaN(dt.getTime())) return null;
  return dt;
}

function ymStr(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}`; }

function monthStart(d){ return new Date(d.getFullYear(), d.getMonth(), 1); }
function monthEnd(d){ return new Date(d.getFullYear(), d.getMonth()+1, 0); }

function addMonthsJS(d, n){
  const y = d.getFullYear();
  const m = d.getMonth();
  const day = d.getDate();
  const tgt = new Date(y, m+n, 1);
  const last = new Date(tgt.getFullYear(), tgt.getMonth()+1, 0).getDate();
  const dd = Math.min(day, last);
  return new Date(tgt.getFullYear(), tgt.getMonth(), dd);
}

function samePeriodPrevMonth(from, to){
  // same day span previous month (clamp day)
  const f = addMonthsJS(from, -1);
  const t = addMonthsJS(to, -1);
  return {from:f, to:t};
}

function fmtMoney(x){
  const v = Number(x || 0);
  const s = v.toLocaleString("it-IT", {minimumFractionDigits:2, maximumFractionDigits:2});
  return s + " €";
}
function moneyClassSigned(v){
  const x = Number(v||0);
  if(x>0) return "pos";
  if(x<0) return "neg";
  return "neu";
}
function deltaClass(v){
  const x = Number(v||0);
  if(x>0) return "pos";
  if(x<0) return "neg";
  return "neu";
}

/* hash → stable HSL color */
function hash32(str){
  let h=2166136261>>>0;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h>>>0;
}
function hslFromKey(key){
  const h = hash32(String(key)) % 360;
  const s = 64;
  const l = 48;
  return `hsl(${h} ${s}% ${l}%)`;
}
function ensureDynRule(selector, color){
  // create CSS rule with left border & accent usage
  const style = $("dynRules");
  const css = `${selector}{--accent:${color};border-left-color:var(--accent)!important}
${selector} .tag{border-color:color-mix(in oklab, var(--accent), rgba(255,255,255,.15) 60%);color:color-mix(in oklab, var(--accent), white 35%)}
${selector} .ttl{color:color-mix(in oklab, var(--accent), white 28%)}
`;
  if(!style.__set) style.__set = new Set();
  if(style.__set.has(selector)) return;
  style.__set.add(selector);
  style.textContent += "\n" + css;
}

/* =========================
   API
========================= */
function apiBase(){
  // fixed as per your setup
  const raw = ($("apiBase").value || "https://iamemanuele.pythonanywhere.com/").trim();
  return raw.replace(/\/+$/, "");
}
async function apiFetch(path, opts={}){
  const base = apiBase();
  const url = base.replace(/\/+$/, "") + path;
  const res = await fetch(url, {
    headers: {"Content-Type":"application/json"},
    ...opts
  });
  if(!res.ok){
    let txt=""; try{ txt=await res.text(); }catch{}
    throw new Error(`HTTP ${res.status} ${res.statusText} - ${txt}`);
  }
  const ct = (res.headers.get("content-type")||"").toLowerCase();
  if(ct.includes("application/json")) return await res.json();
  return await res.text();
}

/* =========================
   State
========================= */
const state = {
  wallets: [],
  events: [],
  dashboard: null,
  selectedDate: new Date(),
  visibleMonth: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
  walletFilter: "",

  // caches
  walletsById: new Map(),
  cardIds: new Set(),
  walletNameById: new Map(),
};

function saveLocal(){
  localStorage.setItem("fin_ui_apiBase", $("apiBase").value);
  localStorage.setItem("fin_ui_autoRepay", $("autoRepayToggle").value);
}
function loadLocal(){
  const a = localStorage.getItem("fin_ui_apiBase");
  if(a) $("apiBase").value = a;
  const t = localStorage.getItem("fin_ui_autoRepay");
  if(t) $("autoRepayToggle").value = t;
}

/* =========================
   Data loading
========================= */
async function loadWallets(){
  const ws = await apiFetch("/wallets");
  state.wallets = Array.isArray(ws) ? ws : [];
  state.walletsById = new Map(state.wallets.map(w=>[String(w.id), w]));
  state.walletNameById = new Map(state.wallets.map(w=>[String(w.id), w.name]));
  state.cardIds = new Set(state.wallets.filter(w=>w.type==="card").map(w=>String(w.id)));

  // color rules per wallet
  for(const w of state.wallets){
    const key = `wallet:${w.id}:${w.type}:${w.name}`;
    ensureDynRule(`.accent-wallet-${w.id}`, hslFromKey(key));
  }
}

function dateRangeForMonth(m0){
  const ms = monthStart(m0);
  const me = monthEnd(m0);
  // fetch a wider range to show cross-window events near month edges
  const from = addDays(ms, -10);
  const to   = addDays(me,  10);
  return {from, to};
}
function addDays(d, n){
  const x = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  x.setDate(x.getDate()+n);
  return x;
}

async function loadEventsForVisibleMonth(){
  const {from, to} = dateRangeForMonth(state.visibleMonth);
  const qs = new URLSearchParams({
    from: isoDate(from),
    to: isoDate(to)
  });
  // optional wallet filter: backend supports walletId
  if(state.walletFilter){
    qs.set("walletId", state.walletFilter);
  }
  const ev = await apiFetch("/events?"+qs.toString());
  state.events = Array.isArray(ev) ? ev : [];
}

async function loadDashboard(){
  const asOf = state.selectedDate ? isoDate(state.selectedDate) : isoDate(new Date());
  const month = ymStr(state.visibleMonth);
  const qs = new URLSearchParams({ asOf, month });
  const d = await apiFetch("/dashboard?"+qs.toString());
  state.dashboard = d || null;
}

/* =========================
   Auto-create repayment events (optional)
========================= */
async function maybeAutoCreateRepayments(){
  if($("autoRepayToggle").value !== "1") return;
  if(!state.dashboard || !state.dashboard.wallets) return;

  // We only create if:
  // - wallet is card
  // - scheduledRepayment.exists == false
  // - defaultSourceWalletId exists
  // - paymentDate within a reasonable window (current visible month ± 1)
  const month = state.visibleMonth;
  const winFrom = addMonthsJS(monthStart(month), -1);
  const winTo = addMonthsJS(monthEnd(month), 1);

  // Preload events in a wider range to avoid duplicates
  const {from, to} = dateRangeForMonth(month);
  const qs = new URLSearchParams({from: isoDate(addDays(from,-40)), to: isoDate(addDays(to,40))});
  const all = await apiFetch("/events?"+qs.toString());
  const allEvents = Array.isArray(all) ? all : [];

  for(const w of state.dashboard.wallets){
    if(w.type !== "card") continue;
    const cardId = String(w.id);
    const card = w.card;
    if(!card || !card.scheduledRepayment) continue;
    const sr = card.scheduledRepayment;
    if(sr.exists) continue;

    const payDate = parseISO(sr.paymentDate);
    if(!payDate) continue;
    if(payDate < winFrom || payDate > winTo) continue;

    // Need defaultSourceWalletId (backend gives it in wallets list, not dashboard card.settings)
    const walletRow = state.walletsById.get(cardId);
    const defaultSourceId = walletRow ? walletRow.defaultSourceWalletId : null;
    if(!defaultSourceId) continue;

    // Check if already present: card_repayment with toCardWalletId=cardId and paymentDate=sr.paymentDate
    const already = allEvents.some(e =>
      e.type==="card_repayment" &&
      String(e.toCardWalletId||"")===cardId &&
      String(e.paymentDate||"")===sr.paymentDate &&
      (e.status||"active")!=="skipped"
    );
    if(already) continue;

    // Create event
    const payload = {
      type: "card_repayment",
      title: "Addebito carta (auto)",
      amount: Number(sr.suggestedAmount || sr.baselineAmount || 0),
      category: "Card Repayment",
      calendarDate: sr.paymentDate,
      notes: "Creato automaticamente",
      fromWalletId: Number(defaultSourceId),
      toCardWalletId: Number(cardId),
      paymentDate: sr.paymentDate
    };
    if(!payload.amount || payload.amount<=0) continue;

    try{
      await apiFetch("/events", {method:"POST", body: JSON.stringify(payload)});
      toast("Addebito carta creato", `Carta ${w.name}: ${sr.paymentDate} - ${fmtMoney(payload.amount)}`);
    }catch(err){
      // non bloccare UX
      console.warn("auto-repayment failed", err);
    }
  }
}

/* =========================
   Rendering: Tabs
========================= */
function setTab(name){
  for(const b of document.querySelectorAll(".tabbtn")){
    b.classList.toggle("active", b.dataset.tab===name);
  }
  $("tab-calendar").style.display = (name==="calendar") ? "" : "none";
  $("tab-overview").style.display = (name==="overview") ? "" : "none";
  $("tab-settings").style.display = (name==="settings") ? "" : "none";
  if(name==="overview") renderOverview();
}

/* =========================
   Rendering: Headers (per wallet/card)
========================= */
function renderHeaders(){
  const wrap = $("headersWrap");
  wrap.innerHTML = "";

  if(!state.dashboard || !state.dashboard.wallets){
    wrap.innerHTML = `<div class="muted">Caricamento testate…</div>`;
    return;
  }

  // One header per wallet, collapsed into cards
  for(const w of state.dashboard.wallets){
    // apply accent class by wallet id
    const cls = `panel accent-wallet-${w.id}`;
    const card = document.createElement("div");
    card.className = cls;
    card.style.flex = "1 1 420px";
    card.style.minWidth = "210px";
    card.style.padding = "14px";
    card.style.overflow = "hidden";


    const typeLabel = (w.type==="card") ? "Carta" : "Conto";
    const selected = isoDate(state.selectedDate);

    const bal = Number(w.balance || 0);
    const spentSoFar = Number(w.spentSoFar || 0);
    const spentRem = Number(w.spentRemaining || 0);
    const incSoFar = Number(w.incomeSoFar || 0);
    const incRem = Number(w.incomeRemaining || 0);

    const dExp = w.compareLastMonthExpenses || {amount:0, percent:0};
    const dInc = w.compareLastMonthIncome || {amount:0, percent:0};

    const expDiff = Number(dExp.amount||0);
    const incDiff = Number(dInc.amount||0);

    let extra = "";
    if(w.type==="card" && w.card){
      const c = w.card;
      const lim = c.limit!=null ? fmtMoney(c.limit) : "—";
      const avail = c.availableCredit!=null ? fmtMoney(c.availableCredit) : "—";
      const out = c.outstanding!=null ? fmtMoney(c.outstanding) : "—";
      const sr = c.scheduledRepayment || null;
      extra = `
        <div class="hr"></div>
        <div class="row" style="gap:10px;align-items:stretch">
          <div class="kpi" style="flex:1">
            <div class="t">Plafond</div>
            <div class="v">${lim}</div>
            <div class="s">Disponibile: <span class="money ${moneyClassSigned(Number(c.availableCredit||0))}">${avail}</span></div>
          </div>
          <div class="kpi" style="flex:1">
            <div class="t">Usato (outstanding)</div>
            <div class="v"><span class="money neg">${out}</span></div>
            <div class="s">Saldo carta: <span class="money neg">${fmtMoney(Number(w.balance||0))}</span></div>
          </div>
        </div>
        ${sr ? `
          <div class="hr"></div>
          <div class="row" style="gap:10px;align-items:center;justify-content:space-between">
            <div>
              <div class="t muted">Addebito previsto</div>
              <div class="v" style="font-size:20px">
                <span class="mono">${sr.paymentDate}</span> ·
                <span class="money neg">${fmtMoney(Number(sr.suggestedAmount||0))}</span>
                <span class="tag" style="margin-left:8px">${sr.exists ? "registrato" : "mancante"}</span>
              </div>
            </div>
          </div>
        `:""}
      `;
    }

    card.innerHTML = `
      <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:10px">
        <div style="min-width:0">
          <div class="muted">${typeLabel}</div>
          <div style="font-size:22px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:100%">${escapeHtml(w.name||"")}</div>
          <div class="muted">Aggiornato al giorno: <span class="mono">${selected}</span></div>
        </div>
        <div style="text-align:right">
          <div class="muted">Saldo</div>
          <div style="font-size:26px" class="money ${moneyClassSigned(bal)}">${fmtMoney(bal)}</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="kpiwrap" style="grid-template-columns:repeat(auto-fit, minmax(220px,1fr))">

        <div class="kpi">
          <div class="t">Spese nel mese</div>
          <div class="v"><span class="money neg">${fmtMoney(-spentSoFar).replace("-", "")}</span></div>
          <div class="s">Δ mese scorso: <span class="delta ${deltaClass(expDiff)}">${fmtMoney(expDiff)}</span></div>
        </div>
        <div class="kpi">
          <div class="t">Entrate nel mese</div>
          <div class="v"><span class="money pos">${fmtMoney(incSoFar)}</span></div>
          <div class="s">Δ mese scorso: <span class="delta ${deltaClass(incDiff)}">${fmtMoney(incDiff)}</span></div>
        </div>
        <div class="kpi">
          <div class="t">Spese rimanenti</div>
          <div class="v"><span class="money neg">${fmtMoney(-spentRem).replace("-", "")}</span></div>
          <div class="s">fino a fine mese</div>
        </div>
        <div class="kpi">
          <div class="t">Entrate rimanenti</div>
          <div class="v"><span class="money pos">${fmtMoney(incRem)}</span></div>
          <div class="s">fino a fine mese</div>
        </div>
      </div>

      ${extra}
    `;
    wrap.appendChild(card);
  }
}

/* =========================
   Rendering: Calendar
========================= */
const DOW = ["Lun","Mar","Mer","Gio","Ven","Sab","Dom"];

function eventEffectiveDayISO(ev){
  // calendar shows based on:
  // - card_purchase: purchaseDate fallback calendarDate
  // - card_repayment: paymentDate preferred? (but backend stores calendarDate anyway)
  if(ev.type==="card_purchase"){
    return (ev.purchaseDate || ev.calendarDate || ev.date || ev.effectiveDate || "").slice(0,10);
  }
  if(ev.type==="card_repayment"){
    return (ev.paymentDate || ev.calendarDate || ev.date || ev.effectiveDate || "").slice(0,10);
  }
  return (ev.calendarDate || ev.date || ev.effectiveDate || "").slice(0,10);
}

function normalizeEventForUI(ev){
  // Ensure accent rules: by wallet/card + type + category
  const wid = ev.walletId!=null ? String(ev.walletId) : null;
  const cid = ev.cardWalletId!=null ? String(ev.cardWalletId) : (ev.toCardWalletId!=null ? String(ev.toCardWalletId) : null);
  const type = ev.type || "";
  const cat  = ev.category || "";
  const sub  = ev.subType || "";

  // dynamic category accent (also for new categories)
  const catKey = `cat:${type}:${cat}:${sub}`;
  const catClass = "accent-cat-" + hash32(catKey);
  ensureDynRule(`.${catClass}`, hslFromKey(catKey));

  const walletClass = wid ? `accent-wallet-${wid}` : "";
  const cardClass   = cid ? `accent-wallet-${cid}` : "";

  // choose main accent:
  // for card events, prefer card accent
  const accentClass = (type.startsWith("card_") && cid) ? cardClass : walletClass;

  return {...ev, __day: eventEffectiveDayISO(ev), __catClass: catClass, __accentClass: accentClass};
}

function renderCalendar(){
  $("calTitle").textContent = state.visibleMonth.toLocaleString("it-IT", {month:"long", year:"numeric"}).replace(/^\w/, c=>c.toUpperCase());

  const cal = $("calendar");
  cal.innerHTML = "";

  const ms = monthStart(state.visibleMonth);
  const me = monthEnd(state.visibleMonth);

  // Build header row (DOW)
  const head = document.createElement("div");
  head.className = "calgrid";
  for(const d of DOW){
    const el = document.createElement("div");
    el.className = "dow";
    el.textContent = d;
    head.appendChild(el);
  }
  cal.appendChild(head);

  // Determine first day offset (Mon=0)
  const firstJS = new Date(ms.getFullYear(), ms.getMonth(), 1);
  let jsDay = firstJS.getDay(); // Sun=0
  let offset = (jsDay===0) ? 6 : jsDay-1;

  const grid = document.createElement("div");
  grid.className = "calgrid";

  // Normalize events
  const evs = state.events.map(normalizeEventForUI);

  // Group by day (ISO)
  const byDay = new Map();
  for(const e of evs){
    if(!e.__day) continue;
    if(!byDay.has(e.__day)) byDay.set(e.__day, []);
    byDay.get(e.__day).push(e);
  }
  for(const [k,arr] of byDay.entries()){
    arr.sort((a,b)=> (a.id||0)-(b.id||0));
  }

  // Outlook-like grid: always 6 weeks (42 days), including prev/next month days
  const gridStart = addDays(ms, -offset);          // Monday of first grid row
  const totalCells = 42;

  for(let i=0;i<totalCells;i++){
    const cur = addDays(gridStart, i);
    const dayIso = isoDate(cur);
    const list = byDay.get(dayIso) || [];

    const inThisMonth = (cur.getMonth() === ms.getMonth());
    const el = document.createElement("div");
    el.className = "day";
    if(!inThisMonth) el.classList.add("outmonth");
    if(isoDate(state.selectedDate)===dayIso) el.classList.add("selected");

    const count = list.length;

    el.innerHTML = `
      <div class="dayHead">
        <div class="dayNum">${cur.getDate()}</div>
        ${count ? `<div class="badge">${count} eventi</div>` : `<div class="badge">—</div>`}
      </div>
      <div class="evlist"></div>
    `;

    el.addEventListener("click", ()=> onSelectDay(cur));

    const evlist = el.querySelector(".evlist");
    const shown = list.slice(0, 3);
    for(const ev of shown){
      evlist.appendChild(renderEventChip(ev));
    }
    if(list.length>3){
      const more = document.createElement("div");
      more.className = "muted";
      more.style.fontSize = "13px";
      more.textContent = `+ altri ${list.length-3}`;
      evlist.appendChild(more);
    }

    grid.appendChild(el);
  }


  cal.appendChild(grid);

  // right panel details
  renderDayPanel();
}

function renderEventChip(ev){
  const el = document.createElement("div");
  el.className = `ev ${ev.__accentClass} ${ev.__catClass}`;
  el.dataset.id = ev.id;

  const sign = (ev.type==="income" || ev.type==="card_credit") ? "+" :
               (ev.type==="expense" || ev.type==="card_purchase" || ev.type==="card_charge" || ev.type==="card_repayment") ? "-" : "";

  const amt = Number(ev.amount||0);
  const isPos = (ev.type==="income" || ev.type==="card_credit");
  const amtCls = isPos ? "pos" : "neg";

  const walletLabel = (() => {
    if(ev.type==="income" || ev.type==="expense"){
      return state.walletNameById.get(String(ev.walletId||"")) || "Conto";
    }
    if(ev.type==="card_purchase" || ev.type==="card_credit" || ev.type==="card_charge"){
      return state.walletNameById.get(String(ev.cardWalletId||"")) || "Carta";
    }
    if(ev.type==="card_repayment"){
      const from = state.walletNameById.get(String(ev.fromWalletId||"")) || "Conto";
      const to = state.walletNameById.get(String(ev.toCardWalletId||"")) || "Carta";
      return `${from} → ${to}`;
    }
    return "";
  })();

  const tag = (ev.type==="card_purchase" && ev.schedule && ev.schedule.kind==="financing") ? "rate" :
              (ev.type==="card_repayment") ? "rimborso" :
              (ev.type==="card_credit") ? "credito" :
              (ev.type==="card_charge") ? (ev.subType||"addebito") :
              (ev.type==="income") ? "entrata" :
              (ev.type==="expense") ? "spesa" : ev.type;

  el.innerHTML = `
    <div class="l" style="min-width:0">
      <div class="ttl">${escapeHtml(ev.title||"")}</div>
      <div class="meta">${escapeHtml(ev.category||"")} · <span class="tag">${escapeHtml(tag)}</span></div>
      <div class="meta">${escapeHtml(walletLabel)}</div>
    </div>
    <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
      <div class="amt money ${amtCls}">${sign}${fmtMoney(amt).replace(" €","")} €</div>
    </div>
  `;

  // stop propagation so clicking chip doesn't change selected day unexpectedly
  el.addEventListener("click", (e)=>{
    e.stopPropagation();
    openEditEvent(ev.id);
  });

  return el;
}

/* =========================
   Day panel (right)
========================= */
function renderDayPanel(){
  const dayIso = isoDate(state.selectedDate);
  $("pillDate").textContent = dayIso;
  $("ovDate").textContent = dayIso;
  $("ovMonth").textContent = ymStr(state.visibleMonth);

  const evs = state.events.map(normalizeEventForUI).filter(e=>e.__day===dayIso);
  const filt = state.walletFilter ? String(state.walletFilter) : "";
  const shown = filt ? evs.filter(e=>{
    // keep those linked to filtered wallet
    const w = String(filt);
    return String(e.walletId||"")===w || String(e.cardWalletId||"")===w || String(e.fromWalletId||"")===w || String(e.toCardWalletId||"")===w;
  }) : evs;

  $("daySummary").innerHTML = `
    <div style="font-size:20px"><b>${dayIso}</b></div>
    <div class="muted">${shown.length} eventi</div>
  `;

  const box = $("dayEvents");
  box.innerHTML = "";
  if(!shown.length){
    box.innerHTML = `<div class="muted">Nessun evento in questo giorno.</div>`;
    return;
  }

  for(const ev of shown.sort((a,b)=>(a.id||0)-(b.id||0))){
    const row = document.createElement("div");
    row.className = `ev ${ev.__accentClass} ${ev.__catClass}`;
    row.style.borderLeftWidth = "10px";

    const isPos = (ev.type==="income" || ev.type==="card_credit");
    const amtCls = isPos ? "pos" : "neg";
    const sign = isPos ? "+" : "-";
    const walletLabel = (() => {
      if(ev.type==="income" || ev.type==="expense"){
        return state.walletNameById.get(String(ev.walletId||"")) || "Conto";
      }
      if(ev.type==="card_purchase" || ev.type==="card_credit" || ev.type==="card_charge"){
        return state.walletNameById.get(String(ev.cardWalletId||"")) || "Carta";
      }
      if(ev.type==="card_repayment"){
        const from = state.walletNameById.get(String(ev.fromWalletId||"")) || "Conto";
        const to = state.walletNameById.get(String(ev.toCardWalletId||"")) || "Carta";
        return `${from} → ${to}`;
      }
      return "";
    })();

    row.innerHTML = `
      <div class="l" style="min-width:0">
        <div class="ttl">${escapeHtml(ev.title||"")}</div>
        <div class="meta">${escapeHtml(ev.category||"")} · ${escapeHtml(walletLabel)}</div>
        <div class="meta">${escapeHtml(ev.notes||"")}</div>
      </div>
      <div class="actions">
        <div class="amt money ${amtCls}">${sign}${fmtMoney(Number(ev.amount||0)).replace(" €","")} €</div>
        <button class="btn small" data-act="edit">Modifica</button>
      </div>
    `;
    row.querySelector("[data-act=edit]").addEventListener("click", ()=>openEditEvent(ev.id));
    box.appendChild(row);
  }
}

/* =========================
   Overview: tree + card subtotals
========================= */
function groupSum(items, keyFn){
  const m = new Map();
  for(const it of items){
    const k = keyFn(it);
    m.set(k, (m.get(k)||0) + Number(it.amount||0));
  }
  return [...m.entries()].map(([k,v])=>({k, v}));
}

/* =========================================================
   PATCH JS — Overview “completa e intuitiva”
   Target: SOLO modifica funzione renderOverview() (no HTML changes)
   Cosa aggiunge:
   A) Monthly Summary globale (totali mese + delta vs mese scorso + per mezzo)
   B) “Da fare” (eventi futuri nel mese + rimborsi carta mancanti)
   C) Dettagli rimborsi/finanziamenti (subType, schedule, rate, ecc.)
========================================================= */

function renderOverview(){
  if(!state.dashboard || !state.dashboard.wallets){
    $("overviewTree").innerHTML = `<div class="muted">Caricamento…</div>`;
    $("cardsStatementBox").innerHTML = "";
    return;
  }

  const tree = $("overviewTree");
  tree.innerHTML = "";

  // Helpers locali (renderOverview scope)
  const ms = monthStart(state.visibleMonth);
  const me = monthEnd(state.visibleMonth);
  const prev = samePeriodPrevMonth(ms, me);
  const today = new Date();
  const today0 = new Date(today.getFullYear(), today.getMonth(), today.getDate());

  const allEvsNorm = state.events.map(normalizeEventForUI);

  function within(d, a, b){ return d && d >= a && d <= b; }

  function isInMonth(ev){
    const d = parseISO(ev.__day);
    return within(d, ms, me);
  }
  function isInPrevMonth(ev){
    const d = parseISO(ev.__day);
    return within(d, prev.from, prev.to);
  }

  function evSign(ev){
    // cashflow sign convention for summary:
    // + income, + card_credit
    // - expense, - card_purchase, - card_charge, - card_repayment (cash out from account)
    if(ev.type === "income") return +1;
    if(ev.type === "card_credit") return +1;
    if(ev.type === "expense") return -1;
    if(ev.type === "card_purchase") return -1;
    if(ev.type === "card_charge") return -1;
    if(ev.type === "card_repayment") return -1;
    return 0;
  }

  function cashIn(ev){
    const s = evSign(ev);
    return s > 0 ? Number(ev.amount||0) : 0;
  }
  function cashOut(ev){
    const s = evSign(ev);
    return s < 0 ? Number(ev.amount||0) : 0;
  }

  function labelForPaymentMethod(ev){
    // “mezzo” leggibile
    if(ev.type==="income" || ev.type==="expense"){
      return state.walletNameById.get(String(ev.walletId||"")) || "Conto";
    }
    if(ev.type==="card_purchase" || ev.type==="card_credit" || ev.type==="card_charge"){
      return state.walletNameById.get(String(ev.cardWalletId||"")) || "Carta";
    }
    if(ev.type==="card_repayment"){
      const from = state.walletNameById.get(String(ev.fromWalletId||"")) || "Conto";
      const to = state.walletNameById.get(String(ev.toCardWalletId||"")) || "Carta";
      return `${from} → ${to}`;
    }
    return "Altro";
  }

  function fmtDelta(v){
    const cls = deltaClass(v);
    return `<span class="delta ${cls}">${fmtMoney(v)}</span>`;
  }

  // =========================
  // A) MONTHLY SUMMARY (globale)
  // =========================
  const evMonth = allEvsNorm.filter(isInMonth);
  const evPrevM = allEvsNorm.filter(isInPrevMonth);

  const sumIn  = evMonth.reduce((a,e)=>a+cashIn(e), 0);
  const sumOut = evMonth.reduce((a,e)=>a+cashOut(e), 0);
  const net    = sumIn - sumOut;

  const prevIn  = evPrevM.reduce((a,e)=>a+cashIn(e), 0);
  const prevOut = evPrevM.reduce((a,e)=>a+cashOut(e), 0);
  const prevNet = prevIn - prevOut;

  const dIn  = sumIn - prevIn;
  const dOut = sumOut - prevOut;
  const dNet = net - prevNet;

  // Totali “per mezzo”
  const byMethod = new Map(); // label -> {in,out,net,count}
  for(const e of evMonth){
    const k = labelForPaymentMethod(e);
    if(!byMethod.has(k)) byMethod.set(k, {in:0,out:0,net:0,count:0});
    const row = byMethod.get(k);
    row.in  += cashIn(e);
    row.out += cashOut(e);
    row.net += (cashIn(e) - cashOut(e));
    row.count += 1;
  }
  const byMethodArr = [...byMethod.entries()]
    .map(([k,v])=>({k,...v}))
    .sort((a,b)=> (b.out - a.out) || (b.in - a.in));

  // Render Summary Panel (senza cambiare HTML: lo inseriamo come HTML dentro overviewTree)
  const summary = document.createElement("div");
  summary.className = "panel";
  summary.innerHTML = `
    <h3 style="margin-top:0">Riepilogo mese (globale)</h3>
    <div class="muted">Periodo: <span class="mono">${ymStr(state.visibleMonth)}</span> · basato su data selezionata: <span class="mono">${isoDate(state.selectedDate)}</span></div>
    <div class="hr"></div>

    <div class="kpiwrap" style="grid-template-columns:repeat(auto-fit, minmax(220px,1fr))">
      <div class="kpi">
        <div class="t">Totale entrate</div>
        <div class="v"><span class="money pos">${fmtMoney(sumIn)}</span></div>
        <div class="s">Δ mese scorso: ${fmtDelta(dIn)}</div>
      </div>
      <div class="kpi">
        <div class="t">Totale uscite</div>
        <div class="v"><span class="money neg">${fmtMoney(sumOut)}</span></div>
        <div class="s">Δ mese scorso: ${fmtDelta(dOut)}</div>
      </div>
      <div class="kpi">
        <div class="t">Saldo netto mese</div>
        <div class="v"><span class="money ${moneyClassSigned(net)}">${fmtMoney(net)}</span></div>
        <div class="s">Δ mese scorso: ${fmtDelta(dNet)}</div>
      </div>
      <div class="kpi">
        <div class="t">Eventi nel mese</div>
        <div class="v">${evMonth.length}</div>
        <div class="s">Conti + Carte</div>
      </div>
    </div>

    <details style="margin-top:12px" open>
      <summary><span>Per mezzo (conto/carta)</span><span class="tag">${byMethodArr.length}</span></summary>
      <div class="treeBody">
        ${
          byMethodArr.map(x=>`
            <div class="treeRow">
              <div class="name">${escapeHtml(x.k)} <span class="muted" style="font-size:14px">· ${x.count} eventi</span></div>
              <div class="amt" style="display:flex;gap:10px;align-items:center">
                <span class="money pos">${fmtMoney(x.in)}</span>
                <span class="money neg">${fmtMoney(x.out)}</span>
                <span class="money ${moneyClassSigned(x.net)}">${fmtMoney(x.net)}</span>
              </div>
            </div>
          `).join("")
          || `<div class="muted">Nessun dato nel mese.</div>`
        }
        <div class="hint" style="margin-top:8px">Colonne: Entrate · Uscite · Netto</div>
      </div>
    </details>
  `;
  tree.appendChild(summary);

  // =========================
  // B) “DA FARE” (futuri + rimborsi mancanti)
  // =========================
  // B1: eventi futuri nel mese (calendar/purchase/payment day > oggi)
  const futureInMonth = evMonth.filter(e=>{
    const d = parseISO(e.__day);
    return d && d > today0;
  }).sort((a,b)=> (a.__day||"").localeCompare(b.__day||"") || (a.id||0)-(b.id||0));

  // B2: scheduled repayments mancanti nel mese (da dashboard)
  const missingRepay = [];
  for(const w of (state.dashboard.wallets||[])){
    if(w.type!=="card") continue;
    const sr = w.card && w.card.scheduledRepayment;
    if(!sr || sr.exists) continue;
    const pd = parseISO(sr.paymentDate);
    if(!pd) continue;
    if(pd < ms || pd > me) continue;
    // solo “da fare” se data >= oggi
    if(pd < today0) continue;

    missingRepay.push({
      cardId: String(w.id),
      cardName: w.name || `Carta #${w.id}`,
      paymentDate: sr.paymentDate,
      suggestedAmount: Number(sr.suggestedAmount||sr.baselineAmount||0),
    });
  }
  missingRepay.sort((a,b)=> (a.paymentDate||"").localeCompare(b.paymentDate||""));

  const todo = document.createElement("div");
  todo.className = "panel";
  todo.style.marginTop = "12px";
  todo.innerHTML = `
    <h3 style="margin-top:0">Da fare (nel mese)</h3>
    <div class="muted">Cose future rispetto a oggi (${isoDate(today0)}).</div>
    <div class="hr"></div>

    <details open>
      <summary><span>Eventi futuri già registrati</span><span class="tag">${futureInMonth.length}</span></summary>
      <div class="treeBody">
        ${
          futureInMonth.map(e=>`
            <div class="treeRow ${e.__catClass}">
              <div class="name" style="min-width:0">
                <div><b>${escapeHtml(e.__day||"")}</b> · ${escapeHtml(e.title||"")}</div>
                <div class="muted" style="font-size:14px">${escapeHtml(labelForPaymentMethod(e))} · ${escapeHtml(e.category||"")} · ${escapeHtml(e.type||"")}</div>
              </div>
              <div class="amt money ${(evSign(e)>0)?"pos":"neg"}">${(evSign(e)>0?"+":"-")}${fmtMoney(Number(e.amount||0)).replace(" €","")} €</div>
            </div>
          `).join("") || `<div class="muted">Nessun evento futuro nel mese.</div>`
        }
      </div>
    </details>

    <details style="margin-top:10px" open>
      <summary><span>Rimborsi carta previsti ma mancanti</span><span class="tag">${missingRepay.length}</span></summary>
      <div class="treeBody">
        ${
          missingRepay.map(x=>`
            <div class="treeRow">
              <div class="name">
                <div><b>${escapeHtml(x.paymentDate)}</b> · ${escapeHtml(x.cardName)}</div>
                <div class="muted" style="font-size:14px">scheduledRepayment mancante</div>
              </div>
              <div class="amt" style="display:flex;gap:10px;align-items:center">
                <span class="money neg">${fmtMoney(x.suggestedAmount)}</span>
                <button class="btn small" data-create-repay="${escapeHtml(x.cardId)}">Crea ora</button>
              </div>
            </div>
          `).join("") || `<div class="muted">Nessun rimborso mancante nel mese.</div>`
        }
        <div class="hint" style="margin-top:8px">“Crea ora” usa la logica già presente (defaultSourceWalletId della carta).</div>
      </div>
    </details>
  `;
  tree.appendChild(todo);

  // wire “Crea ora” buttons (riuso tua funzione esistente)
  for(const btn of todo.querySelectorAll("[data-create-repay]")){
    btn.addEventListener("click", async ()=>{
      await createRepaymentNowForCard(String(btn.getAttribute("data-create-repay")));
    });
  }

  // =========================
  // C) Dettagli rimborsi/finanziamenti: arricchiamo la vista per wallet
  // =========================

  // Build tree for each wallet (come prima, ma con dettagli aggiuntivi)
  for(const w of state.dashboard.wallets){
    const wid = String(w.id);
    const isCard = w.type==="card";
    const accent = `accent-wallet-${w.id}`;

    const evs = allEvsNorm.filter(e=>{
      const d = parseISO(e.__day);
      if(!within(d, ms, me)) return false;

      if(isCard){
        const cid = String(e.cardWalletId||e.toCardWalletId||"");
        return cid===wid;
      }else{
        return String(e.walletId||e.fromWalletId||"")===wid;
      }
    });

    const incomes = evs.filter(e=> e.type==="income" || (isCard && e.type==="card_repayment"));
    const expenses = evs.filter(e=> e.type==="expense" || (isCard && (e.type==="card_purchase" || e.type==="card_charge")));

    const expByCat = groupSum(expenses, e=> e.category||"Senza categoria").sort((a,b)=>b.v-a.v);
    const incByCat = groupSum(incomes,  e=> e.category||"Senza categoria").sort((a,b)=>b.v-a.v);

    function extraLineForEvent(e){
      // C) componenti/dettagli
      // - subType (credit/charge)
      // - schedule (financing)
      if(e.type==="card_credit"){
        const st = (e.subType||"").trim();
        return st ? `<div class="muted" style="font-size:14px">subType: <span class="mono">${escapeHtml(st)}</span></div>` : "";
      }
      if(e.type==="card_charge"){
        const st = (e.subType||"").trim();
        return st ? `<div class="muted" style="font-size:14px">subType: <span class="mono">${escapeHtml(st)}</span></div>` : "";
      }
      if(e.type==="card_purchase"){
        const sch = e.schedule || null;
        if(sch && sch.kind==="financing"){
          const first = sch.firstStatementMonth || "—";
          const count = Number(sch.count||0);
          // custom installments (componenti)
          const ci = Array.isArray(sch.customInstallments) ? sch.customInstallments : null;
          if(ci && ci.length){
            const lines = ci.slice(0,6).map(x=>`${escapeHtml(String(x.date||""))}: ${fmtMoney(Number(x.amount||0))}`).join(" · ");
            const more = ci.length>6 ? ` · +${ci.length-6}` : "";
            return `
              <div class="muted" style="font-size:14px">
                rate (custom): <span class="mono">${escapeHtml(first)}</span> · count: <span class="mono">${count}</span>
              </div>
              <div class="muted" style="font-size:14px">componenti: ${lines}${more}</div>
            `;
          }
          // monthly installments
          const inst = sch.monthlyInstallments && sch.monthlyInstallments.installmentAmount!=null
            ? Number(sch.monthlyInstallments.installmentAmount)
            : null;
          return `
            <div class="muted" style="font-size:14px">
              rate (mensili): <span class="mono">${escapeHtml(first)}</span> · count: <span class="mono">${count}</span>
              ${inst ? `· quota: <span class="mono">${fmtMoney(inst)}</span>` : ""}
            </div>
          `;
        }
      }
      if(e.type==="card_repayment"){
        const pd = (e.paymentDate||"").slice(0,10);
        return pd ? `<div class="muted" style="font-size:14px">paymentDate: <span class="mono">${escapeHtml(pd)}</span></div>` : "";
      }
      return "";
    }

    const det = document.createElement("details");
    det.className = accent;
    det.open = false;
    det.innerHTML = `
      <summary>
        <span style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">
          <b>${escapeHtml(w.name||"")}</b>
          <span class="tag" style="margin-left:8px">${isCard ? "carta" : "conto"}</span>
        </span>
        <span class="money ${moneyClassSigned(Number(w.balance||0))}">${fmtMoney(Number(w.balance||0))}</span>
      </summary>
      <div class="treeBody">
        <div class="grid2">
          <div class="kpi">
            <div class="t">Spese mese</div>
            <div class="v"><span class="money neg">${fmtMoney(-Number(w.spentSoFar||0)).replace("-","")}</span></div>
            <div class="s">Δ mese scorso: <span class="delta ${deltaClass(Number((w.compareLastMonthExpenses||{}).amount||0))}">${fmtMoney(Number((w.compareLastMonthExpenses||{}).amount||0))}</span></div>
          </div>
          <div class="kpi">
            <div class="t">Entrate mese</div>
            <div class="v"><span class="money pos">${fmtMoney(Number(w.incomeSoFar||0))}</span></div>
            <div class="s">Δ mese scorso: <span class="delta ${deltaClass(Number((w.compareLastMonthIncome||{}).amount||0))}">${fmtMoney(Number((w.compareLastMonthIncome||{}).amount||0))}</span></div>
          </div>
        </div>

        <div class="hr"></div>

        <details class="${accent}" style="margin:10px 0">
          <summary><span>Spese per categoria</span><span class="tag">${expByCat.length}</span></summary>
          <div class="treeBody">
            ${expByCat.map(x=>`
              <div class="treeRow ${catAccentClass("expense", x.k)}">
                <div class="name">${escapeHtml(x.k)}</div>
                <div class="amt money neg">${fmtMoney(-x.v).replace("-","")}</div>
              </div>
            `).join("") || `<div class="muted">Nessuna spesa nel mese.</div>`}
          </div>
        </details>

        <details class="${accent}" style="margin:10px 0">
          <summary><span>Entrate per categoria</span><span class="tag">${incByCat.length}</span></summary>
          <div class="treeBody">
            ${incByCat.map(x=>`
              <div class="treeRow ${catAccentClass("income", x.k)}">
                <div class="name">${escapeHtml(x.k)}</div>
                <div class="amt money pos">${fmtMoney(x.v)}</div>
              </div>
            `).join("") || `<div class="muted">Nessuna entrata nel mese.</div>`}
          </div>
        </details>

        <details class="${accent}" style="margin:10px 0" open>
          <summary><span>Dettaglio eventi del mese (con componenti)</span><span class="tag">${evs.length}</span></summary>
          <div class="treeBody">
            ${evs
              .sort((a,b)=> (a.__day||"").localeCompare(b.__day||"") || (a.id||0)-(b.id||0))
              .map(e=>`
                <div class="treeRow ${e.__catClass}">
                  <div class="name" style="min-width:0">
                    <div><b>${escapeHtml(e.__day||"")}</b> · ${escapeHtml(e.title||"")}</div>
                    <div class="muted" style="font-size:14px">${escapeHtml(e.category||"")} · ${escapeHtml(e.type||"")}</div>
                    ${extraLineForEvent(e)}
                  </div>
                  <div class="amt money ${(evSign(e)>0) ? "pos":"neg"}">${(evSign(e)>0?"+":"-")}${fmtMoney(Number(e.amount||0)).replace(" €","")} €</div>
                </div>
              `).join("") || `<div class="muted">Nessun evento nel mese.</div>`}
          </div>
        </details>

        <div class="hint">Per modificare: vai su Calendario e clicca l’evento.</div>
      </div>
    `;
    tree.appendChild(det);
  }

  // =========================
  // Cards statement box (tuo codice originale invariato)
  // =========================
  const cbox = $("cardsStatementBox");
  cbox.innerHTML = "";
  const cards = state.dashboard.wallets.filter(w=>w.type==="card");

  if(!cards.length){
    cbox.innerHTML = `<div class="muted">Nessuna carta.</div>`;
    return;
  }

  for(const w of cards){
    const accent = `accent-wallet-${w.id}`;
    const s = (w.card && w.card.statement) ? w.card.statement : null;
    const sr = (w.card && w.card.scheduledRepayment) ? w.card.scheduledRepayment : null;

    const el = document.createElement("div");
    el.className = `panel ${accent}`;
    el.style.marginBottom = "12px";
    el.innerHTML = `
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start">
        <div style="min-width:0">
          <div class="muted">Carta</div>
          <div style="font-size:22px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHtml(w.name||"")}</div>
        </div>
        <div style="text-align:right">
          <div class="muted">Saldo</div>
          <div class="money neg" style="font-size:22px">${fmtMoney(Number(w.balance||0))}</div>
        </div>
      </div>

      ${s ? `
        <div class="hr"></div>
        <div class="muted">Statement window: <span class="mono">${s.window.start}</span> → <span class="mono">${s.window.end}</span></div>
        <div class="grid2" style="margin-top:10px">
          <div class="kpi">
            <div class="t">Baseline statement</div>
            <div class="v money neg">${fmtMoney(Number(s.baselineAmount||0))}</div>
            <div class="s">Instant: ${Number(s.instantPurchasesCount||0)} · Rate: ${Number((s.installments||[]).length||0)}</div>
          </div>
          <div class="kpi">
            <div class="t">Charges / Credits</div>
            <div class="v">
              <span class="money neg">${fmtMoney(Number(s.charges||0))}</span> /
              <span class="money pos">${fmtMoney(Number(s.credits||0))}</span>
            </div>
            <div class="s">Addebito previsto sotto</div>
          </div>
        </div>
      ` : `<div class="hr"></div><div class="muted">Nessun dettaglio statement disponibile.</div>`}

      ${sr ? `
        <div class="hr"></div>
        <div class="row" style="justify-content:space-between;align-items:center">
          <div>
            <div class="muted">Addebito previsto</div>
            <div style="font-size:20px">
              <span class="mono">${sr.paymentDate}</span> · <span class="money neg">${fmtMoney(Number(sr.suggestedAmount||0))}</span>
              <span class="tag" style="margin-left:8px">${sr.exists ? "registrato" : "mancante"}</span>
            </div>
          </div>
          <button class="btn small" data-create-repay="${w.id}" ${sr.exists ? "disabled":""}>Crea addebito ora</button>
        </div>
      `:""}
    `;
    cbox.appendChild(el);

    const btn = el.querySelector("[data-create-repay]");
    if(btn){
      btn.addEventListener("click", async ()=>{
        await createRepaymentNowForCard(String(w.id));
      });
    }
  }
}


function catAccentClass(type, category){
  const key = `cat:${type}:${category||""}`;
  const cls = "accent-cat-" + hash32(key);
  ensureDynRule(`.${cls}`, hslFromKey(key));
  return cls;
}

/* manual create repayment for card from statement box */
async function createRepaymentNowForCard(cardId){
  await loadDashboard(); // refresh
  const w = (state.dashboard.wallets||[]).find(x=>String(x.id)===String(cardId));
  if(!w || !w.card || !w.card.scheduledRepayment) return;

  const sr = w.card.scheduledRepayment;
  if(sr.exists){
    toast("Già presente", "Esiste già un rimborso registrato per quella data.");
    return;
  }
  const walletRow = state.walletsById.get(String(cardId));
  const defaultSourceId = walletRow ? walletRow.defaultSourceWalletId : null;
  if(!defaultSourceId){
    toast("Impossibile", "La carta non ha defaultSourceWalletId (imposta il conto sorgente della carta).");
    return;
  }
  const payload = {
    type: "card_repayment",
    title: "Addebito carta (manuale)",
    amount: Number(sr.suggestedAmount || sr.baselineAmount || 0),
    category: "Card Repayment",
    calendarDate: sr.paymentDate,
    notes: "Creato manualmente dalla UI",
    fromWalletId: Number(defaultSourceId),
    toCardWalletId: Number(cardId),
    paymentDate: sr.paymentDate
  };
  await apiFetch("/events", {method:"POST", body: JSON.stringify(payload)});
  toast("Creato", `Rimborso carta creato: ${sr.paymentDate} · ${fmtMoney(payload.amount)}`);
  await refreshAll();
}

/* =========================
   Event CRUD
========================= */
function fillWalletSelects(){
  // Wallet selects:
  const nonCards = state.wallets.filter(w=>w.type!=="card");
  const cards = state.wallets.filter(w=>w.type==="card");

  const options = (arr, placeholder) => {
    const o = [`<option value="">${placeholder}</option>`];
    for(const w of arr){
      o.push(`<option value="${w.id}">${escapeHtml(w.name)} (#${w.id})</option>`);
    }
    return o.join("");
  };

  $("evWalletId").innerHTML = options(nonCards, "Seleziona conto…");
  $("evFromWalletId").innerHTML = options(nonCards, "Seleziona conto…");
  $("evCardWalletId").innerHTML = options(cards, "Seleziona carta…");
  $("evToCardWalletId").innerHTML = options(cards, "Seleziona carta…");
  $("evCardCreditWalletId").innerHTML = options(cards, "Seleziona carta…");
  $("evCardChargeWalletId").innerHTML = options(cards, "Seleziona carta…");

  // Calendar filter
  const f = $("calWalletFilter");
  const cur = f.value;
  f.innerHTML = `<option value="">Tutti i conti/carte</option>` + state.wallets.map(w=>(
    `<option value="${w.id}">${escapeHtml(w.name)} (${w.type})</option>`
  )).join("");
  f.value = cur || "";

  // Cards selector in settings
  const sc = $("selCard");
  const scCur = sc.value;
  sc.innerHTML = cards.map(w=>`<option value="${w.id}">${escapeHtml(w.name)} (#${w.id})</option>`).join("");
  if(scCur) sc.value = scCur;
}

function resetEventDialog(){
  $("dlgTitle").textContent = "Nuovo evento";
  $("btnDeleteEvent").style.display = "none";
  $("dlgEvent").dataset.editId = "";

  // base fields
  $("evType").value = "expense";
  $("evCalendarDate").value = isoDate(state.selectedDate);
  $("evTitle").value = "";
  $("evCategory").value = "";
  $("evAmount").value = "";
  $("evNotes").value = "";

  // series
  $("evSeriesMode").value = "none";

  // card purchase
  $("evPurchaseDate").value = isoDate(state.selectedDate);
  $("evScheduleKind").value = "instant";
  $("evFirstStmtMonth").value = "";
  $("evFinCount").value = "";
  $("evFinInstAmount").value = "";
  $("evFinCustomJson").value = "";

  // repayment
  $("evPaymentDate").value = isoDate(state.selectedDate);
  $("evRepCategory").value = "Card Repayment";

  // subtype
  $("evSubTypeCredit").value = "gutschrift";

  // duplication
  $("dupMonths").value = "";
  $("dupRule").value = "same_day_or_last";

  updateDialogVisibility();
}

function updateDialogVisibility(){
  const t = $("evType").value;

  $("boxWallet").style.display = (t==="income" || t==="expense") ? "" : "none";
  $("boxCardPurchase").style.display = (t==="card_purchase") ? "" : "none";
  $("boxRepayment").style.display = (t==="card_repayment") ? "" : "none";
  $("boxCardCredit").style.display = (t==="card_credit") ? "" : "none";
  $("boxCardCharge").style.display = (t==="card_charge") ? "" : "none";

  const sk = $("evScheduleKind").value;
  const isFin = (sk==="financing_monthly" || sk==="financing_custom");
  $("boxFinFirst").style.display = isFin ? "" : "none";
  $("boxFinMonthly").style.display = (sk==="financing_monthly") ? "" : "none";
  $("boxFinCustom").style.display = (sk==="financing_custom") ? "" : "none";
}

function openNewEvent(presetType=null){
  resetEventDialog();
  if(presetType) $("evType").value = presetType;
  if(presetType==="card_purchase"){
    $("evCalendarDate").value = isoDate(state.selectedDate);
    $("evPurchaseDate").value = isoDate(state.selectedDate);
  }
  if(presetType==="card_repayment"){
    $("evCalendarDate").value = isoDate(state.selectedDate);
    $("evPaymentDate").value = isoDate(state.selectedDate);
  }
  updateDialogVisibility();
  $("dlgEvent").showModal();
}

function findEventById(id){
  return state.events.find(e=>String(e.id)===String(id));
}

function openEditEvent(id){
  const ev = findEventById(id);
  if(!ev){
    toast("Errore", "Evento non trovato in memoria (ricarica).");
    return;
  }
  resetEventDialog();
  $("dlgTitle").textContent = "Modifica evento";
  $("btnDeleteEvent").style.display = "";
  $("dlgEvent").dataset.editId = String(ev.id);

  $("evType").value = ev.type || "expense";
  $("evCalendarDate").value = (ev.calendarDate||"").slice(0,10);
  $("evTitle").value = ev.title || "";
  $("evCategory").value = ev.category || "";
  $("evAmount").value = String(ev.amount || "");
  $("evNotes").value = ev.notes || "";

  // wallet
  if(ev.walletId!=null) $("evWalletId").value = String(ev.walletId);

  // card purchase
  if(ev.type==="card_purchase"){
    if(ev.cardWalletId!=null) $("evCardWalletId").value = String(ev.cardWalletId);
    $("evPurchaseDate").value = (ev.purchaseDate||ev.calendarDate||"").slice(0,10);

    const sch = ev.schedule || {};
    if(sch && sch.kind==="financing"){
      // decide kind
      if(Array.isArray(sch.customInstallments) && sch.customInstallments.length){
        $("evScheduleKind").value = "financing_custom";
        $("evFinCustomJson").value = JSON.stringify(sch.customInstallments, null, 2);
      }else{
        $("evScheduleKind").value = "financing_monthly";
        $("evFinCount").value = String(sch.count || "");
        if(sch.monthlyInstallments && sch.monthlyInstallments.installmentAmount!=null){
          $("evFinInstAmount").value = String(sch.monthlyInstallments.installmentAmount);
        }
      }
      $("evFirstStmtMonth").value = sch.firstStatementMonth || "";
    }else{
      $("evScheduleKind").value = "instant";
    }
  }

  // repayment
  if(ev.type==="card_repayment"){
    if(ev.fromWalletId!=null) $("evFromWalletId").value = String(ev.fromWalletId);
    if(ev.toCardWalletId!=null) $("evToCardWalletId").value = String(ev.toCardWalletId);
    $("evPaymentDate").value = (ev.paymentDate||ev.calendarDate||"").slice(0,10);
    $("evRepCategory").value = ev.category || "Card Repayment";
  }

  // credit
  if(ev.type==="card_credit"){
    if(ev.cardWalletId!=null) $("evCardCreditWalletId").value = String(ev.cardWalletId);
    $("evSubTypeCredit").value = ev.subType || "gutschrift";
  }

  // charge
  if(ev.type==="card_charge"){
    if(ev.cardWalletId!=null) $("evCardChargeWalletId").value = String(ev.cardWalletId);
    $("evSubTypeCharge").value = ev.subType || "fee_card";
  }

  updateDialogVisibility();
  $("dlgEvent").showModal();
}

function buildPayloadFromDialog(){
  const type = $("evType").value;
  const title = $("evTitle").value.trim();
  const category = $("evCategory").value.trim();
  const notes = $("evNotes").value || "";
  const calendarDate = $("evCalendarDate").value.trim();
  const amount = Number(String($("evAmount").value).replace(",", "."));

  if(!title) throw new Error("Titolo mancante.");
  if(!category) throw new Error("Categoria mancante.");
  if(!calendarDate || !/^\d{4}-\d{2}-\d{2}$/.test(calendarDate)) throw new Error("calendarDate non valida.");
  if(!Number.isFinite(amount) || amount<=0) throw new Error("Importo non valido.");

  if(type==="income" || type==="expense"){
    const walletId = Number($("evWalletId").value||0);
    if(!walletId) throw new Error("Seleziona un conto.");
    const payload = { type, title, amount, category, calendarDate, notes, walletId };
    // optional series
    const sm = $("evSeriesMode").value;
    if(sm!=="none"){
      const months = (sm==="monthly_12")?12 : (sm==="monthly_24")?24 : 120;
      payload.series = {
        frequency: "monthly",
        durationMode: (sm==="monthly_forever") ? "forever" : "n_months",
        months: (sm==="monthly_forever") ? null : months,
        firstDate: calendarDate
      };
    }
    return payload;
  }

  if(type==="card_purchase"){
    const cardWalletId = Number($("evCardWalletId").value||0);
    if(!cardWalletId) throw new Error("Seleziona una carta.");
    const purchaseDate = $("evPurchaseDate").value.trim();
    if(!purchaseDate || !/^\d{4}-\d{2}-\d{2}$/.test(purchaseDate)) throw new Error("purchaseDate non valida.");

    const sk = $("evScheduleKind").value;
    let schedule = { kind:"instant" };

    if(sk==="financing_monthly"){
      const firstStatementMonth = $("evFirstStmtMonth").value.trim();
      if(!/^\d{4}-\d{2}$/.test(firstStatementMonth)) throw new Error("firstStatementMonth non valido (YYYY-MM).");
      const count = Number(($("evFinCount").value||"").trim());
      if(!Number.isFinite(count) || count<=0) throw new Error("Numero rate non valido.");
      const instAmountStr = ($("evFinInstAmount").value||"").trim();
      const instAmount = instAmountStr ? Number(instAmountStr.replace(",", ".")) : null;
      schedule = {
        kind: "financing",
        count,
        firstStatementMonth,
        monthlyInstallments: instAmount!=null && Number.isFinite(instAmount) && instAmount>0 ? {installmentAmount: instAmount} : {}
      };
    }

    if(sk==="financing_custom"){
      const firstStatementMonth = $("evFirstStmtMonth").value.trim();
      if(firstStatementMonth && !/^\d{4}-\d{2}$/.test(firstStatementMonth)) throw new Error("firstStatementMonth non valido (YYYY-MM).");
      let arr;
      try{ arr = JSON.parse($("evFinCustomJson").value || "[]"); }catch{ throw new Error("Rate personalizzate: JSON non valido."); }
      if(!Array.isArray(arr) || !arr.length) throw new Error("Rate personalizzate: inserisci almeno 1 rata.");
      // backend normalizza count = len(ci)
      schedule = {
        kind: "financing",
        count: arr.length,
        firstStatementMonth: firstStatementMonth || null,
        customInstallments: arr
      };
      // se firstStatementMonth non dato, backend lo calcola dalla prima data valida
    }

    return {
      type, title, amount, category,
      calendarDate: purchaseDate, // per coerenza: calendarDate = purchaseDate (come nel tuo backend)
      purchaseDate,
      cardWalletId,
      notes,
      schedule
    };
  }

  if(type==="card_repayment"){
    const fromWalletId = Number($("evFromWalletId").value||0);
    const toCardWalletId = Number($("evToCardWalletId").value||0);
    const paymentDate = $("evPaymentDate").value.trim();
    if(!fromWalletId) throw new Error("Seleziona il conto sorgente.");
    if(!toCardWalletId) throw new Error("Seleziona la carta.");
    if(!paymentDate || !/^\d{4}-\d{2}-\d{2}$/.test(paymentDate)) throw new Error("paymentDate non valida.");
    return {
      type, title,
      amount,
      category: ($("evRepCategory").value||category||"Card Repayment"),
      calendarDate,
      notes,
      fromWalletId,
      toCardWalletId,
      paymentDate
    };
  }

  if(type==="card_credit"){
    const cardWalletId = Number($("evCardCreditWalletId").value||0);
    if(!cardWalletId) throw new Error("Seleziona una carta.");
    const subType = ($("evSubTypeCredit").value||"").trim() || "gutschrift";
    return {
      type, title, amount, category, calendarDate, notes,
      cardWalletId,
      subType
    };
  }

  if(type==="card_charge"){
    const cardWalletId = Number($("evCardChargeWalletId").value||0);
    if(!cardWalletId) throw new Error("Seleziona una carta.");
    const subType = $("evSubTypeCharge").value;
    return {
      type, title, amount, category, calendarDate, notes,
      cardWalletId,
      subType
    };
  }

  throw new Error("Tipo evento non supportato.");
}

function applyDuplication(payload){
  const n = Number(($("dupMonths").value||"").trim());
  if(!Number.isFinite(n) || n<=0) return [payload];

  const rule = $("dupRule").value;
  const baseDate = parseISO(payload.calendarDate);
  if(!baseDate) return [payload];

  const out = [payload];
  for(let i=1;i<=n;i++){
    const d = addMonthsJS(baseDate, i);
    const fixed = new Date(d.getFullYear(), d.getMonth(), d.getDate());

    let target = fixed;
    if(rule==="first_day") target = new Date(d.getFullYear(), d.getMonth(), 1);
    if(rule==="last_day")  target = new Date(d.getFullYear(), d.getMonth()+1, 0);

    if(rule==="same_day_or_last"){
      // already clamped by addMonthsJS
    }

    const copy = JSON.parse(JSON.stringify(payload));
    const cal = isoDate(target);

    copy.calendarDate = cal;

    // keep semantics:
    if(copy.type==="card_purchase"){
      copy.purchaseDate = cal;
      copy.calendarDate = cal;
    }
    if(copy.type==="card_repayment"){
      copy.paymentDate = cal; // user likely wants payment in that month
    }

    // remove series when duplicating
    if(copy.series) delete copy.series;

    out.push(copy);
  }
  return out;
}

async function saveEvent(){
  const editId = $("dlgEvent").dataset.editId;
  const isEdit = !!editId;

  const payload = buildPayloadFromDialog();
  const payloads = applyDuplication(payload);

  // If editing and duplication is requested: we will update the existing and create copies for additional months
  try{
    if(isEdit){
      // update current event with first payload
      await apiFetch(`/events/${encodeURIComponent(editId)}`, {method:"PUT", body: JSON.stringify(payloads[0])});
      // create copies for rest
      for(let i=1;i<payloads.length;i++){
        await apiFetch("/events", {method:"POST", body: JSON.stringify(payloads[i])});
      }
    }else{
      // create all
      for(const p of payloads){
        await apiFetch("/events", {method:"POST", body: JSON.stringify(p)});
      }
    }

    $("dlgEvent").close();
    toast("Salvato", isEdit ? "Evento aggiornato." : "Evento creato.");
    await refreshAllAfterMutation(payload);
  }catch(err){
    toast("Errore", String(err.message||err));
  }
}

async function deleteEvent(){
  const editId = $("dlgEvent").dataset.editId;
  if(!editId) return;
  if(!confirm("Eliminare questo evento?")) return;
  try{
    await apiFetch(`/events/${encodeURIComponent(editId)}`, {method:"DELETE"});
    $("dlgEvent").close();
    toast("Eliminato", "Evento rimosso.");
    await refreshAllAfterMutation(null);
  }catch(err){
    toast("Errore", String(err.message||err));
  }
}

async function refreshAllAfterMutation(lastPayload){
  // refresh month events + dashboard + maybe auto repayment
  await loadEventsForVisibleMonth();
  await loadDashboard();

  // if the mutation impacts cards, optionally create missing repayment events
  if(lastPayload && String(lastPayload.type||"").startsWith("card_")){
    await maybeAutoCreateRepayments();
    // reload to reflect auto created
    await loadEventsForVisibleMonth();
    await loadDashboard();
  }

  renderHeaders();
  renderCalendar();
  if(document.querySelector(".tabbtn.active")?.dataset?.tab==="overview") renderOverview();
}

/* =========================
   Settings: Card settings CRUD
========================= */
async function loadCardSettings(){
  const id = $("selCard").value;
  if(!id) return;
  try{
    const cs = await apiFetch(`/cards/${encodeURIComponent(id)}/settings`);
    $("csTeil").value = cs.teilzahlungAmount ?? "";
    $("csSoll").value = cs.sollzinsAnnual ?? "";
    $("csEff").value = cs.effektivzinsAnnual ?? "";
    $("csLimit").value = cs.kreditlimit ?? "";
    $("csCycleStart").value = cs.cycleStartDay ?? "";
    $("csCycleEnd").value = cs.cycleEndDay ?? "";
    $("csDebitDay").value = cs.debitDay ?? "";
    $("csEffFrom").value = cs.effectiveFrom ?? "";
    $("csOffset").value = ""; // not returned by GET in your handler; keep for PUT only
    toast("Caricato", "Impostazioni carta caricate.");
  }catch(err){
    toast("Errore", String(err.message||err));
  }
}

async function saveCardSettings(){
  const id = $("selCard").value;
  if(!id) return;

  // Keep backend param names exactly as you implemented
  const payload = {
    teilzahlungAmount: $("csTeil").value ? Number(String($("csTeil").value).replace(",",".")) : null,
    sollzinsAnnual: $("csSoll").value ? Number(String($("csSoll").value).replace(",",".")) : null,
    effektivzinsAnnual: $("csEff").value ? Number(String($("csEff").value).replace(",",".")) : null,
    kreditlimit: $("csLimit").value ? Number(String($("csLimit").value).replace(",",".")) : null,
    cycleStartDay: $("csCycleStart").value ? Number($("csCycleStart").value) : null,
    cycleEndDay: $("csCycleEnd").value ? Number($("csCycleEnd").value) : null,
    debitDay: $("csDebitDay").value ? Number($("csDebitDay").value) : null,
    effectiveFrom: $("csEffFrom").value ? $("csEffFrom").value.trim() : null
  };

  // debitMonthOffset exists in your DB schema and backend uses it in dashboard/statement-report
  // Your GET doesn't expose it; PUT currently doesn't support it either.
  // We still send it only if you want: it will be ignored unless your PUT handler supports it.
  if($("csOffset").value.trim()){
    payload.debitMonthOffset = Number($("csOffset").value.trim());
  }

  try{
    await apiFetch(`/cards/${encodeURIComponent(id)}/settings`, {method:"PUT", body: JSON.stringify(payload)});
    toast("Salvato", "Impostazioni carta salvate.");
    await refreshAll();
  }catch(err){
    toast("Errore", String(err.message||err));
  }
}

/* =========================
   Selection handlers
========================= */
async function onSelectDay(d){
  state.selectedDate = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  $("pillDate").textContent = isoDate(state.selectedDate);

  // dashboard depends on asOf => reload
  await loadDashboard();
  renderHeaders();
  renderCalendar();
  renderDayPanel();

  if(document.querySelector(".tabbtn.active")?.dataset?.tab==="overview"){
    renderOverview();
  }
}

async function setVisibleMonth(d){
  state.visibleMonth = new Date(d.getFullYear(), d.getMonth(), 1);

  // if selected date is outside month, keep it but still ok.
  await loadEventsForVisibleMonth();
  await loadDashboard();
  await maybeAutoCreateRepayments();

  // re-load if auto created things
  await loadEventsForVisibleMonth();
  await loadDashboard();

  renderHeaders();
  renderCalendar();
  if(document.querySelector(".tabbtn.active")?.dataset?.tab==="overview") renderOverview();
}

async function refreshAll(){
  $("pillApi").textContent = apiBase();
  await loadWallets();
  fillWalletSelects();

  state.walletFilter = $("calWalletFilter").value || "";
  await loadEventsForVisibleMonth();
  await loadDashboard();
  await maybeAutoCreateRepayments();

  // refresh again after potential auto creation
  await loadEventsForVisibleMonth();
  await loadDashboard();

  renderHeaders();
  renderCalendar();
  renderDayPanel();
  if(document.querySelector(".tabbtn.active")?.dataset?.tab==="overview") renderOverview();

  $("pillApi").textContent = apiBase();
}

/* =========================
   Escaping
========================= */
function escapeHtml(s){
  return String(s??"").replace(/[&<>"']/g, c=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}

/* =========================
   Wire up
========================= */
function wire(){
  // tabs
  for(const b of document.querySelectorAll(".tabbtn")){
    b.addEventListener("click", ()=>setTab(b.dataset.tab));
  }

  // calendar nav
  $("btnPrevMonth").addEventListener("click", ()=>setVisibleMonth(addMonthsJS(state.visibleMonth, -1)));
  $("btnNextMonth").addEventListener("click", ()=>setVisibleMonth(addMonthsJS(state.visibleMonth,  1)));

  // filter
  $("calWalletFilter").addEventListener("change", async ()=>{
    state.walletFilter = $("calWalletFilter").value || "";
    await loadEventsForVisibleMonth();
    renderCalendar();
    renderDayPanel();
  });

  // reload
  $("btnReload").addEventListener("click", async ()=>{
    saveLocal();
    await refreshAll();
    toast("Ok", "Dati ricaricati.");
  });

  // quick add
  $("btnQuickAdd").addEventListener("click", ()=>openNewEvent());
  $("btnAddOnSelected").addEventListener("click", ()=>openNewEvent());
  $("btnQuickIncome").addEventListener("click", ()=>openNewEvent("income"));
  $("btnQuickExpense").addEventListener("click", ()=>openNewEvent("expense"));
  $("btnQuickCardPurchase").addEventListener("click", ()=>openNewEvent("card_purchase"));
  $("btnQuickRepayment").addEventListener("click", ()=>openNewEvent("card_repayment"));

  // dialog
  $("dlgClose").addEventListener("click", ()=>$("dlgEvent").close());
  $("btnCancelEvent").addEventListener("click", ()=>$("dlgEvent").close());
  $("btnSaveEvent").addEventListener("click", saveEvent);
  $("btnDeleteEvent").addEventListener("click", deleteEvent);

  $("evType").addEventListener("change", updateDialogVisibility);
  $("evScheduleKind").addEventListener("change", updateDialogVisibility);

  // settings
  $("autoRepayToggle").addEventListener("change", saveLocal);
  $("apiBase").addEventListener("change", saveLocal);

  $("btnLoadCardSettings").addEventListener("click", loadCardSettings);
  $("btnSaveCardSettings").addEventListener("click", saveCardSettings);
}

/* =========================
   Init
========================= */
(async function init(){
  loadLocal();
  $("pillApi").textContent = apiBase().replace("/finance","/");
  state.selectedDate = new Date();
  state.visibleMonth = new Date(state.selectedDate.getFullYear(), state.selectedDate.getMonth(), 1);
  $("pillDate").textContent = isoDate(state.selectedDate);

  wire();

  try{
    await refreshAll();
  }catch(err){
    toast("Errore avvio", String(err.message||err));
    console.error(err);
  }
})();
</script>
</body>
</html>
