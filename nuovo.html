<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dwarfs Cave ‚Äì Goblin Expeditions (Polling, No SSE)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">

  <link rel="preload" as="style" href="cyberpunktribalV2.css?v=1" onload="this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="cyberpunktribalV2.css?v=1"></noscript>
  <link id="theme-style" rel="stylesheet" href="css013.css"/>
</head>

<body>
  <div id="app-root">
    <header id="app-header" aria-label="Application header">
      <h1>Goblin DEX</h1>
      <p id="subtitle">Build goblin expeditions, watch the world map update via polling (no SSE).</p>

      <nav id="action-bar" aria-label="Actions">
        <div id="duration-switch" aria-label="Expedition Duration">
          <label for="sel-duration" style="margin-right:8px;font-weight:900;">Duration</label>
          <select id="sel-duration" title="Choose expedition duration" style="min-width:140px;">
            <option value="5">5m ‚Äî Blitz</option>
            <option value="30" selected>30m ‚Äî Standard</option>
            <option value="60">1h ‚Äî Long</option>
            <option value="120">2h ‚Äî Marathon</option>
            <option value="360">6h ‚Äî Endurance</option>
            <option value="1440">24h ‚Äî Ultra</option>
          </select>
          <small id="duration-hint" style="margin-left:10px;opacity:.85;"></small>
        </div>

        <div id="cap-line" aria-live="polite">
          <span id="cap-label" title="Maximum goblins you can send in the current run">Max goblins this run: 50</span> ¬∑
          <span id="reinf-label" title="Reinforcement adds +5 goblins each, up to +200">Base 50 + 0√ó Reinforcement (= 0 extra)</span>
        </div>

        <div id="action-buttons" role="group" aria-label="Primary actions">
          <button id="btn-start" class="btn-primary" title="Start an expedition with the selected goblins">üöÄ Start Expedition</button>
          <button id="btn-copy-overlay" class="btn-primary" title="Copy a link to the overlay-only view">üîó Copy overlay link</button>
        </div>
      </nav>

      <section id="news-banner" aria-label="News & Ads">
        <strong>Live:</strong> World expeditions map updates every few seconds (HTTP polling only, no SSE).
      </section>

      <div id="status-row" aria-live="polite">
        <span id="latency-label" title="Time to sync the latest snapshot">syncing‚Ä¶</span>
      </div>
    </header>

    <main id="main-layout" aria-label="Main content">
      <section id="game-area" aria-label="Game Area">
        <h2>World Expeditions Map</h2>
        <div id="canvas-wrap" aria-label="Game viewport">
          <canvas id="game-canvas"></canvas>
          <div id="canvas-feedback" class="feedback-near-canvas" aria-live="polite"></div>
        </div>

        <div id="legend">
          <span>Legend:</span>
          <span>Goblin Squad</span>
        </div>

        <div id="ticker-row" aria-label="Global log and commands">
          <div id="ticker" aria-live="polite">
            <strong>GLOBAL LOG:</strong> <span id="ticker-line">Waiting for events‚Ä¶</span>
          </div>
        
          <aside id="botcommands" aria-label="Bot commands">
            <div class="bc-head">
              <strong>BOT COMMANDS</strong>
              <span class="bc-pill">Twitch chat</span>
            </div>
        
            <div class="bc-list">
              <div class="bc-item">
                <span class="bc-cmd">!chest</span>
                <span class="bc-desc">Spawn a chest inside the Goblin DeX Arena. First click wins!</span>
              </div>
            </div>
        
            <div class="bc-foot">
              Use these commands in Twitch chat to trigger arena events. More coming soon.
            </div>
          </aside>
        </div>
      </section>

<aside id="panels" aria-label="Information panels">
  <nav id="tabs" role="tablist" aria-label="Panels" aria-orientation="horizontal">
    <button id="tab-btn-my" class="btn-primary" role="tab" aria-selected="true" tabindex="0"
            aria-controls="tab-my" data-panel="tab-my" title="Build your expedition">
      My Goblins
    </button>

    <button id="tab-btn-staking" class="btn-primary" role="tab" aria-selected="false" tabindex="-1"
            aria-controls="tab-staking" data-panel="tab-staking" title="View your staking points and bonuses">
      Staking
    </button>

    <button id="tab-btn-global" class="btn-primary" role="tab" aria-selected="false" tabindex="-1"
            aria-controls="tab-global" data-panel="tab-global" title="Live view of all expeditions">
      Global
    </button>

    <button id="tab-btn-recent" class="btn-primary" role="tab" aria-selected="false" tabindex="-1"
            aria-controls="tab-recent" data-panel="tab-recent" title="Expeditions completed in the last 24h">
      Recent
    </button>
  </nav>

  <!-- ========================= -->
  <!-- TAB: MY GOBLINS (builder) -->
  <!-- ========================= -->
  <section id="tab-my" role="tabpanel" aria-labelledby="tab-btn-my" tabindex="0" aria-label="My Goblins">
    <h3>üß¨ Goblin Expedition Builder</h3>

    <div id="my-status" aria-live="polite">
      Load your goblins to start building an expedition.
    </div>

    <section id="goblin-account-summary" aria-label="Goblin account stats">
      <div class="gas-row">
        <span id="gas-total-count" class="gas-chip gas-chip--power">Goblins: <strong>0</strong></span>
        <span id="gas-total-power" class="gas-chip gas-chip--power">Total power: <strong>0</strong></span>
        <span id="gas-avg-power"   class="gas-chip gas-chip--power">Avg power: <strong>0</strong></span>
      </div>

      <div class="gas-row">
        <span id="gas-total-res"   class="gas-chip gas-chip--sum">RES Œ£: <strong>0</strong></span>
        <span id="gas-total-acc"   class="gas-chip gas-chip--sum">ACC Œ£: <strong>0</strong></span>
        <span id="gas-total-loot"  class="gas-chip gas-chip--sum">LOOT Œ£: <strong>0</strong></span>
        <span id="gas-total-speed" class="gas-chip gas-chip--sum">SPD Œ£: <strong>0</strong></span>
      </div>

      <div class="gas-row">
        <span id="gas-avg-res"   class="gas-chip gas-chip--avg">RES Œº: <strong>0</strong></span>
        <span id="gas-avg-acc"   class="gas-chip gas-chip--avg">ACC Œº: <strong>0</strong></span>
        <span id="gas-avg-loot"  class="gas-chip gas-chip--avg">LOOT Œº: <strong>0</strong></span>
        <span id="gas-avg-speed" class="gas-chip gas-chip--avg">SPD Œº: <strong>0</strong></span>
      </div>

      <div class="gas-row">
        <span id="gas-rarity-mythic"    class="gas-chip gas-chip--rarity">Mythic: <strong>0</strong></span>
        <span id="gas-rarity-legendary" class="gas-chip gas-chip--rarity">Legendary: <strong>0</strong></span>
        <span id="gas-rarity-epic"      class="gas-chip gas-chip--rarity">Epic: <strong>0</strong></span>
        <span id="gas-rarity-rare"      class="gas-chip gas-chip--rarity">Rare: <strong>0</strong></span>
        <span id="gas-rarity-common"    class="gas-chip gas-chip--rarity">Common: <strong>0</strong></span>
      </div>
    </section>

    <!-- Panoramica + bottone manuale per fetch goblins -->
    <section id="goblin-overview" aria-label="Your goblins overview">
      <div id="goblin-overview-card" class="card"
           style="display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:12px;margin:12px 0 6px;">
        <div style="display:flex;flex-wrap:wrap;gap:16px;align-items:flex-start;">
          <div>
            <div style="font-size:11px;opacity:.8;">Total goblins</div>
            <div class="value" id="stat-goblins-count" style="font-weight:900;font-size:20px;">0</div>
          </div>
          <div>
            <div style="font-size:11px;opacity:.8;">Total daily power</div>
            <div class="value" id="stat-goblins-power-total" style="font-weight:900;font-size:20px;">0</div>
          </div>
          <div>
            <div style="font-size:11px;opacity:.8;">Average daily power</div>
            <div class="value" id="stat-goblins-power-avg" style="font-weight:900;font-size:20px;">0</div>
          </div>
          <div>
            <div style="font-size:11px;opacity:.8;">Goblins data</div>
            <div class="value" id="stat-goblins-updated" style="font-size:18px;opacity:.9;">Not loaded yet</div>
          </div>
        </div>

        <button id="btn-load-goblins" class="btn-primary" type="button"
                title="Fetch your goblins from the API"
                style="min-width:230px;padding:9px 16px;font-weight:800;font-size:20px;border-radius:999px;margin-left:auto;display:inline-flex;align-items:center;gap:6px;justify-content:center;">
          üîÑ Load / Refresh goblins
        </button>
      </div>
    </section>

    <section id="filters" aria-label="Filters">
      <input id="flt-search" type="search" placeholder="Search name or #id‚Ä¶" title="Filter goblins by name or asset id">
      <select id="flt-rarity" title="Filter by rarity">
        <option value="">All rarities</option>
        <option>Common</option>
        <option>Rare</option>
        <option>Epic</option>
        <option>Legendary</option>
      </select>
      <label for="flt-power" title="Only show goblins with at least this power">Min power</label>
      <input id="flt-power" type="range" min="0" max="100" step="5" value="0">
      <span id="flt-power-label">0</span>
    </section>

    <section id="builder-controls" aria-label="Expedition controls"></section>
    <div id="action-hint" aria-live="polite"></div>

    <section id="run-forecast" aria-live="polite" hidden></section>

    <section id="quick-select" aria-label="Quick selection">
      <button id="qs-first" class="btn-primary" title="Pick the first goblins up to your cap">‚úÖ First 50</button>
      <button id="qs-best"  class="btn-primary" title="Pick the strongest goblins up to your cap">üèÜ Best 50</button>
      <button id="qs-clear" class="btn-primary" title="Clear the current selection">‚ùå Clear</button>
    </section>

    <section id="selection-summary" aria-label="Selection summary">
      <div id="sel-count">Selected goblins: 0</div>
      <div id="sel-stats" title="Aggregated attributes of selected goblins">R: 0 ¬∑ L: 0 ¬∑ S: 0 ¬∑ A: 0</div>
    </section>

    <section id="goblin-list" aria-label="Your goblins list"></section>

    <div id="view-more" aria-label="Pagination">
      <button id="btn-toggle-more" class="btn-primary" title="Expand or collapse the list" hidden>View more</button>
    </div>

    <div id="toast-host" aria-live="polite"></div>
  </section>

  <!-- ========================= -->
  <!-- TAB: STAKING              -->
  <!-- ========================= -->
  <section id="tab-staking" role="tabpanel" aria-labelledby="tab-btn-staking" tabindex="0"
           aria-label="Staking Report" hidden>
    <h3>üßæ Staking Pools</h3>

    <div class="staking-toolbar">
      <div class="staking-meta">
        <div class="staking-chip">
          <span class="lbl">Account</span>
          <b id="staking-account">‚Äî</b>
        </div>
        <div class="staking-chip" title="When this report was generated on the server (UTC).">
          <span class="lbl">Generated</span>
          <b id="staking-started-at">‚Äî</b>
        </div>
        <div class="staking-chip" title="Cached on this device for fast switching.">
          <span class="lbl">Cache</span>
          <b id="staking-cache">‚Äî</b>
        </div>
      </div>

      <div class="staking-actions">
        <button id="btn-staking-refresh" class="btn-primary" type="button">üîÑ Refresh</button>
        <button id="btn-staking-copy" class="btn-primary" type="button">üìã Copy summary</button>
      </div>
    </div>

    <div id="staking-host" aria-live="polite"></div>
  </section>

  <!-- ========================= -->
  <!-- TAB: GLOBAL               -->
  <!-- ========================= -->
  <section id="tab-global" role="tabpanel" aria-labelledby="tab-btn-global" tabindex="0"
           aria-label="World Live Expeditions" hidden>
    <h3>üåç World Live Expeditions</h3>
    <div id="global-count">0</div>
    <div id="global-list" aria-label="Expeditions list"></div>
  </section>

  <!-- ========================= -->
  <!-- TAB: RECENT               -->
  <!-- ========================= -->
  <section id="tab-recent" role="tabpanel" aria-labelledby="tab-btn-recent" tabindex="0"
           aria-label="Last Completed Expeditions" hidden>
    <h3>üïí Last Completed Expeditions</h3>
    <div id="recent-list" aria-label="Recent results"></div>
  </section>
</aside>

    </main>

    <footer id="app-footer" aria-label="Footer">
      <small>Overlay-only link available from the top bar. All times are local to your device.</small>
    </footer>
  </div>

  <script>
    window.CAVE_API_BASE = "https://iamemanuele.pythonanywhere.com";
    window.userData = {
      wax_account: "agoscry4ever",
      user_id: "5235038223",
      usx_token: "9o0B6EGF9CJxXMqKyZPtcGEcRifzP9Yeil5S1zuRGjZehKoyy9ZDcIEe26OgmiGuYAgFgqYletGoHVhFATQjrtP6ZPLuU9UvGYSki0rYw7kjCEw6q6of4xO0VPgt6WE0"
    };
    window.CAVE_OVERLAY = false;
  </script>

  <script>
  ;(function () {
    'use strict';

    // ------------------------------------------------------------
    // CONFIG
    // ------------------------------------------------------------
    const DURATION_BUCKETS = [5, 30, 60, 120, 360, 1440];
    const CONFIG = {
      worldCols: 48,
      worldRows: 24,

      pollIntervalMs: 3500,
      userNftsTimeoutMs: 60000,
      snapshotTimeoutMs: 10000,
      recentTimeoutMs: 12000,

      apiBase: (window.CAVE_API_BASE || '').replace(/\/$/, ''),

      goblinSpeedMin: 4.8 * 3,
      goblinSpeedMax: 7.8 * 3,

      trailBaseMaxAgeMs: 1400,
      trailMinPointDist: 0.10,
      trailMaxPoints: 60,
drop: {
  pollGraceMs: 2500,
  clickRadiusCells: 1.35,
  openingMs: 1100,
  hologramMs: 1200,
  doneHoldMs: 900,
  dissolveMs: 650,
  maxLifeFallbackMs: 90_000
},
    };
    const SIMULATION_API_PATH = '/2expedition_simulate';
    const ACTIVE_DROP_API_PATH = '/2active_drop';
    const CLAIM_DROP_API_PATH  = '/2drop_claim';
    const QS = new URLSearchParams(location.search);
    const OVERLAY_MODE =
      QS.get('overlay') === '1' ||
      /\/overlay\.html$/i.test(location.pathname);

    // ------------------------------------------------------------
    // STATE
    // ------------------------------------------------------------
    const State = {
      mounted: false,
      dpr: window.devicePixelRatio || 1,
      overlay: OVERLAY_MODE,

      ui: {
        canvas: null,
        latency: null,
        ticker: null,
        toastHost: null,

        listHost: null,
        summaryCount: null,
        summaryStats: null,

        fltSearch: null,
        fltRarity: null,
        fltPower: null,
        fltPowerLabel: null,

        btnFirst: null,
        btnBest: null,
        btnClear: null,
        btnToggleMore: null,

        btnStart: null,
        btnCopyOverlay: null,

        capLabel: null,
        reinfLabel: null,

        durationSelect: null,
        durationHint: null,

        globalList: null,
        globalCount: null,
        recentList: null,

        goblinStatCount: null,
        goblinStatTotal: null,
        goblinStatAvg: null,
        goblinStatUpdated: null,
        btnLoadGoblins: null,

        // staking tab
        stakingHost: null,
        stakingAccount: null,
        stakingStartedAt: null,
        stakingCache: null,
        btnStakingRefresh: null,
        btnStakingCopy: null,
      },

      user: { wax_account:'', user_id:'', usx_token:'' },

      nftsLoaded: false,
      nftIndex: new Map(),
      goblinsUser: [],
      selectedGoblinIds: new Set(),

      expedition: {
        durationMinutes: 30,
        reinforcementCount: 0,
      },

      engine: null,

      net: {
        pollTimer: null,
        pollMs: CONFIG.pollIntervalMs,
        busySnapshot: false
      },

      globalExpeditions: [],
      recentExpeditions: [],
      globalLogEvents: [],    
      runtime: {
        expeditionInProgress: false,
        lastForecastPayloadKey: '',
        forecastBusy: false,
        forecastData: null,
        forecastPowerByAsset: {},        // { asset_id: power_needed }
        forecastInsufficientIds: new Set(),     
        forecastMode: 'real',            // 'real' | 'sim'
        simConfig: {                     // current simulator form values
          durationMinutes: 30,
          goblinsCount: 50,
          totalAcc: 0,
          totalRes: 0,
          totalSpeed: 0,
          totalLoot: 0
        },      
        ticker: { idx: 0, timer: null },
        simResult: null                  // last simulation result
      },
      drop: {
        current: null,
        serverKey: '',
        lastSeenEventId: '',
        claimBusy: false,
        claimedEventId: '',
        claimedBy: '',
        lastLocalTickerHtml: '',
        lastLocalTickerUntilMs: 0,
        fx: {
          phase: 'idle',               // idle|visible|claiming|opening|hologram|dissolve|done|expired
          startedAtMs: 0,
          openAtMs: 0,
          holoAtMs: 0,
          doneAtMs: 0,
          shakePower: 0,
          pulsePhase: 0,
          particles: [],
          shockwaves: []
        }
      },
    };

    // ------------------------------------------------------------
    // UTILS + API + HELPERS (reintrodotti)
    // ------------------------------------------------------------
    function parseUtcMs(iso){
      if (!iso) return null;
      const d = new Date(iso);
      const t = d.getTime();
      return Number.isFinite(t) ? t : null;
    }
    
    function normalizeDrop(d){
      if (!d || typeof d !== 'object') return null;
    
      // ‚úÖ accept backend shape: sometimes only event_id exists
      const event_id = String(d.event_id ?? d.eid ?? '');
      const drop_id  = String(d.drop_id ?? d.id ?? event_id ?? '');
    
      if (!drop_id) return null;
    
      const wx = toNumber(d.world?.x ?? d.x ?? d.world_x);
      const wy = toNumber(d.world?.y ?? d.y ?? d.world_y);
    
      const expiresAtMs =
        parseUtcMs(d.expires_at_utc ?? d.expires_at ?? d.expiresAtUtc) ??
        (d.ttl_ms ? (Date.now() + toNumber(d.ttl_ms)) : null) ??
        (d.claim_window_ms ? (Date.now() + toNumber(d.claim_window_ms)) : null) ??
        (Date.now() + (CONFIG.drop?.maxLifeFallbackMs || 90_000));
    
      const spawnedAtMs =
        parseUtcMs(d.spawned_at_utc ?? d.spawned_at ?? d.spawnedAtUtc ?? d.created_at) ??
        (Date.now() - 500);
    
      return {
        drop_id,
        event_id,
        status: String(d.status ?? 'spawned'),
        rarity: String(d.rarity ?? ''),
        world: { x: wx, y: wy },
        spawnedAtMs,
        expiresAtMs,
        claimed: !!(d.claimed ?? (d.status === 'claimed')),
        claimedBy: d.claimed_by ? String(d.claimed_by) : (d.claimed_by === '' ? '' : ''),
        reward_preview: d.reward_preview || null
      };
    }

    function dropTimeLeftMs(drop){
      if (!drop) return null;
      return Math.max(0, (drop.expiresAtMs || 0) - Date.now());
    }

    // --- debounce ---

    function debounce(fn, delay){
      let t;
      return function(...args){
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // --- numeri, clamp, random ---

    function toNumber(x){
      const n = Number(x);
      return Number.isFinite(n) ? n : 0;
    }

    function clamp(v, min, max){
      return v < min ? min : (v > max ? max : v);
    }

    function randRange(min, max){
      return min + Math.random() * (max - min);
    }

    // --- escape HTML ---

    function safe(str){
      if (str == null) return '';
      return String(str)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    // --- formattazioni varie ---

    function formatCompact(num){
      const n = toNumber(num);
      if (n === 0) return '0';
      const abs = Math.abs(n);
      if (abs >= 1e9) return (n/1e9).toFixed(2).replace(/\.00$/,'') + 'B';
      if (abs >= 1e6) return (n/1e6).toFixed(2).replace(/\.00$/,'') + 'M';
      if (abs >= 1e3) return (n/1e3).toFixed(2).replace(/\.00$/,'') + 'K';
      return String(Math.round(n));
    }

    function formatDP(v){
      const n = toNumber(v);
      if (n === 0) return '0';
      if (Math.abs(n) < 1)   return n.toFixed(2);
      if (Math.abs(n) < 10)  return n.toFixed(2);
      if (Math.abs(n) < 100) return n.toFixed(1);
      return formatCompact(n);
    }

    function timeHM(value){
      let d;
      if (value instanceof Date) d = value;
      else if (typeof value === 'number') d = new Date(value);
      else if (typeof value === 'string') d = new Date(value);
      else return '';
      if (isNaN(d.getTime())) return '';
      const h = d.getHours().toString().padStart(2,'0');
      const m = d.getMinutes().toString().padStart(2,'0');
      return `${h}:${m}`;
    }

    function fmtHMS(ms){
      const total = Math.max(0, Math.floor(ms / 1000));
      const h = Math.floor(total / 3600).toString().padStart(2,'0');
      const m = Math.floor((total % 3600) / 60).toString().padStart(2,'0');
      const s = (total % 60).toString().padStart(2,'0');
      return `${h}:${m}:${s}`;
    }

    function formatMinutesShort(mins){
      const m = toNumber(mins);
      if (!m) return '0m';
      if (m % 1440 === 0) return (m/1440) + 'd';
      if (m >= 60 && m % 60 === 0) return (m/60) + 'h';
      return m + 'm';
    }

    function formatEffectiveDurationShort(effSeconds){
      const mins = Math.round(toNumber(effSeconds) / 60);
      return formatMinutesShort(mins);
    }
    function formatDurationMinSecFromSeconds(sec){
      const total = Math.max(0, Math.floor(toNumber(sec)));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m}m ${s.toString().padStart(2,'0')}s`;
    }
// ------------------------------------------------------------
// RESPONSE NORMALIZERS (backend shape changes safe)
// ------------------------------------------------------------
function pickArrayFromPayload(payload, ...keys){
  if (!payload) return [];
  if (Array.isArray(payload)) return payload;

  // try common wrappers
  for (const k of keys){
    if (payload && Array.isArray(payload[k])) return payload[k];
  }

  // other common patterns
  if (payload && payload.data && Array.isArray(payload.data)) return payload.data;
  if (payload && payload.result && Array.isArray(payload.result)) return payload.result;
  if (payload && payload.results && Array.isArray(payload.results)) return payload.results;

  return [];
}

function pickObject(payload, ...keys){
  if (!payload || typeof payload !== 'object') return null;
  for (const k of keys){
    if (payload[k] && typeof payload[k] === 'object') return payload[k];
  }
  return payload;
}

    // --- durata / costo nominale ---

    function bucketFromMinutes(mins){
      const m = toNumber(mins);
      if (!m) return 0;
      let best = DURATION_BUCKETS[0];
      let bestDiff = Math.abs(m - best);
      for (const b of DURATION_BUCKETS){
        const diff = Math.abs(m - b);
        if (diff < bestDiff){
          bestDiff = diff;
          best = b;
        }
      }
      return best;
    }

    function nominalCostPerGoblinForMinutes(mins){
      const m = toNumber(mins);
      if (!m) return 0;
      // Stima lineare semplice: 24h ‚âà 100 DP base
      return (m / 1440) * 100;
    }

    // ------------------------------------------------------------
    // API helper (GET / POST con timeout)
    // ------------------------------------------------------------

    async function apiRequest(method, path, body, timeoutMs){
      const base = CONFIG.apiBase || '';
      const url = base + path;
      const ctrl = new AbortController();
      const tId = timeoutMs ? setTimeout(() => ctrl.abort(), timeoutMs) : null;

      let resp;
      try{
        resp = await fetch(url, {
          method,
          headers: { 'Content-Type':'application/json' },
          body: body ? JSON.stringify(body) : null,
          signal: ctrl.signal
        });
      } catch (err){
        if (tId) clearTimeout(tId);
        return { ok:false, status:0, error:err };
      }
      if (tId) clearTimeout(tId);

      let data = null;
      try { data = await resp.json(); } catch { /* ignore */ }

      return { ok: resp.ok, status: resp.status, data };
    }

    const Api = {
      get(path, timeoutMs){
        return apiRequest('GET', path, null, timeoutMs);
      },
      post(path, body, timeoutMs){
        return apiRequest('POST', path, body, timeoutMs);
      }
    };

    // ------------------------------------------------------------
    // AUTH
    // ------------------------------------------------------------

    function syncUserFromStorage(){
      const src = (window.userData && typeof window.userData === 'object')
        ? window.userData
        : {};
      State.user.wax_account = src.wax_account || State.user.wax_account || '';
      State.user.user_id     = src.user_id     || State.user.user_id     || '';
      State.user.usx_token   = src.usx_token   || State.user.usx_token   || '';
    }

    function assertAuth(){
      syncUserFromStorage();
      if (!State.user.wax_account || !State.user.user_id || !State.user.usx_token){
        throw new Error('Not authenticated');
      }
    }
    
// ============================================================
// STAKING REPORT ‚Äî UX/UI + FETCH  (POOLS + EXPAND/COLLAPSE)
// ============================================================

function fmtUtc(iso){
  if (!iso) return '‚Äî';
  const d = new Date(iso);
  if (isNaN(d.getTime())) return String(iso);
  return `${timeHM(d)} ¬∑ ${d.toLocaleDateString()}`;
}

function stakingCacheKey(wax){
  return `staking_report_cache::${String(wax||'').toLowerCase()}`;
}

function setStakingMeta({account, startedAtUtc, cacheLabel}){
  if (State.ui.stakingAccount) State.ui.stakingAccount.textContent = account || '‚Äî';
  if (State.ui.stakingStartedAt) State.ui.stakingStartedAt.textContent = startedAtUtc ? fmtUtc(startedAtUtc) : '‚Äî';
  if (State.ui.stakingCache) State.ui.stakingCache.textContent = cacheLabel || '‚Äî';
}

function renderStakingSkeleton(){
  const host = State.ui.stakingHost;
  if (!host) return;
  host.innerHTML = `
    <div class="staking-skeleton" style="height:120px"></div>
    <div style="height:10px"></div>
    <div class="staking-skeleton" style="height:320px"></div>
  `;
}

function renderStakingError(message){
  const host = State.ui.stakingHost;
  if (!host) return;
  host.innerHTML = `
    <div class="staking-card">
      <div class="title">‚ö†Ô∏è Staking report unavailable</div>
      <div style="opacity:.9;line-height:1.45">${safe(message || 'Could not load staking report right now.')}</div>
      <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn-primary" type="button" id="btn-staking-retry">üîÑ Try again</button>
      </div>
    </div>
  `;
  const btn = document.getElementById('btn-staking-retry');
  if (btn) btn.onclick = ()=> fetchAndRenderStakingReport({force:true});
}

// unwrap { ok:true, report:{...}, bonus:{...} } -> report
function normalizeStakingPayload(raw){
  if (!raw || typeof raw !== 'object') return null;
  if (raw.report && typeof raw.report === 'object') return raw.report;
  if (raw.data && typeof raw.data === 'object') return raw.data;
  return raw;
}

// IMPORTANT: scoring fields are LONG decimal strings -> don't Number() them
function fmtDecStr(x){
  if (x == null) return '‚Äî';
  const s = String(x);
  // keep it readable: if very long, truncate but preserve meaning
  if (s.length > 18){
    // show first 10 + '‚Ä¶' + last 4 only if it has many decimals
    const head = s.slice(0, 12);
    return head + '‚Ä¶';
  }
  return s;
}

function renderStakingReport(report){
  const host = State.ui.stakingHost;
  if (!host) return;

  const grand = report?.grand_totals || {};
  const venues = report?.venues || {};
  const scoring = report?.scoring || {};

  const venueNames = Object.keys(venues || {});
  const targets = Array.isArray(report?.targets) ? report.targets : [];

  // --- Points -> Bonus mapping (stessa logica del tuo Copy summary attuale)
  // +1% ogni 10 punti, cap a 100%
  function parsePoints(x){
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  }
  function pointsToBonus(points){
    const p = Math.max(0, points);
    const pct = clamp(Math.floor(p / 10), 0, 100);
    const mult = 1 + pct / 100;
    const nextPct = Math.min(100, pct + 1);
    const nextAt = nextPct * 10;
    const missing = Math.max(0, nextAt - p);
    const progress = pct >= 100 ? 100 : clamp((p - pct*10) / 10 * 100, 0, 100);
    return { pct, mult, nextPct, nextAt, missing, progress };
  }

  const grandPtsRaw = grand?.points ?? '0';
  const pointsNum = parsePoints(grandPtsRaw);
  const bonus = pointsToBonus(pointsNum);

  const renderPool = (row)=>{
    const pair = row?.pair || `${row?.token0||'?'} / ${row?.token1||'?'}`;
    const a0 = row?.amount0 ?? '0';
    const a1 = row?.amount1 ?? '0';
    const t0 = row?.token0 || '';
    const t1 = row?.token1 || '';
    const meta = row?.meta || '';
    const poolId = row?.pool_id != null ? String(row.pool_id) : '‚Äî';
    const pos = row?.positions != null ? String(row.positions) : '‚Äî';
    const pts = row?.points ?? '0';

    return `
      <div class="stk-pool">
        <div class="row1">
          <div>
            <div class="pair">${safe(pair)}</div>
            <div class="stk-subtle">
              Pool: <b>${safe(poolId)}</b> ¬∑ Positions: <b>${safe(pos)}</b> ¬∑
              Points: <b>${safe(fmtDecStr(pts))}</b>
            </div>
          </div>
          ${meta ? `<div class="meta" title="${safe(meta)}">${safe(meta)}</div>` : `<div class="meta"></div>`}
        </div>

        <div class="stk-tokens">
          <span class="stk-token">${safe(t0)} <b>${safe(fmtDecStr(a0))}</b></span>
          <span class="stk-token">${safe(t1)} <b>${safe(fmtDecStr(a1))}</b></span>
        </div>
      </div>
    `;
  };

  const renderVenue = (name)=>{
    const v = venues?.[name] || {};
    const vPts = v?.points ?? '0';
    const subt = v?.subtotals || {};
    const rows = Array.isArray(v?.rows) ? v.rows : [];
    const lux = subt?.LUX ?? '0';
    const chips = subt?.CHIPS ?? '0';

    const openAttr = (name === venueNames[0]) ? 'open' : '';

    return `
      <div class="stk-venue">
        <details class="stk-acc" ${openAttr}>
          <summary>
            <div class="left">
              <div>
                ${safe(name)}
                <span class="staking-pill" style="margin-left:6px">points ${safe(fmtDecStr(vPts))}</span>
              </div>
              <div class="stk-subtle">
                Pools <b>${rows.length}</b> ¬∑ Subtotals: CHIPS <b>${safe(fmtDecStr(chips))}</b> ¬∑ LUX <b>${safe(fmtDecStr(lux))}</b>
              </div>
            </div>
            <div class="right"><span class="chev">‚Ä∫</span></div>
          </summary>
          <div class="body">
            ${rows.length ? rows.map(renderPool).join('') : `<div class="stk-subtle">No pools found in this venue.</div>`}
          </div>
        </details>
      </div>
    `;
  };

  // Hero copy super-chiara: +X% CHIPS per run
  const bonusText = bonus.pct >= 100
    ? `You are at the maximum bonus cap.`
    : `Add more token liquidity to gain more points and reach +${bonus.nextPct}% (need ~${Math.ceil(bonus.missing)} more points).`;

  host.innerHTML = `
    <div class="stk-hero">
      <div class="top">
        <div>
          <div class="big">+${bonus.pct}% CHIPS per expedition</div>
          <div class="sub">
            Your staking positions generate <b>${safe(fmtDecStr(grandPtsRaw))}</b> total points.
            Every expedition‚Äôs CHIPS rewards are multiplied by <b>x${bonus.mult.toFixed(2)}</b>.
          </div>
          <div class="stk-note">
            ${safe(bonusText)}
          </div>
        </div>

        <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
          <span class="pill">Total points: ${safe(fmtDecStr(grandPtsRaw))}</span>
          <span class="pill">Multiplier: x${bonus.mult.toFixed(2)}</span>
          <span class="pill">Targets: ${targets.length ? targets.map(safe).join(', ') : '‚Äî'}</span>
        </div>
      </div>

      <div class="bar" title="Progress to the next +1% tier">
        <i style="width:${bonus.progress}%"></i>
      </div>

      <div class="barline">
        <span>Current tier: <b>+${bonus.pct}%</b></span>
        <span>${bonus.pct >= 100 ? '<b>Maxed</b>' : `Next tier: <b>+${bonus.nextPct}%</b> at <b>${bonus.nextAt}</b> points`}</span>
      </div>
    </div>

    <div class="staking-card">
      <div class="title">
        <span>üè¶ Open staking positions (pools)</span>
        <span class="staking-pill">${venueNames.length} venues</span>
      </div>
      <div style="opacity:.9;font-size:12px;line-height:1.45;margin-bottom:8px">
        Expand a venue to see each pool, the token amounts in staking, and how many <b>points</b> each position generates.
        Increasing token amounts in these pools increases points ‚Üí increases your <b>+% CHIPS per expedition</b>.
      </div>
      ${venueNames.length ? venueNames.map(renderVenue).join('') : `<div class="stk-subtle">No venues in report.</div>`}
    </div>

    <div style="height:10px"></div>

    <div class="staking-card">
      <div class="title">
        <span>‚öôÔ∏è Scoring engine</span>
        <span class="staking-pill">params</span>
      </div>
      <div class="staking-kv">
        <div>
          <div class="k">wax_per_chips</div>
          <div class="v">${safe(fmtDecStr(scoring?.wax_per_chips))}</div>
        </div>
        <div>
          <div class="k">wax_per_lux</div>
          <div class="v">${safe(fmtDecStr(scoring?.wax_per_lux))}</div>
        </div>
        <div>
          <div class="k">x_points_per_chips</div>
          <div class="v">${safe(fmtDecStr(scoring?.x_points_per_chips))}</div>
        </div>
        <div>
          <div class="k">quote_token</div>
          <div class="v">${safe(report?.quote_token || '‚Äî')}</div>
        </div>
      </div>
    </div>
  `;
}

async function fetchAndRenderStakingReport({force=false} = {}){
  syncUserFromStorage();
  try { assertAuth(); } catch {
    setStakingMeta({account:'‚Äî', startedAtUtc:null, cacheLabel:'‚Äî'});
    renderStakingError('Not authenticated. Please connect your account first.');
    return;
  }

  const wax = (State.user.wax_account || '').trim().toLowerCase();
  const key = stakingCacheKey(wax);

  if (!force){
    try{
      const cachedRaw = localStorage.getItem(key);
      if (cachedRaw){
        const cached = JSON.parse(cachedRaw);
        if (cached && cached.report){
          setStakingMeta({
            account: wax,
            startedAtUtc: cached.report.started_at_utc,
            cacheLabel: `hit ¬∑ ${new Date(cached.savedAt).toLocaleTimeString()}`
          });
          renderStakingReport(cached.report);

          const ageMs = Date.now() - (cached.savedAt || 0);
          if (ageMs < 60_000) return;
        }
      }
    } catch {/* ignore */}
  }

  setStakingMeta({account:wax, startedAtUtc:null, cacheLabel: force ? 'refresh‚Ä¶' : 'miss‚Ä¶'});
  renderStakingSkeleton();

  const res = await Api.post('/staking_report', {
    wax_account: wax,
    user_id: State.user.user_id,
    usx_token: State.user.usx_token
  }, 60000);

  if (!res || !res.ok || !res.data){
    renderStakingError(res?.data?.error || 'Network / server error while generating the report.');
    setStakingMeta({account:wax, startedAtUtc:null, cacheLabel:'error'});
    return;
  }

  const report = normalizeStakingPayload(res.data);

  if (!report || !report.venues){
    renderStakingError('Staking report response has an unexpected format.');
    setStakingMeta({account:wax, startedAtUtc:null, cacheLabel:'bad format'});
    return;
  }

  try{
    localStorage.setItem(key, JSON.stringify({ savedAt: Date.now(), report }));
  } catch {/* ignore */}

  setStakingMeta({
    account: wax,
    startedAtUtc: report.started_at_utc,
    cacheLabel: 'fresh'
  });

  renderStakingReport(report);
}

function ensureStakingReportLoaded(){
  fetchAndRenderStakingReport({force:false});
}

    // ------------------------------------------------------------
    // SELEZIONE / CAP / UI BOTTONI
    // ------------------------------------------------------------

    function getSendCap(){
      const base = 50;
      const reinf = State.expedition.reinforcementCount || 0;
      const extraPer = 5;
      const extra = clamp(reinf * extraPer, 0, 200);
      return base + extra;
    }

    function updateCapUI(){
      const base = 50;
      const reinf = State.expedition.reinforcementCount || 0;
      const extraPer = 5;
      const extra = clamp(reinf * extraPer, 0, 200);
      const cap = base + extra;

      if (State.ui.capLabel){
        State.ui.capLabel.textContent = `Max goblins this run: ${cap}`;
      }
      if (State.ui.reinfLabel){
        State.ui.reinfLabel.textContent =
          `Base ${base} + ${reinf}√ó Reinforcement (= ${extra} extra)`;
      }
    }

    function getSelectedGoblins(){
      if (!State.goblinsUser || !State.goblinsUser.length) return [];
      const set = State.selectedGoblinIds;
      return State.goblinsUser.filter(g => set.has(g.asset_id));
    }

    function isGoblinTired(g){
      if (!g) return false;
      const id = String(g.asset_id);
      return State.runtime.forecastInsufficientIds
        ? State.runtime.forecastInsufficientIds.has(id)
        : false;
    }

    function updateActionButtonsUI(){
      const btn = State.ui.btnStart;
      if (!btn) return;
      const hasSel = State.selectedGoblinIds.size > 0;
      const inProg = !!State.runtime.expeditionInProgress;
      btn.disabled = !hasSel || inProg;
      if (inProg){
        btn.textContent = '‚õèÔ∏è Expedition running‚Ä¶';
      } else {
        btn.textContent = 'üöÄ Start Expedition';
      }
    }

    function setBuilderEnabled(enabled){
      const ids = ['filters','builder-controls','quick-select','goblin-list'];
      ids.forEach(id=>{
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.toggle('builder-disabled', !enabled);
      });
      const rf = document.getElementById('run-forecast');
      if (rf){
        rf.classList.toggle('builder-disabled', !enabled);
      }
    }

    function initDurationSwitch(){
      const sel = State.ui.durationSelect;
      const hint = State.ui.durationHint;
      if (!sel) return;

      const update = ()=>{
        const val = Number(sel.value || 30);
        State.expedition.durationMinutes = val;
        if (hint){
          hint.textContent = `Approx. ${formatMinutesShort(val)} expedition.`;
        }
        // ricalcola forecast quando cambi durata
        scheduleForecastIfReady();
      };

      sel.addEventListener('change', update);
      update();
    }

    // ------------------------------------------------------------
    // TEMPO / GLOBAL SNAPSHOT
    // ------------------------------------------------------------

    function fromSecondsRemaining(exp){
      const sr = toNumber(exp && exp.seconds_remaining);
      if (!sr) return null;
      const snapAt = exp._snapAt || Date.now();
      const endTs = snapAt + sr * 1000;
      return {
        endsAt(){
          return new Date(endTs);
        },
        leftMs(nowMs){
          const now = nowMs || Date.now();
          return Math.max(0, endTs - now);
        }
      };
    }

    function getEndsAt(exp){
      if (!exp) return null;
      if (exp.ends_at){
        const d = new Date(exp.ends_at);
        return isNaN(d.getTime()) ? null : d;
      }
      if (exp.end_time){
        const d = new Date(exp.end_time);
        return isNaN(d.getTime()) ? null : d;
      }
      const start = exp.start_time || exp.started_at || exp.timestamp;
      const durSec = exp.duration_seconds || exp.effective_seconds || exp.nominal_seconds;
      if (start && durSec){
        const d0 = new Date(start);
        if (!isNaN(d0.getTime())){
          return new Date(d0.getTime() + toNumber(durSec) * 1000);
        }
      }
      if (exp._snapAt && exp.seconds_remaining){
        return new Date(exp._snapAt + toNumber(exp.seconds_remaining) * 1000);
      }
      return null;
    }

    function getTimeLeftMs(exp, now){
      const end = getEndsAt(exp);
      if (!end) return null;
      const n = now instanceof Date ? now.getTime() : (now || Date.now());
      return Math.max(0, end.getTime() - n);
    }

    // ------------------------------------------------------------
    // ASSETS (background + goblin sprite)
    // ------------------------------------------------------------

    const Assets = { bg:null, goblin:null, chest:null };

    function loadImage(src){
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => resolve(null);
        img.src = src;
      });
    }

    async function loadAssets(){
      const [bg, gob, chest] = await Promise.all([
        loadImage('cave-grid.gif'),
        loadImage('goblin.png'),
        loadImage('chest_sprite.png')
      ]);
      if (bg) Assets.bg = bg;
      if (gob) Assets.goblin = gob;
      if (chest) Assets.chest = chest;
    }

    // ------------------------------------------------------------
    // TOAST / MESSAGGI VICINO AL CANVAS
    // ------------------------------------------------------------

    function toast(msg){
      const host = State.ui.toastHost;
      if (!host) return;
      const div = document.createElement('div');
      div.textContent = msg;
      div.className = 'toast';
      div.style.marginTop = '6px';
      host.appendChild(div);
      setTimeout(() => div.remove(), 4000);
    }

    function pushCanvasMsg(msg){
      const host = document.getElementById('canvas-feedback');
      if (!host) return;
      const p = document.createElement('div');
      p.className = 'msg';
      p.textContent = msg;
      host.appendChild(p);
      setTimeout(() => p.remove(), 4000);
    }

    // ------------------------------------------------------------
    // GOBLIN GLOBAL STATS PANEL
    // ------------------------------------------------------------
    function updateGoblinGlobalStats(statsSummary, countFallback){
      const totalCount = toNumber(statsSummary?.count_total) ||
                         toNumber(countFallback) || 0;
    
      const totals = statsSummary?.totals || {};
      const avgs   = statsSummary?.averages || {};
      const rarity = statsSummary?.rarity_counts || {};
    
      const totalPower = toNumber(totals.daily_power)   || 0;
      const avgPower   = toNumber(avgs.daily_power)     || 0;
    
      // pannello "Total goblins / Total daily power / Avg daily power"
      if (State.ui.goblinStatCount) {
        State.ui.goblinStatCount.textContent = String(totalCount);
      }
      if (State.ui.goblinStatTotal){
        State.ui.goblinStatTotal.textContent = formatCompact(totalPower);
      }
      if (State.ui.goblinStatAvg){
        State.ui.goblinStatAvg.textContent = formatDP(avgPower);
      }
    
      const setStrong = (id, val)=>{
        const el = document.getElementById(id);
        if (!el) return;
        const strong = el.querySelector('strong');
        if (strong) strong.textContent = String(val);
      };
    
      // power nel riepilogo a chip
      setStrong('gas-total-power', formatCompact(totalPower));
      setStrong('gas-avg-power',   formatDP(avgPower));
    
      // resto dei totali
      setStrong('gas-total-count', totalCount);
      setStrong('gas-total-res',   formatCompact(totals.resistance   || 0));
      setStrong('gas-total-acc',   formatCompact(totals.accuracy     || 0));
      setStrong('gas-total-loot',  formatCompact(totals.loot_hungry  || 0));
      setStrong('gas-total-speed', formatCompact(totals.speed        || 0));
    
      setStrong('gas-avg-res',   formatDP(avgs.resistance   || 0));
      setStrong('gas-avg-acc',   formatDP(avgs.accuracy     || 0));
      setStrong('gas-avg-loot',  formatDP(avgs.loot_hungry  || 0));
      setStrong('gas-avg-speed', formatDP(avgs.speed        || 0));
    
      setStrong('gas-rarity-mythic',    rarity.mythic    || 0);
      setStrong('gas-rarity-legendary', rarity.legendary || 0);
      setStrong('gas-rarity-epic',      rarity.epic      || 0);
      setStrong('gas-rarity-rare',      rarity.rare      || 0);
      setStrong('gas-rarity-common',    rarity.common    || 0);
    }

    // ------------------------------------------------------------
    // FORECAST (REAL + SIMULATOR)
    // ------------------------------------------------------------
    const requestForecastDebounced = debounce(requestForecast, 320);

    function scheduleForecastIfReady(){
      if (!State.nftsLoaded){
        renderForecast(null, 'Load your goblins to see a run forecast.');
        return;
      }

      const duration = State.expedition?.durationMinutes || 0;
      const sel = getSelectedGoblins();
      if (!duration || !sel.length) {
        renderForecast(null, 'Select some goblins and a duration.');
        return;
      }

      const payloadKey = JSON.stringify({
        d: duration,
        ids: sel.map(g=>g.asset_id).sort(),
        reinf: State.expedition?.reinforcementCount || 0
      });

      if (payloadKey === State.runtime.lastForecastPayloadKey && State.runtime.forecastData){
        renderForecast(State.runtime.forecastData, null);
        return;
      }
      State.runtime.lastForecastPayloadKey = payloadKey;
      requestForecastDebounced(duration, sel);
    }

    async function requestForecast(duration, selArr){
      //if (State.runtime.expeditionInProgress) { renderForecast(null, 'An expedition is running.'); return; }
      //if (!State.nftsLoaded) { renderForecast(null,'Load your goblins first.'); return; }
      //if (!selArr?.length || !duration) { renderForecast(null, ''); return; }
      //try { assertAuth(); } catch { renderForecast(null,'Sign in to preview rewards.'); return; }

      const body = {
        wax_account: State.user.wax_account,
        user_id: State.user.user_id,
        usx_token: State.user.usx_token,
        duration_minutes: duration,
        asset_ids: selArr.map(g=> g.asset_id),
        reinforcement_count: State.expedition?.reinforcementCount || 0
      };

      State.runtime.forecastBusy = true;
      renderForecastLoading();

      const res = await Api.post('/2expedition_forecast', body, 12000).catch(()=>({ok:false}));
      State.runtime.forecastBusy = false;

      if (!res || !res.ok || !res.data){
        renderForecast(null, 'Forecast unavailable right now.');
        return;
      }
      State.runtime.forecastData = res.data || {};
      
      const powerMap = (res.data && res.data.power_needed_by_asset) || {};
      State.runtime.forecastPowerByAsset = powerMap || {};
      State.runtime.forecastInsufficientIds = new Set();
      
      const sel = selArr || getSelectedGoblins();
      for (const g of sel) {
        const id = String(g.asset_id);
        const needed = toNumber(powerMap[id]);
        const dp = Number(g.daily_power_num || 0);
        if (needed && dp + 1e-6 < needed) {
          State.runtime.forecastInsufficientIds.add(id);
        }
      }
      
      renderForecast(res.data, null);
      hydrateGoblinBuilder(); // update card labels (POWER OK / LOW POWER)
    }

    function renderForecastLoading(){
      const host = ensureForecastShell();
      if (!host) return;

      host.hidden = false;
      const realPanel = document.getElementById('forecast-panel-real');
      if (realPanel){
        realPanel.innerHTML = `
          <div class="card">
            <div class="hint">Computing forecast‚Ä¶</div>
          </div>
        `;
      }

      State.runtime.forecastMode = 'real';
      updateForecastTabs(host);
    }

    // -------- shell + tabs (REAL / SIM) --------
    function ensureForecastShell() {
      const host = document.getElementById('run-forecast');
      if (!host) return null;
      if (!host.dataset.shellInitialized) {
        host.innerHTML = `
          <div class="hdr">
            <span class="tag cyan">Run Forecast & Simulator</span>
            <span class="hint">üîÑ Updates when you change duration, selection or simulator inputs.</span>
          </div>
          <div class="forecast-tabs" role="tablist" aria-label="Forecast mode">
            <button type="button"
                    data-mode="real"
                    aria-pressed="true">
              üß¨ My Goblins
            </button>
            <button type="button"
                    data-mode="sim"
                    aria-pressed="false">
              üß™ Attribute Simulator
            </button>
          </div>
          <div id="forecast-panel-real"></div>
          <div id="forecast-panel-sim" hidden>
            <div class="card">
              <div class="forecast-sim-form" aria-label="Run simulator">
                <label>
                  Duration (minutes)
                  <select id="sim-duration">
                    <option value="5">5m ‚Äî Blitz</option>
                    <option value="30" selected>30m ‚Äî Standard</option>
                    <option value="60">1h ‚Äî Long</option>
                    <option value="120">2h ‚Äî Marathon</option>
                    <option value="360">6h ‚Äî Endurance</option>
                    <option value="1440">24h ‚Äî Ultra</option>
                  </select>
                </label>
                <label>
                  Number of goblins
                  <input id="sim-goblins" type="number" min="1" step="1" inputmode="numeric" placeholder="e.g. 50">
                </label>
                <label>
                  Total Accuracy (ACC)
                  <input id="sim-acc" type="number" min="0" step="1" inputmode="numeric" placeholder="sum of ACC">
                </label>
                <label>
                  Total Resistance (RES)
                  <input id="sim-res" type="number" min="0" step="1" inputmode="numeric" placeholder="sum of RES">
                </label>
                <label>
                  Total Speed (SPD)
                  <input id="sim-spd" type="number" min="0" step="1" inputmode="numeric" placeholder="sum of SPD">
                </label>
                <label>
                  Total Loot Hungry (LOOT)
                  <input id="sim-loot" type="number" min="0" step="1" inputmode="numeric" placeholder="sum of LOOT">
                </label>
              </div>
              <div style="display:flex;justify-content:flex-start;margin-top:8px;gap:8px;">
                <button id="sim-run" class="btn-primary" type="button">
                  üß™ Run simulation
                </button>
              </div>
              <div id="forecast-sim-result" class="forecast-help" style="margin-top:8px;">
                <div class="forecast-help-title">üìò Attribute-based simulator</div>
                <p>
                  Enter <strong>number of goblins</strong> and your total
                  <strong>SPD / RES / LOOT / ACC</strong>. The simulator will run
                  <strong>the same backend math</strong> used for real expeditions and return:
                </p>
                <ul style="margin-top:4px;font-size:12px;">
                  <li>effective duration and Daily Power usage,</li>
                  <li>estimated CHIPS range and per-goblin averages,</li>
                  <li>token reward tiers with probabilities,</li>
                  <li>overall NFT chance and per-template drop chances.</li>
                </ul>
                <p style="margin-top:4px;font-size:12px;opacity:.85;">
                  No Daily Power is consumed and no on-chain expedition is started.
                </p>
              </div>
            </div>
          </div>
        `;
        host.dataset.shellInitialized = '1';
        wireForecastTabs(host);
        wireSimForm(host);
      }
      return host;
    }

    function wireForecastTabs(host) {
      const buttons = host.querySelectorAll('.forecast-tabs button[data-mode]');
      buttons.forEach(btn => {
        btn.onclick = () => {
          const mode = btn.getAttribute('data-mode') === 'sim' ? 'sim' : 'real';
          State.runtime.forecastMode = mode;
          updateForecastTabs(host);
        };
      });

      updateForecastTabs(host);
    }

    function updateForecastTabs(host) {
      const mode = State.runtime.forecastMode || 'real';
      const buttons = host.querySelectorAll('.forecast-tabs button[data-mode]');
      buttons.forEach(btn => {
        const m = btn.getAttribute('data-mode');
        btn.setAttribute('aria-pressed', String(m === mode));
      });

      const realPanel = document.getElementById('forecast-panel-real');
      const simPanel  = document.getElementById('forecast-panel-sim');
      if (realPanel) realPanel.hidden = (mode !== 'real');
      if (simPanel)  simPanel.hidden  = (mode !== 'sim');
    }

    // ---------- REAL forecast panel (with your goblins) ----------
    function updateForecastRealPanel(data, message) {
      const panel = document.getElementById('forecast-panel-real');
      if (!panel) return;

      panel.innerHTML = renderForecastRealContent(data, message);
    }

    function renderForecastRealContent(data, message){
      if (message){
        return `
          <div class="card">
            <div class="hint">${safe(message)}</div>
          </div>
        `;
      }
      if (!data){
        return '';
      }

      const durNominal = State.expedition.durationMinutes || 0;
      const durEff = toNumber(data.duration_effective_minutes) || durNominal;
      const durEffSeconds = toNumber(
        data.duration?.effective_seconds ??
        data.duration_effective_seconds ??
        durEff * 60
      );
      
      const tMin = toNumber(data.tokens_min);
      const tMax = toNumber(data.tokens_max);
      const probs = data.token_tier_probs || {};
      const nftRewards = Array.isArray(data.nft_rewards) ? data.nft_rewards : [];
      const msgs = Array.isArray(data.messages) ? data.messages : [];
      const selectedCountBackend = toNumber(data.selected_count);
      const selectedCount = selectedCountBackend || State.selectedGoblinIds.size || 0;
      const tierEff = bucketFromMinutes(durEff);
      // nuovo blocco power dal backend
      const powerBlock = data.power || {};
      const powTot = toNumber(
        powerBlock.total_power_effective ??
        data.power_needed_total ??
        0
      );
      const baseNominalPerGoblin = toNumber(
        powerBlock.base_cost_nominal_per_goblin ??
        0
      );
      let effAvgPerGoblin = toNumber(
        powerBlock.base_cost_effective_per_goblin ??
        0
      );
      const totalPowerNominal = toNumber(
        powerBlock.total_power_nominal ??
        (baseNominalPerGoblin * selectedCount)
      );

      const totalPowerEffective = toNumber(
        powerBlock.total_power_effective ??
        data.power_needed_total ??
        totalPowerNominal
      );
      
      // fallback difensivo se manca il campo specifico
      if (!effAvgPerGoblin && powTot && selectedCount) {
        effAvgPerGoblin = powTot / selectedCount;
      }

      // tired goblins: prima usiamo il dato del backend, poi il set locale come fallback
      const tiredFromBackend = toNumber(powerBlock.tired_goblins_effective);
      const tiredCount = tiredFromBackend ||
        (State.runtime.forecastInsufficientIds
          ? State.runtime.forecastInsufficientIds.size
          : 0);


      return `
        <div class="grid">
          <div class="card">
            <div class="kv">
              <div title="Minutes chosen in the duration selector.">
                <span class="label">‚è± Nominal duration</span>
                <b>${durNominal} min</b>
              </div>
              <div title="Estimated duration after the total SPEED bonus is applied.">
                <span class="label">‚ö° Effective duration</span>
                <b>
                  ${formatDurationMinSecFromSeconds(durEffSeconds)}
                  <span class="badge-inline">tier ${tierEff}m</span>
                </b>
              </div>
              <div title="Base daily cost per goblin BEFORE RESISTANCE is applied, for this duration tier.">
                <span class="label">üí∞ Nominal daily cost / goblin</span>
                <b>
                  ${formatDP(baseNominalPerGoblin)} DP
                  <span class="badge-inline">base</span>
                </b>
              </div>
              
              <div title="Average effective daily cost per goblin AFTER RESISTANCE.">
                <span class="label">üõ°Ô∏è Effective daily cost / goblin</span>
                <b>
                  ${selectedCount ? formatDP(effAvgPerGoblin) : '‚Äî'} DP
                  <span class="badge-inline">effective</span>
                </b>
              </div>
              
              <div title="Sum of all NOMINAL daily power costs (without RES) for this run.">
                <span class="label">üîã Total daily power (nominal)</span>
                <b>${Number.isFinite(totalPowerNominal) ? formatDP(totalPowerNominal) : '‚Äî'} DP</b>
              </div>
              
              <div title="Sum of all EFFECTIVE daily power costs (with RES) for this run.">
                <span class="label">üîã Total daily power (effective)</span>
                <b>${Number.isFinite(totalPowerEffective) ? formatDP(totalPowerEffective) : '‚Äî'} DP</b>
              </div>

              <div title="Goblins actually used in the forecast (after applying the cap, if exceeded).">
                <span class="label">üß¨ Selected goblins</span>
                <b>${selectedCount}</b>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="kv">
              <div title="Expected CHIPS reward range for this run.">
                <span class="label">üíé Chips (min‚Äìmax)</span>
                <b>
                  ${Number.isFinite(tMin) ? tMin : '‚Äî'} ‚Äì ${Number.isFinite(tMax) ? tMax : '‚Äî'}
                  <span class="badge-inline">reward</span>
                </b>
              </div>
              ${Object.keys(probs).length ? `
              <div title="Relative probability of token reward tiers based on average ACC.">
                <span class="label">üìä Token tier probabilities</span>
                <b>${
                  Object.entries(probs)
                    .map(([k,v]) => `${safe(k)} ${Math.round(v * 100)}%`)
                    .join(' ¬∑ ')
                }</b>
              </div>` : ''}

              ${nftRewards.length ? `
              <div title="Approximate chance of receiving each NFT template in a single run.">
                <span class="label">üéÅ NFT drop chances</span>
                <b>${
                  nftRewards
                    .map(it => `${safe(it.name)} ${Math.round((it.chance || 0) * 100)}%`)
                    .join(' ¬∑ ')
                }</b>
              </div>` : ''}

              ${tiredCount ? `
              <div style="margin-top:6px;">
                <button id="btn-remove-tired" class="btn-primary" type="button">
                  üí§ Remove ${tiredCount} tired goblin${tiredCount > 1 ? 's' : ''} from selection
                </button>
              </div>` : ''}
            </div>
          </div>
        </div>

        <div class="card forecast-help">
          <div class="forecast-help-title">üìò How your attributes affect this run</div>
          <ul>
            <li><strong>Speed (SPD)</strong> makes the run <em>finish faster</em> by reducing effective duration.</li>
            <li><strong>Resistance (RES)</strong> <em>reduces Daily Power cost</em> per goblin, making runs cheaper.</li>
            <li><strong>Loot Hungry (LOOT)</strong> scales how many <em>CHIPS</em> you can loot on average.</li>
            <li><strong>Accuracy (ACC)</strong> improves <em>reward quality</em>: better token tiers and higher NFT drop chances.</li>
          </ul>
        </div>

        ${msgs.length ? `<div class="hint">‚ÑπÔ∏è ${msgs.map(safe).join(' ¬∑ ')}</div>` : ''}
      `;
    }

    // ---------- SIMULATOR result panel ----------
    function updateForecastSimResult() {
      const host = document.getElementById('forecast-sim-result');
      if (!host) return;
    
      const cfg = State.runtime.simConfig || {};
      const sim = State.runtime.simResult;
    
      // Nessun risultato ancora ‚Üí testo introduttivo
      if (!sim) {
        host.innerHTML = `
          <div class="forecast-help-title">üìò Attribute-based simulator</div>
          <p>
            Enter <strong>number of goblins</strong> and your total
            <strong>SPD / RES / LOOT / ACC</strong>, then click
            <strong>Run simulation</strong>.
          </p>
          <p style="margin-top:4px;font-size:12px;opacity:.85;">
            The simulator uses the same logic as real expeditions, but
            <strong>does not spend</strong> Daily Power and does not start
            any on-chain run.
          </p>
        `;
        return;
      }
    
      // -------------------------
      //  Estrazione dati backend
      // -------------------------
    
      const durationRequested = toNumber(
        sim.duration?.requested_minutes ??
        sim.duration_minutes ??
        cfg.durationMinutes ??
        30
      );
    
      const durationEffective = toNumber(
        sim.duration?.effective_minutes ??
        sim.duration_effective_minutes ??
        durationRequested
      );
    
      const effectiveSeconds = toNumber(
        sim.duration?.effective_seconds ??
        sim.duration_effective_seconds ??
        durationEffective * 60
      );
    
      const goblinsCount = toNumber(
        sim.goblins_count ??
        sim.selected_count ??
        cfg.goblinsCount ??
        0
      );
    
      // Power block
      const power = sim.power || {};
      const nominalPerGoblin = toNumber(
        power.base_cost_nominal_per_goblin ?? 0
      );
      const effectivePerGoblin = toNumber(
        power.base_cost_effective_per_goblin ?? 0
      );
      
      const totalPowerNominal = toNumber(
        power.total_power_nominal ?? (nominalPerGoblin * goblinsCount)
      );
      const totalPowerEffective = toNumber(
        power.total_power_effective ?? totalPowerNominal
      );
      const tiredGoblins = toNumber(power.tired_goblins_effective ?? 0);
    
      const dailyPowerBlock = power.daily_power || {};
      const dpBefore = toNumber(dailyPowerBlock.total_before ?? 0);
      const dpAfter  = toNumber(dailyPowerBlock.total_after_effective ?? 0);
    
      // Stats totali inserite in input alla sim
      const statsTotals = sim.stats_totals || {};
      const totalAcc   = toNumber(statsTotals.accuracy ?? 0);
      const totalLoot  = toNumber(statsTotals.loot_hungry ?? 0);
      const totalRes   = toNumber(statsTotals.resistance ?? 0);
      const totalSpd   = toNumber(statsTotals.speed ?? 0);
    
      // Tokens
      const tokens = sim.tokens || {};
      const tExpected = toNumber(tokens.expected_total ?? 0);
      const tMin      = toNumber(tokens.min_total ?? 0);
      const tMax      = toNumber(tokens.max_total ?? 0);
    
      const perGoblinAvg = tokens.per_goblin_average || {};
      const tAvgExpectedPerGoblin = toNumber(perGoblinAvg.expected ?? 0);
      const tMinPerGoblin         = toNumber(perGoblinAvg.min ?? 0);
      const tMaxPerGoblin         = toNumber(perGoblinAvg.max ?? 0);
    
      const tierProbsPercent = tokens.tier_probs_percent || {};
      const tierProbs = Object.keys(tierProbsPercent).length
        ? tierProbsPercent
        : (tokens.tier_probs || {});
    
      const probsAlreadyPercent = Object.keys(tierProbsPercent).length > 0;
    
      const fmtTierPct = (v) => {
        const num = Number(v) || 0;
        const pct = probsAlreadyPercent ? num : num * 100;
        return `${pct.toFixed(1).replace(/\.0$/,'')}%`;
      };
    
      const prettyTierName = (key) => {
        const k = String(key || '').toLowerCase();
        if (k.includes('low')) return 'Small token reward';
        if (k.includes('mid') || k.includes('medium')) return 'Medium token reward';
        if (k.includes('high') && !k.includes('very')) return 'High token reward';
        if (k.includes('very') || k.includes('jackpot')) return 'Very high token reward';
        return key;
      };
    
      const tierClassByIndex = (idx) => {
        if (idx === 0) return 'sim-chip-token-low';
        if (idx === 1) return 'sim-chip-token-mid';
        if (idx === 2) return 'sim-chip-token-high';
        return 'sim-chip-token-veryhigh';
      };
    
      // NFT
      const nfts = sim.nfts || {};
      const nftAnyChance = (function() {
        if (nfts.any_nft_chance_percent != null)
          return `${(Number(nfts.any_nft_chance_percent) || 0)
            .toFixed(2).replace(/\.00$/,'')}%`;
        if (nfts.any_nft_chance != null)
          return `${((Number(nfts.any_nft_chance) || 0) * 100)
            .toFixed(2).replace(/\.00$/,'')}%`;
        return null;
      })();
    
      const nftRewards = Array.isArray(nfts.rewards) ? nfts.rewards : [];
    
      const fmtNftChance = (item) => {
        if (item.chance_percent != null)
          return `${(Number(item.chance_percent) || 0)
            .toFixed(3).replace(/\.000$/,'')}%`;
        if (item.chance != null)
          return `${((Number(item.chance) || 0) * 100)
            .toFixed(3).replace(/\.000$/,'')}%`;
        return 'rare';
      };
    
      // Messaggi dal backend
      const messages = Array.isArray(sim.messages) ? sim.messages : [];
    
      // Helpers UI HTML
      const tokenProbsHtml = Object.keys(tierProbs).length
        ? `
          <div class="sim-section-title">Token reward probabilities</div>
          <div class="sim-chips">
            ${
              Object.entries(tierProbs)
                .sort((a,b) => (Number(b[1])||0) - (Number(a[1])||0))
                .map(([key, value], idx) => `
                  <span class="sim-chip ${tierClassByIndex(idx)}">
                    <span class="sim-chip-label">${safe(prettyTierName(key))}</span>
                    <span class="sim-chip-value">${fmtTierPct(value)}</span>
                  </span>
                `).join('')
            }
          </div>
        `
        : `
          <div class="sim-section-title">Token reward probabilities</div>
          <p style="font-size:12px;opacity:.85;">No token probability breakdown available for this configuration.</p>
        `;
    
      const nftChipsHtml = nftRewards.length
        ? `
          <div class="sim-section-title">Collectible item chances (NFTs)</div>
          <div class="sim-chips">
            ${
              nftRewards.map((n) => {
                const name = safe(n.name || n.template_name || 'Unknown item');
                const label = fmtNftChance(n);
                return `
                  <span class="sim-chip sim-chip-nft">
                    <span class="sim-chip-label">${name}</span>
                    <span class="sim-chip-value">${label}</span>
                  </span>
                `;
              }).join('')
            }
          </div>
        `
        : `
          <div class="sim-section-title">Collectible item chances (NFTs)</div>
          <p style="font-size:12px;opacity:.85;">
            This sample expedition has no specific collectible item chances to display.
          </p>
        `;
    
      // -------------------------
      //  Render finale UI
      // -------------------------
    
      host.innerHTML = `
        <div class="forecast-help-title">üß™ Simulation result</div>
    
        <div class="sim-grid">
          <!-- Colonna sinistra: setup + power + CHIPS -->
          <div class="sim-card">
            <div class="sim-section-title">Expedition setup (simulated)</div>
            <ul style="margin:0;padding-left:18px;font-size:13px;">
              <li><strong>Requested duration:</strong> ${durationRequested} minutes</li>
              <li>
                <strong>Effective duration:</strong>
                ${durationEffective} minutes
                <span style="opacity:.7">
                  (${formatDurationMinSecFromSeconds(effectiveSeconds)})
                </span>
              </li>
              <li><strong>Number of goblins:</strong> ${goblinsCount}</li>
            </ul>
    
            <div style="height:6px;"></div>
    
            <div class="sim-section-title">Daily Power usage</div>
            <ul style="margin:0;padding-left:18px;font-size:13px;">
              <li>
                <strong>Nominal cost / goblin (no RES):</strong>
                ${formatDP(nominalPerGoblin)} DP
              </li>
              <li>
                <strong>Effective cost / goblin (with RES):</strong>
                ${formatDP(effectivePerGoblin || (totalPowerEffective && goblinsCount ? totalPowerEffective / goblinsCount : 0))} DP
              </li>
              <li>
                <strong>Total DP (nominal):</strong>
                ${formatDP(totalPowerNominal)} DP
              </li>
              <li>
                <strong>Total DP (effective):</strong>
                ${formatDP(totalPowerEffective)} DP
              </li>
              <li>
                <strong>Total DP before RES:</strong>
                ${dpBefore ? formatDP(dpBefore) : '‚Äî'} 
                <span style="opacity:.7">(raw)</span>
              </li>
              <li>
                <strong>Total DP after RES:</strong>
                ${dpAfter ? formatDP(dpAfter) : '‚Äî'} 
                <span style="opacity:.7">(effective)</span>
              </li>
              <li>
                <strong>Tired goblins in this sim:</strong>
                ${tiredGoblins}
              </li>
            </ul>
    
            <div style="height:6px;"></div>
    
            <div class="sim-section-title">Total attributes used in this simulation</div>
            <ul style="margin:0;padding-left:18px;font-size:13px;">
              <li><strong>SPD (Speed):</strong> ${formatCompact(totalSpd)}</li>
              <li><strong>RES (Resistance):</strong> ${formatCompact(totalRes)}</li>
              <li><strong>LOOT (Loot Hungry):</strong> ${formatCompact(totalLoot)}</li>
              <li><strong>ACC (Accuracy):</strong> ${formatCompact(totalAcc)}</li>
            </ul>
    
            <p style="margin-top:8px;font-size:12px;opacity:.85;">
              These values come directly from your input to the simulator and represent
              the <strong>total sum</strong> of all goblins in this hypothetical run.
            </p>
          </div>
    
          <!-- Colonna destra: CHIPS + tier + NFT -->
          <div class="sim-card">
            <div class="sim-section-title">CHIPS rewards (simulated)</div>
            <ul style="margin:0;padding-left:18px;font-size:13px;">
              <li>
                <strong>Estimated CHIPS range (total):</strong>
                ${tMin || '0'} ‚Äì ${tMax || '0'}
              </li>
              <li>
                <strong>Estimated average CHIPS (total):</strong>
                ${tExpected || 0}
              </li>
              <li>
                <strong>Per goblin (min / avg / max):</strong>
                ${tMinPerGoblin || 0} / ${tAvgExpectedPerGoblin || 0} / ${tMaxPerGoblin || 0}
              </li>
            </ul>
    
            <div style="height:8px;"></div>
    
            ${tokenProbsHtml}
            <div style="height:6px;"></div>
            ${
              nftAnyChance
                ? `<p style="font-size:12px;opacity:.9;margin:4px 0;">
                     Overall chance to receive <strong>at least one NFT</strong> in this run:
                     <strong>${nftAnyChance}</strong>.
                   </p>`
                : ''
            }
            ${nftChipsHtml}
          </div>
        </div>
    
        <p style="margin-top:8px;font-size:12px;opacity:.8;">
          All values are indicative and based on the same logic used by real expeditions.
          Actual rewards in live runs can be higher or lower due to randomness and per-goblin details.
        </p>
    
        ${
          messages.length
            ? `<p style="margin-top:6px;font-size:12px;opacity:.9;">
                 ‚ÑπÔ∏è ${messages.map(safe).join(' ¬∑ ')}
               </p>`
            : ''
        }
      `;
    }

    // ---------- wire simulator form ----------
    function wireSimForm(host) {
      const cfg = State.runtime.simConfig;

      const selDuration = host.querySelector('#sim-duration');
      const inGoblins   = host.querySelector('#sim-goblins');
      const inAcc       = host.querySelector('#sim-acc');
      const inRes       = host.querySelector('#sim-res');
      const inSpd       = host.querySelector('#sim-spd');
      const inLoot      = host.querySelector('#sim-loot');
      const btnRun      = host.querySelector('#sim-run');

      // init values
      if (selDuration) selDuration.value = String(cfg.durationMinutes || 30);
      if (inGoblins)   inGoblins.value   = String(cfg.goblinsCount || 0);
      if (inAcc)       inAcc.value       = String(cfg.totalAcc || 0);
      if (inRes)       inRes.value       = String(cfg.totalRes || 0);
      if (inSpd)       inSpd.value       = String(cfg.totalSpeed || 0);
      if (inLoot)      inLoot.value      = String(cfg.totalLoot || 0);

      if (selDuration) selDuration.addEventListener('change', () => {
        cfg.durationMinutes = Number(selDuration.value || 30);
      });

      const syncNumber = (inputEl, key) => {
        if (!inputEl) return;
        inputEl.addEventListener('input', () => {
          const val = Number(inputEl.value || 0);
          cfg[key] = isNaN(val) ? 0 : val;
        });
      };

      syncNumber(inGoblins, 'goblinsCount');
      syncNumber(inAcc,     'totalAcc');
      syncNumber(inRes,     'totalRes');
      syncNumber(inSpd,     'totalSpeed');
      syncNumber(inLoot,    'totalLoot');

      if (btnRun) {
        btnRun.addEventListener('click', () => {
          runSimulationFromForm();
        });
      }
    }

    // ---------- call /2expedition_simulate with TOTALS ----------
    async function runSimulationFromForm() {
      const cfg = State.runtime.simConfig || {};
      const host = document.getElementById('forecast-sim-result');
      if (!host) return;
    
      const goblinsCount = Number(cfg.goblinsCount || 0);
      if (!goblinsCount || goblinsCount <= 0) {
        State.runtime.simResult = null;
        updateForecastSimResult();
        return;
      }
    
      host.innerHTML = `
        <div class="forecast-help-title">üß™ Attribute-based simulator</div>
        <p>Calculating a sample expedition with your numbers‚Ä¶</p>
      `;
    
      const body = {
        duration_minutes: Number(cfg.durationMinutes || 30),
        goblins_count: goblinsCount,
        total_accuracy: Number(cfg.totalAcc || 0),
        total_resistance: Number(cfg.totalRes || 0),
        total_speed: Number(cfg.totalSpeed || 0),
        total_loot: Number(cfg.totalLoot || 0)
      };
    
      let res;
      try {
        res = await Api.post(SIMULATION_API_PATH, body, 15000);
      } catch (e) {
        res = { ok: false, error: e };
      }
    
      if (!res.ok || !res.data) {
        State.runtime.simResult = null;
        host.innerHTML = `
          <div class="forecast-help-title">üß™ Attribute-based simulator</div>
          <p>Simulation is temporarily unavailable. Please try again in a few seconds.</p>
        `;
        return;
      }
    
      // üëá Qui usiamo direttamente la struttura del backend, che ha:
      // duration, goblins_count, power, stats_totals, tokens, nfts, messages, ecc.
      State.runtime.simResult = res.data || {};
      updateForecastSimResult();
    }

    // MAIN: keep existing renderForecast entry point
    function renderForecast(data, message) {
      const mode = State.runtime.forecastMode || 'real';
      const host = ensureForecastShell();
      if (!host) return;

      if (!data && !message && mode === 'real') {
        host.hidden = false; // keep the shell visible
        updateForecastRealPanel(null, 'Select some goblins and a duration.');
        updateForecastSimResult();
        wireRemoveTiredButton();
        return;
      }

      host.hidden = false;
      updateForecastTabs(host);
      updateForecastRealPanel(data, message);
      updateForecastSimResult();
      wireRemoveTiredButton();
    }

    function wireRemoveTiredButton(){
      const btn = document.getElementById('btn-remove-tired');
      if (!btn) return;
      btn.onclick = () => {
        if (!State.goblinsUser?.length) return;
        const before = State.selectedGoblinIds.size;
        for (const id of Array.from(State.runtime.forecastInsufficientIds || [])){
          State.selectedGoblinIds.delete(id);
        }
        const after = State.selectedGoblinIds.size;
        hydrateGoblinBuilder();
        toast(`Removed tired goblins: ${before - after}`);
      };
    }

    // ------------------------------------------------------------
    // NFT STAT HELP
    // ------------------------------------------------------------
    function getStatFromNFT(nft, key) {
      if (!nft) return 0;
      const tryKeys = [key];
      if (key === 'loot_hungry') tryKeys.push('lootHungry','loot-hungry','loothungry');
      const buckets = [nft[key], nft.attributes, nft.attrs, nft.stats, nft.data, nft.mutable_data, nft.immutable_data];
      for (const val of buckets){
        if (val == null) continue;
        if (typeof val === 'number' || typeof val === 'string') return toNumber(val);
        if (typeof val === 'object' && !Array.isArray(val)){
          for (const k of tryKeys){ if (val[k] != null) return toNumber(val[k]); }
        }
        if (Array.isArray(val)){
          for (const attr of val){
            const trait = String(attr.trait_type || attr.trait || attr.key || attr.name || '').toLowerCase();
            if (tryKeys.some(k => k.toLowerCase() === trait)) return toNumber(attr.value ?? attr.val ?? attr.score);
          }
        }
      }
      return 0;
    }

    // ------------------------------------------------------------
    // TRAIL
    // ------------------------------------------------------------
    class NeonTrail {
      constructor(){
        this.points = [];
        this.maxPoints = CONFIG.trailMaxPoints;
        this.baseMaxAgeMs = CONFIG.trailBaseMaxAgeMs;
        this.minDist = CONFIG.trailMinPointDist;
        this._lastAddX = null;
        this._lastAddY = null;
      }

      reset(){
        this.points.length = 0;
        this._lastAddX = this._lastAddY = null;
      }

      add(x, y, speed, nowMs){
        const lx = this._lastAddX, ly = this._lastAddY;
        if (lx != null){
          const dx = x - lx, dy = y - ly;
          if (dx*dx + dy*dy < this.minDist*this.minDist) return;
        }
        this._lastAddX = x; this._lastAddY = y;

        this.points.push({ x, y, tMs: nowMs, spd: speed });
        if (this.points.length > this.maxPoints) this.points.shift();
      }

      prune(nowMs, speed){
        const maxAge = this.baseMaxAgeMs + clamp(speed*45, 0, 750);
        while (this.points.length && (nowMs - this.points[0].tMs) > maxAge) this.points.shift();
      }

      draw(ctx, tr, mainHue = 170){
        if (this.points.length < 3) return;

        const { toScreen, cellSizeX, cellSizeY } = tr;
        const thickBase = Math.max(1, ((cellSizeX+cellSizeY)/2) * 0.10);

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const pts = this.points;
        const scr = pts.map(p => ({ ...p, s: toScreen(p.x, p.y) }));

        for (let pass = 0; pass < 2; pass++){
          const isCore = pass === 1;
          const widthMul = isCore ? 0.70 : 1.95;
          const alphaMul = isCore ? 0.85 : 0.55;

          ctx.beginPath();
          const p0 = scr[0].s;
          ctx.moveTo(p0.x, p0.y);

          for (let i = 1; i < scr.length - 1; i++){
            const a = scr[i].s;
            const b = scr[i+1].s;
            const mx = (a.x + b.x) * 0.5;
            const my = (a.y + b.y) * 0.5;
            ctx.quadraticCurveTo(a.x, a.y, mx, my);
          }
          const pn = scr[scr.length - 1].s;
          ctx.lineTo(pn.x, pn.y);
          ctx.stroke();

          for (let i = 0; i < scr.length - 2; i++){
            const A = scr[i], B = scr[i+1], C = scr[i+2];
            const k = i / Math.max(1, (scr.length - 3));
            const fade = (1 - k);
            const spd = Math.max(A.spd, B.spd, C.spd);

            const w = thickBase * widthMul * (0.8 + clamp(spd/16, 0, 1)*0.9) * (0.35 + 0.65*fade);
            const a = (0.03 + 0.26*fade*fade) * alphaMul;

            const hueA = mainHue;
            const hueB = (mainHue + 140) % 360;

            ctx.lineWidth = w;
            ctx.strokeStyle = `hsla(${hueA}, 100%, ${isCore ? 70 : 60}%, ${a})`;
            ctx.beginPath();
            ctx.moveTo(A.s.x, A.s.y);
            ctx.quadraticCurveTo(B.s.x, B.s.y, C.s.x, C.s.y);
            ctx.stroke();

            ctx.lineWidth = Math.max(1, w*0.55);
            ctx.strokeStyle = `hsla(${hueB}, 100%, ${isCore ? 65 : 55}%, ${a*0.55})`;
            ctx.beginPath();
            ctx.moveTo(A.s.x, A.s.y);
            ctx.quadraticCurveTo(B.s.x, B.s.y, C.s.x, C.s.y);
            ctx.stroke();
          }
        }

        ctx.restore();
      }
    }

    // ------------------------------------------------------------
    // ENTITIES
    // ------------------------------------------------------------
    class GoblinEntity {
      constructor({ id, owner, color, x, y }){
        this.id = String(id);
        this.owner = owner || 'goblin';
        this.color = color || '#facc15';

        this.x = x; this.y = y;
        this.vx = randRange(-0.4, 0.4);
        this.vy = randRange(-0.4, 0.4);
        this.ax = 0; this.ay = 0;

        this.maxSpeed = randRange(CONFIG.goblinSpeedMin, CONFIG.goblinSpeedMax);
        this.boostSpeed = this.maxSpeed * 1.35;

        this.maxForce = 26.0;
        this.friction = 0.90;

        this.wanderAngle = randRange(0, Math.PI*2);
        this.wanderRadius = 1.05;
        this.wanderDistance = 1.85;
        this.wanderJitter = 1.55;

        this.tx = x; this.ty = y;
        this.nextTargetAt = 0;

        this.facing = 1;
        this._faceLockUntil = 0;

        this.gaitPhase = randRange(0, Math.PI*2);
        this.walkPhase = randRange(0, Math.PI*2);

        this.trail = new NeonTrail();
        this.trailHue = 165;
      }

      _normalize(x, y){
        const m = Math.hypot(x, y);
        if (m < 1e-9) return {x:0, y:0};
        return {x:x/m, y:y/m};
      }
      _limitVec(x, y, max){
        const m = Math.hypot(x, y);
        if (m <= max || m < 1e-9) return {x, y};
        const s = max / m;
        return {x:x*s, y:y*s};
      }
      _seek(tx, ty, desiredSpeed){
        const dx = tx - this.x;
        const dy = ty - this.y;
        const n = this._normalize(dx, dy);
        const dvx = n.x * desiredSpeed;
        const dvy = n.y * desiredSpeed;
        return { x: dvx - this.vx, y: dvy - this.vy };
      }
      _arrive(tx, ty, desiredSpeed, slowRadius=3.2){
        const dx = tx - this.x, dy = ty - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 1e-6) return {x:0,y:0};
        const t = clamp(dist / slowRadius, 0, 1);
        const sp = desiredSpeed * (0.15 + 0.85 * t);
        return this._seek(tx, ty, sp);
      }
      _wander(){
        this.wanderAngle += randRange(-1,1) * this.wanderJitter * 0.11;
        const vNorm = this._normalize(this.vx, this.vy);
        const dir = (Math.hypot(vNorm.x,vNorm.y) < 1e-3)
          ? {x:Math.cos(this.wanderAngle), y:Math.sin(this.wanderAngle)}
          : vNorm;

        const px = this.x + dir.x * this.wanderDistance;
        const py = this.y + dir.y * this.wanderDistance;

        const wx = px + Math.cos(this.wanderAngle) * this.wanderRadius;
        const wy = py + Math.sin(this.wanderAngle) * this.wanderRadius;

        return this._seek(wx, wy, this.maxSpeed * 0.65);
      }
      _wallAvoid(engine){
        const { minX, maxX, minY, maxY } = engine.getBounds();
        const soft = 2.2;

        const dl = (this.x - minX);
        const dr = (maxX - this.x);
        const dt = (this.y - minY);
        const db = (maxY - this.y);

        let fx = 0, fy = 0;
        const repel = (d) => {
          const dd = Math.max(0.06, d);
          const t = clamp((soft - dd)/soft, 0, 1);
          return (t*t) / (dd*dd);
        };

        fx += repel(dl) *  1;
        fx += repel(dr) * -1;
        fy += repel(dt) *  1;
        fy += repel(db) * -1;

        return { x: fx * this.maxForce * 2.3, y: fy * this.maxForce * 2.3 };
      }
      _separation(engine){
        const SEP_R = 1.35;
        const SEP_R2 = SEP_R*SEP_R;
        let sx=0, sy=0, count=0;

        for (const other of engine.goblins.values()){
          if (other === this) continue;
          const dx = this.x - other.x;
          const dy = this.y - other.y;
          const d2 = dx*dx + dy*dy;
          if (d2 < 1e-6 || d2 > SEP_R2) continue;

          const d = Math.sqrt(d2);
          const push = (SEP_R - d) / SEP_R;
          sx += (dx / d) * push;
          sy += (dy / d) * push;
          count++;
        }
        if (!count) return {x:0, y:0};
        sx/=count; sy/=count;
        return { x: sx * this.maxForce * 1.2, y: sy * this.maxForce * 1.2 };
      }
      _pickNewTarget(engine, now){
        const { minX, maxX, minY, maxY } = engine.getBounds();
        this.tx = randRange(minX+2, maxX-2);
        this.ty = randRange(minY+2, maxY-2);
        this.nextTargetAt = now + 1300 + Math.random()*2200;
      }

      update(dt, engine){
        const now = performance.now();

        if (!this.nextTargetAt || now > this.nextTargetAt || Math.hypot(this.tx-this.x, this.ty-this.y) < 1.2){
          this._pickNewTarget(engine, now);
        }

        this.gaitPhase += dt * 3.0;
        const gait = 0.78 + 0.20*Math.sin(this.gaitPhase) + 0.10*Math.sin(this.gaitPhase*0.55 + 1.8);
        const desiredSpeed = this.maxSpeed * gait;
        const fTarget = this._arrive(this.tx, this.ty, desiredSpeed, 4.6);
        const fWander = this._wander();
        const fWall = this._wallAvoid(engine);
        const fSep  = this._separation(engine);
        
        let fChest = {x:0, y:0};
        if (engine.drop && State.drop.fx.phase === 'visible') {
          const dx = engine.drop.world.x - this.x;
          const dy = engine.drop.world.y - this.y;
          const dist = Math.hypot(dx, dy);
        
          if (dist > 3 && dist < 11) {
            const pull = (1 - clamp((dist-3)/(11-3), 0, 1));
            fChest = this._seek(engine.drop.world.x, engine.drop.world.y, this.maxSpeed * (0.85 + 0.35*pull));
            this.trailHue = 170 + 60*pull;
          } else {
            this.trailHue = 165;
          }
        } else {
          this.trailHue = 165;
        }
        
        this.ax = 0; this.ay = 0;
        this.ax += fTarget.x * 1.10;
        this.ay += fTarget.y * 1.10;
        
        this.ax += fWall.x   * 1.00;
        this.ay += fWall.y   * 1.00;
        
        this.ax += fSep.x    * 0.75;
        this.ay += fSep.y    * 0.75;
        
        this.ax += fWander.x * 0.40;
        this.ay += fWander.y * 0.40;
        
        // ‚úÖ chest force
        this.ax += fChest.x * 0.22;
        this.ay += fChest.y * 0.22;


        const aLim = this._limitVec(this.ax,this.ay,this.maxForce);
        this.ax=aLim.x; this.ay=aLim.y;

        this.vx += this.ax * dt;
        this.vy += this.ay * dt;

        this.vx *= this.friction;
        this.vy *= this.friction;

        const vLim = this._limitVec(this.vx,this.vy,desiredSpeed);
        this.vx=vLim.x; this.vy=vLim.y;

        const { minX, maxX, minY, maxY } = engine.getBounds();
        this.x = clamp(this.x + this.vx*dt, minX, maxX);
        this.y = clamp(this.y + this.vy*dt, minY, maxY);

        if (now > this._faceLockUntil){
          if (this.vx > 0.25) { this.facing = 1; this._faceLockUntil = now + 120; }
          else if (this.vx < -0.25){ this.facing = -1; this._faceLockUntil = now + 120; }
        }

        const speedNow = Math.hypot(this.vx, this.vy);
        this.walkPhase += dt * (10.0 + speedNow * 1.8);

        const nowMs = Date.now();
        this.trail.add(this.x, this.y, speedNow, nowMs);
        this.trail.prune(nowMs, speedNow);
      }

      draw(ctx, tr){
        const sp = Math.hypot(this.vx, this.vy);
        this.trail.draw(ctx, tr, this.trailHue);

        const { toScreen, cellSizeX, cellSizeY } = tr;
        const pos = toScreen(this.x, this.y);

        const sizeW = cellSizeX * 2.55;
        const sizeH = cellSizeY * 2.55;

        const bob = Math.sin(this.walkPhase) * sizeH * (0.07 + 0.03*clamp(sp/18,0,1));
        const lean = clamp(this.vx / (this.maxSpeed || 1), -1, 1) * 0.24;

        ctx.save();
        ctx.translate(pos.x, pos.y + bob);
        ctx.rotate(lean);
        ctx.scale(this.facing, 1);

        if (Assets.goblin){
          ctx.drawImage(Assets.goblin, -sizeW/2, -sizeH/2, sizeW, sizeH);
        } else {
          ctx.fillStyle = '#6c3';
          ctx.fillRect(-sizeW/2, -sizeH/2, sizeW, sizeH);
        }
        ctx.restore();

        ctx.save();
        ctx.translate(pos.x, pos.y + bob);

        const labelW = sizeW * 1.85, labelH = sizeH * 0.42;
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.fillRect(-labelW/2, sizeH*0.62, labelW, labelH);

        ctx.strokeStyle = this.color;
        ctx.strokeRect(-labelW/2, sizeH*0.62, labelW, labelH);

        ctx.fillStyle = '#eef4ff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '12px sans-serif';
        ctx.fillText(this.owner || 'goblin', 0, sizeH*0.62 + labelH/2);
        ctx.restore();
      }
    }

    function colorByIndex(i){
      const palette = ['#facc15','#38bdf8','#22c55e','#f97316','#a855f7','#ec4899','#e11d48'];
      return palette[i % palette.length];
    }

    // ------------------------------------------------------------
    // ENGINE
    // ------------------------------------------------------------
    class GameEngine {
      constructor(canvas){
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.drop = null;              // normalized drop
        this.dropFx = State.drop.fx;   // reference
        this._shake = { x:0, y:0 };    // camera shake
        this._bindPointer = this._bindPointer.bind(this);
        this._bindPointer();

        this.world = { width: CONFIG.worldCols, height: CONFIG.worldRows };

        this.transform = {
          cellSizeX: 16,
          cellSizeY: 16,
          offsetX: 0,
          offsetY: 0,
          canvasWidth: canvas.width,
          canvasHeight: canvas.height,
          toScreen: (x,y)=>({x,y})
        };

        this.running = false;
        this.lastTs = performance.now();

        this.goblinById = new Map();
        this.goblins = this.goblinById;

        this.handleResize = this.handleResize.bind(this);
        window.addEventListener('resize', this.handleResize, { passive:true });
        this.handleResize();
      }
      
      _bindPointer(){
        const c = this.canvas;
        if (!c) return;
      
        c.addEventListener('pointerdown', (e)=>{
          if (!this.drop) return;
          if (State.drop.claimBusy) return;
      
          // se scaduta ‚Üí ignora
          const left = dropTimeLeftMs(this.drop);
          if (left != null && left <= 0) return;
      
          // hit test in world cells
          const rect = c.getBoundingClientRect();
          const sx = (e.clientX - rect.left);
          const sy = (e.clientY - rect.top);
          const w = this.screenToWorld(sx, sy);
          if (!w) return;
      
          const dx = (w.x - this.drop.world.x);
          const dy = (w.y - this.drop.world.y);
          const r  = (CONFIG.drop?.clickRadiusCells || 1.35);
          if ((dx*dx + dy*dy) <= r*r) {
            // trigger claim
            claimActiveDrop();
          }
        }, { passive:true });
      }

      screenToWorld(sx, sy){
        const tr = this.transform;
        const x = (sx - tr.offsetX) / Math.max(1e-6, tr.cellSizeX);
        const y = (sy - tr.offsetY) / Math.max(1e-6, tr.cellSizeY);
        return { x, y };
      }

      setDrop(drop){
        this.drop = drop || null;
      }

      destroy(){
        this.stop();
        window.removeEventListener('resize', this.handleResize);
      }

      getBounds(){
        return { minX:1, minY:1, maxX:this.world.width-2, maxY:this.world.height-2 };
      }

      handleResize(){
        const root = document.getElementById('canvas-wrap') || document.getElementById('app-root');
        const rect = root.getBoundingClientRect();

        const containerW = Math.max(320, Math.floor(rect.width));
        const maxH = Math.max(220, Math.floor((window.innerHeight || 800) * (State.overlay ? 0.92 : 0.50)));

        const targetW = containerW;
        const targetH = maxH;

        const dpr = State.dpr;
        this.canvas.width  = Math.round(targetW * dpr);
        this.canvas.height = Math.round(targetH * dpr);
        this.canvas.style.width  = targetW + 'px';
        this.canvas.style.height = targetH + 'px';

        const ctx = this.ctx;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        ctx.imageSmoothingEnabled = true;

        const padX = 8, padY = 8;
        const availW = Math.max(50, targetW - padX*2);
        const availH = Math.max(50, targetH - padY*2);

        const worldW = this.world.width, worldH = this.world.height;
        const cellSizeX = availW / worldW;
        const cellSizeY = availH / worldH;

        const areaW = worldW * cellSizeX;
        const areaH = worldH * cellSizeY;
        const offsetX = Math.floor((targetW - areaW) / 2);
        const offsetY = Math.floor((targetH - areaH) / 2);

        this.transform = {
          cellSizeX, cellSizeY,
          offsetX, offsetY,
          canvasWidth: targetW,
          canvasHeight: targetH,
          toScreen: (x, y) => ({ x: offsetX + x * cellSizeX, y: offsetY + y * cellSizeY })
        };
      }

      clear(){
        this.ctx.save();
        this.ctx.setTransform(1,0,0,1,0,0);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.restore();
      }

      drawBackground(){
        const ctx = this.ctx;
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.restore();

        const { cellSizeX, cellSizeY, offsetX, offsetY } = this.transform;
        const areaW = this.world.width  * cellSizeX;
        const areaH = this.world.height * cellSizeY;

        ctx.save();
        ctx.translate(offsetX, offsetY);

        if (Assets.bg){
          ctx.globalAlpha = 1.0;
          ctx.drawImage(Assets.bg, 0, 0, Assets.bg.width, Assets.bg.height, 0, 0, areaW, areaH);
        } else {
          ctx.fillStyle = '#111';
          ctx.fillRect(0, 0, areaW, areaH);
        }

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let x = 0; x <= this.world.width; x++){
          const px = Math.round(x * cellSizeX) + 0.5;
          ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, areaH); ctx.stroke();
        }
        for (let y = 0; y <= this.world.height; y++){
          const py = Math.round(y * cellSizeY) + 0.5;
          ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(areaW, py); ctx.stroke();
        }

        ctx.restore();
      }

      start(){
        if (this.running) return;
        this.running = true;
        this.lastTs = performance.now();
        const loop = (ts)=>{
          if (!this.running) return;
          this.tick(ts || performance.now());
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }

      stop(){ this.running = false; }

      tick(ts){
        const dtMs = ts - this.lastTs;
        this.lastTs = ts;
        const dt = Math.min(0.05, Math.max(0.001, dtMs/1000));
        this.update(dt);
        this.draw();
      }

      update(dt){
        for (const g of this.goblinById.values()){
          g.update(dt, this);
        }
      }

      drawDropHud(ctx, x, y, size, leftMs){
        const total = (State.drop.current?.expiresAtMs && State.drop.current?.spawnedAtMs)
          ? (State.drop.current.expiresAtMs - State.drop.current.spawnedAtMs)
          : (CONFIG.drop.maxLifeFallbackMs || 90_000);
      
        const t = total > 0 ? clamp(leftMs / total, 0, 1) : 0;
      
        // ring
        ctx.save();
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(56,189,248,0.75)';
        ctx.beginPath();
        ctx.arc(x, y, size*0.92, -Math.PI/2, -Math.PI/2 + Math.PI*2*t);
        ctx.stroke();
        ctx.restore();
      
        // hint text
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.font = '12px sans-serif';
        ctx.fillStyle = 'rgba(226,232,240,0.95)';
        ctx.fillText('CLICK TO CLAIM', x, y + size*0.72);
        ctx.restore();
      }

      updateDropParticles(ctx, x, y, size){
        const fx = State.drop.fx;
        if (!fx) return;
      
        // spawn particles gradually while visible
        if (fx.phase === 'visible' && fx.particles.length < 120 && Math.random() < 0.55) {
          fx.particles.push({
            x: x + (Math.random()*2-1)*size*0.4,
            y: y + (Math.random()*2-1)*size*0.4,
            vx: (Math.random()*2-1)*0.35,
            vy: -Math.random()*0.55 - 0.15,
            life: 1.0,
            r: 1 + Math.random()*2.5
          });
        }
      
        // update/draw
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const p of fx.particles){
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.015;
          p.vy  -= 0.01;
          ctx.globalAlpha = Math.max(0, p.life) * 0.65;
          ctx.fillStyle = 'rgba(56,189,248,1)';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fill();
        }
        fx.particles = fx.particles.filter(p => p.life > 0);
        ctx.restore();
      }


drawDropChest(ctx){
  const d = this.drop;
  if (!d) return;

  // auto-expire visuals (client-side)
  const left = dropTimeLeftMs(d);
  if (left != null && left <= 0) {
    if (State.drop.fx.phase !== 'expired' && State.drop.fx.phase !== 'idle'){
      State.drop.fx.phase = 'expired';
      State.drop.fx.doneAtMs = performance.now();
      pushCanvasMsg('‚åõ Chest expired.');
    }
    return;
  }

  const tr = this.transform;
  const p  = tr.toScreen(d.world.x, d.world.y);

  // sizing
  const size = Math.min(tr.cellSizeX, tr.cellSizeY) * 2.3;

  // pulse + rarity glow
  State.drop.fx.pulsePhase += 0.06;
  const pulse = 0.65 + 0.35*Math.sin(State.drop.fx.pulsePhase);

  // rarity color
  const rarity = (d.rarity || '').toLowerCase();
  const glow =
    rarity === 'mythic'    ? 'rgba(168,85,247,0.85)' :
    rarity === 'legendary' ? 'rgba(250,204,21,0.85)' :
    rarity === 'epic'      ? 'rgba(56,189,248,0.85)' :
    rarity === 'rare'      ? 'rgba(34,197,94,0.80)' :
                             'rgba(148,163,184,0.60)';

  // base glow ring
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.beginPath();
  ctx.arc(p.x, p.y, size*0.78, 0, Math.PI*2);
  ctx.fillStyle = glow;
  ctx.globalAlpha = 0.18 * pulse;
  ctx.fill();
  ctx.restore();

  // chest sprite (frame anim)
  ctx.save();

  const phase = State.drop.fx.phase || 'visible';

  // dissolve alpha + slight shrink
  let alpha = 1.0;
  if (phase === 'dissolve'){
    const t = clamp(
      (performance.now() - State.drop.fx.doneAtMs) / (CONFIG.drop.dissolveMs||650),
      0, 1
    );
    alpha = 1 - t;
  }
  ctx.globalAlpha = alpha;

  // opening / hologram / dissolve transforms
  let scale = 1.0;
  let lift  = 0;

  if (phase === 'dissolve'){
    const t = clamp(
      (performance.now() - State.drop.fx.doneAtMs) / (CONFIG.drop.dissolveMs||650),
      0, 1
    );
    scale = 1.0 - 0.12*t;
    lift  = -size*0.10*t;
  }

  if (phase === 'opening'){
    const t = clamp(
      (performance.now() - State.drop.fx.openAtMs) / (CONFIG.drop.openingMs||1100),
      0, 1
    );
    scale = 1.0 + 0.18*Math.sin(t*Math.PI);
    lift  = -size*0.18 * t;
  }

  // hologram scanlines (senza ‚Äúrompere‚Äù alpha globale)
  if (phase === 'hologram'){
    const t = clamp(
      (performance.now() - State.drop.fx.holoAtMs) / (CONFIG.drop.hologramMs||1200),
      0, 1
    );
    lift  = -size*0.22;
    scale = 1.08;

    ctx.save();
    ctx.globalAlpha = alpha * (0.25*(1 - t));
    ctx.fillStyle = 'rgba(56,189,248,0.8)';
    for (let i=0;i<8;i++){
      const yy = p.y - size*0.65 + i*(size*0.17);
      ctx.fillRect(p.x - size*0.55, yy, size*1.10, 2);
    }
    ctx.restore();
  }

  // draw sprite (fallback: rect)
  if (Assets.chest){
    // sprite sheet 4 frames horizontal: 512x128 => 4x (128x128)
    const frames = 4;
    const frameW = Math.floor(Assets.chest.width / frames);
    const frameH = Assets.chest.height;

    // ‚úÖ VARIANTE "pi√π bella": idle ping-pong 0-1-2-1
    let fi = 0;

    if (phase === 'visible' || phase === 'claiming') {
      const seq = [0, 1, 2, 1];
      fi = seq[Math.floor(performance.now() / 140) % seq.length];
    } else if (phase === 'opening') {
      // 0 -> 3 durante openingMs
      const t = clamp(
        (performance.now() - State.drop.fx.openAtMs) / (CONFIG.drop.openingMs||1100),
        0, 1
      );
      fi = Math.floor(t * (frames - 1));
    } else if (phase === 'hologram' || d.claimed) {
      // resta su frame "open"
      fi = frames - 1;
    } else if (phase === 'dissolve') {
      // mentre dissolve, resta aperta
      fi = frames - 1;
    }

    fi = clamp(fi, 0, frames - 1);

    ctx.translate(p.x, p.y + lift);
    ctx.scale(scale, scale);
    ctx.drawImage(
      Assets.chest,
      fi*frameW, 0, frameW, frameH,
      -size/2, -size/2, size, size
    );
  } else {
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(p.x - size/2, p.y - size/2, size, size);
  }

  ctx.restore();

  // timer ring + ‚ÄúCLICK‚Äù hint
  if (phase !== 'dissolve') {
    this.drawDropHud(ctx, p.x, p.y, size, left);
  }
  this.updateDropParticles(ctx, p.x, p.y, size);
}


      draw(){
        this.clear();
      
        // ‚úÖ NO camera shake
        this.drawBackground();
      
        // goblins
        for (const g of this.goblinById.values()){
          g.draw(this.ctx, this.transform);
        }
      
        // chest on top
        this.drawDropChest(this.ctx);
      }

      syncExpeditions(exps=[]){
        const seen = new Set();
        const { minX, maxX, minY, maxY } = this.getBounds();

        exps.forEach((exp, idx)=>{
          const owner = exp.wax_account || exp.owner || 'player';
          const expId = String(exp.expedition_id ?? exp.id ?? idx);
          seen.add(expId);

          let g = this.goblinById.get(expId);
          const color = colorByIndex(idx);

          if (!g){
            const gx = randRange(minX+1, maxX-1);
            const gy = randRange(minY+1, maxY-1);
            g = new GoblinEntity({ id: expId, owner, color, x: gx, y: gy });
            this.goblinById.set(expId, g);
          }

          g.owner = owner;
          g.color = color;

          const sr = toNumber(exp.seconds_remaining);
          if (sr > 0) {
            const snap = exp._snapAt || Date.now();
            g._endsAt = snap + sr*1000;
          } else {
            g._endsAt = getEndsAt(exp)?.getTime() || null;
          }
        });

        for (const [id] of this.goblinById){
          if (!seen.has(id)) this.goblinById.delete(id);
        }
      }
    }

    // ------------------------------------------------------------
    // PANELS
    // ------------------------------------------------------------
    const GlobalTimers = { tickId:null, rows:new Map() };

    function recalcMyExpeditionFlagAndUI(){
      const mine = (State.globalExpeditions || []).some(e => (e.wax_account || e.owner) === State.user.wax_account);
      State.runtime.expeditionInProgress = !!mine;
      updateActionButtonsUI();
      if (!mine) scheduleForecastIfReady();
    }

    function renderGlobalPanel(){
      const host = State.ui.globalList, label = State.ui.globalCount;
      if (!host || !label) return;

      host.innerHTML = '';
      GlobalTimers.rows.clear();

      const exps = State.globalExpeditions || [];
      label.textContent = String(exps.length);

      exps.forEach(exp=>{
        const owner = exp.wax_account || exp.owner || 'unknown';
        const count = exp.total_goblins ?? (Array.isArray(exp.goblin_ids) ? exp.goblin_ids.length : 0);

        const sr = fromSecondsRemaining(exp);
        const endsAt = sr ? sr.endsAt() : getEndsAt(exp);
        const leftMs = sr ? sr.leftMs() : getTimeLeftMs(exp);

        const row = document.createElement('div');
        row.setAttribute('role','group');
        row.style.display = 'grid';
        row.style.gridTemplateColumns = '1fr auto';
        row.style.gap = '8px';

        const left = document.createElement('div');
        left.innerHTML =
          `<strong>${safe(owner)}</strong> &middot; <span class="badge">Goblins: ${formatCompact(count)}</span>`;

        const right = document.createElement('div');
        right.style.textAlign = 'right';
        right.innerHTML =
          `<div style="font-weight:900">
             <span class="badge ok">‚è≥ <span data-eta>${leftMs!=null?fmtHMS(leftMs):'--:--:--'}</span></span>
           </div>
           <div style="font-size:12px;opacity:.85;margin-top:4px">
             ends <span data-end>${endsAt?timeHM(endsAt):'--:--'}</span>
           </div>`;

        row.appendChild(left);
        row.appendChild(right);
        host.appendChild(row);

        GlobalTimers.rows.set(row, {
          exp,
          etaEl: right.querySelector('[data-eta]'),
          endEl: right.querySelector('[data-end]'),
          sr,
        });
      });

      ensureGlobalTimers();
    }

    function renderRecentPanel(){
      const host = State.ui.recentList;
      if (!host) return;
      host.innerHTML = '';

      (State.recentExpeditions || []).forEach(item=>{
        const chips = item.chips ?? 0;
        const nfts  = item.nfts_count ?? 0;
        const tsVal = item.timestamp ?? item.time ?? item.created_at;
        const t = tsVal ? timeHM(tsVal) : '';
        const div = document.createElement('div');
        div.textContent = `${item.wax_account} ¬∑ ${t} ¬∑ +${formatCompact(chips)} CHIPS${nfts?` ¬∑ ${nfts} NFT`:''}`;
        host.appendChild(div);
      });
    }

    function ensureGlobalTimers(){
      if (GlobalTimers.tickId) cancelAnimationFrame(GlobalTimers.tickId);

      const tick = ()=>{
        const now = Date.now();

        for (const [row, meta] of GlobalTimers.rows){
          let leftMs = null, endAt = null;

          if (meta.sr){
            leftMs = meta.sr.leftMs(now);
            endAt  = meta.sr.endsAt();
          } else {
            leftMs = getTimeLeftMs(meta.exp, new Date(now));
            endAt  = getEndsAt(meta.exp);
          }

          if (leftMs == null){
            if (meta.etaEl) meta.etaEl.textContent = '--:--:--';
            continue;
          }
          if (leftMs <= 0){
            row.remove();
            GlobalTimers.rows.delete(row);

            const id = String(meta.exp.expedition_id ?? meta.exp.id ?? '');
            State.globalExpeditions = State.globalExpeditions.filter(e => String(e.expedition_id ?? e.id) !== id);
            if (State.ui.globalCount) State.ui.globalCount.textContent = String(State.globalExpeditions.length);
            if (State.engine) State.engine.goblinById.delete(id);

            recalcMyExpeditionFlagAndUI();
            continue;
          }

          if (meta.etaEl) meta.etaEl.textContent = fmtHMS(leftMs);
          if (meta.endEl && endAt) meta.endEl.textContent = timeHM(endAt);
        }

        GlobalTimers.tickId = requestAnimationFrame(tick);
      };

      GlobalTimers.tickId = requestAnimationFrame(tick);
    }

    // ------------------------------------------------------------
    // TICKER
    // ------------------------------------------------------------
function updateTicker(){
  const el = State.ui.ticker;
  if (!el) return;

  const list = State.globalLogEvents || [];
  const i = (State.runtime?.ticker?.idx || 0);
  const ev = list.length ? list[i % list.length] : null;


  // se abbiamo un messaggio "local" appena claimato, lo preferiamo per qualche secondo
  if (State.drop && State.drop.lastLocalTickerHtml && State.drop.lastLocalTickerUntilMs) {
    if (Date.now() < State.drop.lastLocalTickerUntilMs) {
      el.innerHTML = State.drop.lastLocalTickerHtml;
      return;
    }
  }

  if (ev){
    const when = timeHM(ev.timestamp);
    const account = safe(ev.wax_account || 'unknown');
    const nominal = formatMinutesShort(ev.nominal_minutes || 0);
    const effective = formatEffectiveDurationShort(ev.effective_seconds || 0);
    const goblins = ev.goblins_count != null ? Number(ev.goblins_count) : null;

    // Expeditions
    if (ev.event_type === 'started'){
      el.innerHTML =
        `<span class="ticker-time">[${when}]</span> ` +
        `<strong>${account}</strong> started ` +
        `<span class="ticker-tag">${nominal}</span> expedition ` +
        (goblins ? `<span class="ticker-extra">(${goblins} goblins)</span> ` : '') +
        `<span class="ticker-eff">eff: ${effective}</span>`;
      return;
    }

    if (ev.event_type === 'completed'){
      const chips = ev.chips != null ? formatCompact(ev.chips) : '0';
      const nftPart = ev.nfts_count ? ` ¬∑ ${ev.nfts_count} NFT` : '';
      el.innerHTML =
        `<span class="ticker-time">[${when}]</span> ` +
        `<strong>${account}</strong> completed ` +
        `<span class="ticker-tag">${nominal}</span> expedition ` +
        `<span class="ticker-eff">eff: ${effective}</span> ` +
        `‚Üí <span class="ticker-rew">+${chips} CHIPS${nftPart}</span>`;
      return;
    }

    // DROPS
    if (ev.event_type === 'drop' || ev.event_type === 'drop_claimed'){
      const st = String(ev.status || '').toLowerCase();
      const by = safe(ev.claimed_by || ev.wax_account || 'someone');

      if (st === 'spawned' && ev.event_type === 'drop'){
        el.innerHTML =
          `<span class="ticker-time">[${when}]</span> ` +
          `‚ú® <strong>A chest has spawned!</strong> ` +
          `<span class="ticker-extra">Click it on the map to claim.</span>` +
          `<span class="ticker-eff">Use Twitch chat commands to spawn more.</span>`;
        return;
      }

      if (st === 'claimed' || ev.event_type === 'drop_claimed'){
        const by = safe(ev.claimed_by || ev.wax_account || 'someone');
      
        const amtRaw = (ev.reward_amount != null) ? ev.reward_amount : null;
        const sym = safe(ev.reward_symbol || 'CHIPS');
        const txid = ev.reward_txid ? String(ev.reward_txid) : '';
      
        // amt potrebbe arrivare string/number
        const amtNum = (amtRaw != null) ? Number(amtRaw) : NaN;
        const hasAmt = Number.isFinite(amtNum);
      
        const rewardHtml = hasAmt
          ? `‚Üí <span class="ticker-rew">+${formatCompact(amtNum)} ${sym}</span>`
          : '';
      
        const txHtml = txid
          ? ` <span class="ticker-extra" title="${safe(txid)}">tx: ${safe(txid.slice(0, 10))}‚Ä¶</span>`
          : '';
      
        el.innerHTML =
          `<span class="ticker-time">[${when}]</span> ` +
          `üè¥‚Äç‚ò†Ô∏è <strong>${by}</strong> claimed a chest ` +
          rewardHtml +
          txHtml +
          `<span class="ticker-eff"> Use Twitch chat commands to spawn more chests and win prizes.</span>`;
        return;
      }

      if (st === 'expired'){
        el.innerHTML =
          `<span class="ticker-time">[${when}]</span> ` +
          `‚åõ <strong>A chest expired.</strong> ` +
          `<span class="ticker-eff">Stay active in chat‚Äînew chests can spawn anytime.</span>`;
        return;
      }
    }

    el.textContent = `[${when}] ${account}`;
    return;
  }

  const latest = State.recentExpeditions?.[0];
  if (latest){
    const when = timeHM(latest.timestamp || latest.created_at);
    const account = safe(latest.wax_account || 'unknown');
    const chips = formatCompact(latest.chips);
    const nftPart = latest.nfts_count ? ` ¬∑ ${latest.nfts_count} NFT` : '';
    el.innerHTML =
      `<span class="ticker-time">[${when}]</span> ` +
      `<strong>${account}</strong> finished: ` +
      `<span class="ticker-rew">+${chips} CHIPS${nftPart}</span>`;
    return;
  }

  el.textContent = 'Waiting for events‚Ä¶';
}


    // ------------------------------------------------------------
    // TABS / LAYOUT / OVERLAY
    // ------------------------------------------------------------
    function setTabsBehavior(){
      const tabs = document.getElementById('tabs');
      const my = document.getElementById('tab-my');
      const staking = document.getElementById('tab-staking');
      const global = document.getElementById('tab-global');
      const recent = document.getElementById('tab-recent');

      function activate(panelName){
        my.hidden = panelName !== 'tab-my';
        if (staking) staking.hidden = panelName !== 'tab-staking';
        global.hidden = panelName !== 'tab-global';
        recent.hidden = panelName !== 'tab-recent';
        tabs.querySelectorAll('button[role="tab"]').forEach(b=>{
          b.setAttribute('aria-selected', String(b.dataset.panel === panelName));
          b.tabIndex = (b.dataset.panel === panelName) ? 0 : -1;
        });

        if (panelName === 'tab-global') renderGlobalPanel();
        if (panelName === 'tab-recent') renderRecentPanel();
        if (panelName === 'tab-staking') ensureStakingReportLoaded();
      }

      tabs.querySelectorAll('button[role="tab"]').forEach(btn=>{
        btn.addEventListener('click', ()=> activate(btn.dataset.panel));
      });

      activate('tab-my');
    }

    function applyOverlayMode(){
      if (!State.overlay) return;

      const hideIds = [
        'panels','app-footer','news-banner','action-bar','legend','subtitle'
      ];
      hideIds.forEach(id=>{
        const el = document.getElementById(id);
        if (el) el.hidden = true;
      });

      const header = document.getElementById('app-header');
      if (header) header.style.padding = '8px';

      const wrap = document.getElementById('canvas-wrap');
      if (wrap){
        wrap.style.width = '100%';
        wrap.style.maxWidth = '100%';
        wrap.style.height = Math.floor((window.innerHeight||800) * 0.95) + 'px';
      }

      const h2 = document.querySelector('#game-area > h2');
      if (h2) h2.hidden = true;
    }

    function mountBuilderControls(){
      const host = document.getElementById('builder-controls');
      const duration = document.getElementById('duration-switch');
      const capLine  = document.getElementById('cap-line');
      const actions  = document.getElementById('action-buttons');
      const hintBox  = document.getElementById('action-hint');
      if (!host || !duration || !capLine || !actions) return;

      host.innerHTML = '';

      const row1 = document.createElement('div');
      const row2 = document.createElement('div');

      row1.style.cssText = 'display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:space-between;';
      row2.style.cssText = 'display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:flex-start;margin-top:8px;';

      duration.style.cssText = 'display:flex;gap:8px;align-items:center;flex-wrap:wrap;';

      const sel  = document.getElementById('sel-duration');
      const hint = document.getElementById('duration-hint');
      if (sel){
        sel.style.maxWidth = '160px';
        sel.style.width = 'auto';
        sel.style.padding = '4px 8px';
        sel.style.borderRadius = '6px';
        sel.style.font = 'inherit';
        sel.style.lineHeight = '1.2';
        sel.style.boxSizing = 'border-box';
        sel.style.appearance = 'menulist';
      }
      if (hint){
        hint.style.display = 'block';
        hint.style.opacity = '.85';
        hint.style.marginLeft = '0';
      }

      [duration, sel, capLine, actions].filter(Boolean).forEach(el=>{
        el.removeAttribute('hidden');
        el.style.visibility = 'visible';
        el.style.opacity = '1';
        if (getComputedStyle(el).display === 'none'){
          el.style.display = (el === sel ? 'inline-block' : 'flex');
        }
      });

      row1.appendChild(duration);
      row1.appendChild(capLine);
      row2.appendChild(actions);

      host.appendChild(row1);
      host.appendChild(row2);

      if (hintBox){
        hintBox.style.cssText = 'margin-top:8px;opacity:.85;font-size:12px;line-height:1.35;';
      }
    }

    // ------------------------------------------------------------
    // BUILDER RENDER
    // ------------------------------------------------------------
    function hydrateGoblinBuilder(){
      const listHost = State.ui.listHost;
      if (!listHost) return;

      if (!State.nftsLoaded){
        listHost.innerHTML = `<p class="builder-disabled-hint">Load your goblins with the button above to see them here.</p>`;
        if (State.ui.summaryCount) State.ui.summaryCount.textContent = 'Selected goblins: 0';
        if (State.ui.summaryStats) State.ui.summaryStats.textContent = 'R: 0 ¬∑ L: 0 ¬∑ S: 0 ¬∑ A: 0';
        updateActionButtonsUI();
        return;
      }

      const q = (State.ui.fltSearch?.value || '').trim().toLowerCase();
      const rarity = State.ui.fltRarity?.value || '';
      const minPower = Number(State.ui.fltPower?.value || 0);

      function applyFilters(arr){
        return arr.filter(g=>{
          const name = String(g.name || '').toLowerCase();
          const okQ = !q || name.includes(q) || String(g.asset_id).includes(q);
          const okR = !rarity || String(g.rarity || '').toLowerCase() === rarity.toLowerCase();
          const okP = (g.daily_power_num || 0) >= minPower;
          return okQ && okR && okP;
        });
      }

      const filtered = applyFilters(State.goblinsUser);
      const cap = getSendCap();
      const COLLAPSED = 30;

      const showAll = listHost.getAttribute('data-show-all') === '1';
      const visible = showAll ? filtered : filtered.slice(0, COLLAPSED);

      listHost.innerHTML = '';

      visible.forEach(g=>{
        const tired = isGoblinTired(g);
        const sel = State.selectedGoblinIds.has(g.asset_id);
      
        const card = document.createElement('button');
        card.type = 'button';
        card.setAttribute('role','checkbox');
        card.setAttribute('aria-checked', String(sel));
        card.dataset.id = g.asset_id;
        card.title = tired
          ? 'This goblin has insufficient daily power for the current duration.'
          : 'Click to select/deselect';
        card.tabIndex = tired ? -1 : 0;
      
        card.classList.toggle('card-tired', !!tired);
        card.classList.toggle('card-okpower', !tired && sel);
      
        card.addEventListener('keydown', (e)=>{
          if (tired) return;
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); card.click(); }
        });
      
        card.textContent =
          `#${g.asset_id} ¬∑ ${g.name} ¬∑ ${g.rarity || 'Unknown'} ¬∑ Power ${g.daily_power_num}`;
      
        if (!tired){
          card.addEventListener('click', ()=>{
            if (State.selectedGoblinIds.has(g.asset_id)) State.selectedGoblinIds.delete(g.asset_id);
            else if (State.selectedGoblinIds.size < cap) State.selectedGoblinIds.add(g.asset_id);
            hydrateGoblinBuilder();
          });
        } else {
          card.disabled = true;
        }
      
        listHost.appendChild(card);
      });

      if (State.ui.btnToggleMore){
        const hasOverflow = filtered.length > COLLAPSED;
        State.ui.btnToggleMore.hidden = !hasOverflow;
        State.ui.btnToggleMore.textContent = showAll ? 'View less' : `View more (${filtered.length - visible.length} hidden)`;
        State.ui.btnToggleMore.onclick = ()=>{
          listHost.setAttribute('data-show-all', showAll ? '0' : '1');
          hydrateGoblinBuilder();
        };
      }

      const selArr = State.goblinsUser.filter(g => State.selectedGoblinIds.has(g.asset_id));
      const sums = selArr.reduce((acc,g)=>{
        const nft = State.nftIndex.get(String(g.asset_id));
        acc.res += getStatFromNFT(nft,'resistance');
        acc.loot+= getStatFromNFT(nft,'loot_hungry');
        acc.spd += getStatFromNFT(nft,'speed');
        acc.acc += getStatFromNFT(nft,'accuracy');
        return acc;
      }, {res:0, loot:0, spd:0, acc:0});

      const selected = selArr.length;
      if (State.ui.summaryCount) {
        const over = selected > cap;
        const tiredCount = selArr.filter(isGoblinTired).length;
        State.ui.summaryCount.innerHTML =
          `Selected goblins: <b>${selected}</b> / <b>${cap}</b>` +
          (over ? ` <span class="badge err" title="You are above your cap. Remove some goblins.">Over cap</span>` : '') +
          (tiredCount ? ` <span class="badge warn" title="Some goblins are below the minimum daily power threshold.">${tiredCount} tired</span>` : '');
      }
      if (State.ui.summaryStats){
        State.ui.summaryStats.textContent =
          `R: ${formatCompact(sums.res)} ¬∑ L: ${formatCompact(sums.loot)} ¬∑ S: ${formatCompact(sums.spd)} ¬∑ A: ${formatCompact(sums.acc)}`;
      }

      updateActionButtonsUI();
      scheduleForecastIfReady();
    }

    function wireBuilderUI(){
      const fSearch = State.ui.fltSearch;
      const fRarity = State.ui.fltRarity;
      const fPower  = State.ui.fltPower;
      const fLabel  = State.ui.fltPowerLabel;

      if (fSearch) fSearch.addEventListener('input', hydrateGoblinBuilder);
      if (fRarity) fRarity.addEventListener('change', hydrateGoblinBuilder);
      if (fPower){
        fPower.addEventListener('input', ()=>{
          if (fLabel) fLabel.textContent = String(fPower.value||0);
          hydrateGoblinBuilder();
        });
      }

      if (State.ui.btnFirst) State.ui.btnFirst.onclick = ()=>{
        if (!State.nftsLoaded) return;
        State.selectedGoblinIds.clear();
        const cap = getSendCap();
        const eligible = State.goblinsUser.filter(g => !isGoblinTired(g));
        eligible.slice(0, cap).forEach(g=> State.selectedGoblinIds.add(g.asset_id));
        if (State.selectedGoblinIds.size === 0 && State.goblinsUser.length){
          State.goblinsUser.slice(0, cap).forEach(g=> State.selectedGoblinIds.add(g.asset_id));
        }
        hydrateGoblinBuilder();
      };

      if (State.ui.btnBest) State.ui.btnBest.onclick = ()=>{
        if (!State.nftsLoaded) return;
        State.selectedGoblinIds.clear();
        const cap = getSendCap();
        const eligible = [...State.goblinsUser]
          .filter(g => !isGoblinTired(g))
          .sort((a,b)=>(b.daily_power_num||0)-(a.daily_power_num||0));
        eligible.slice(0, cap).forEach(g=> State.selectedGoblinIds.add(g.asset_id));
        if (State.selectedGoblinIds.size === 0){
          [...State.goblinsUser]
            .sort((a,b)=>(b.daily_power_num||0)-(a.daily_power_num||0))
            .slice(0, cap)
            .forEach(g=> State.selectedGoblinIds.add(g.asset_id));
        }
        hydrateGoblinBuilder();
      };

      if (State.ui.btnClear) State.ui.btnClear.onclick = ()=>{
        State.selectedGoblinIds.clear();
        hydrateGoblinBuilder();
      };
    }

    // ------------------------------------------------------------
    // DATA: USER NFTs (manual fetch via button)
    // ------------------------------------------------------------
    async function fetchUserNFTs() {
      // Allinea userData da localStorage / window
      syncUserFromStorage();
    
      const statusEl = document.getElementById('my-status');
      const btn = State.ui.btnLoadGoblins;
    
      // Stato UI: bottone e messaggio
      if (btn && !btn.dataset.loading) {
        btn.disabled = true;
        btn.dataset.loading = '1';
        btn.textContent = '‚è≥ Loading goblins‚Ä¶';
      }
      if (statusEl) {
        statusEl.textContent = 'Loading goblins from the API‚Ä¶';
      }
    
      // Controllo auth lato FE
      try {
        assertAuth();
      } catch {
        if (statusEl) {
          statusEl.textContent = 'Not authenticated. Connect your account first.';
        }
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'üîÑ Load / Refresh goblins';
          delete btn.dataset.loading;
        }
        return;
      }
    
      // Chiamata API
      const res = await Api.post(
        '/2user_nfts',
        {
          wax_account: State.user.wax_account,
          user_id: State.user.user_id,
          usx_token: State.user.usx_token
        },
        CONFIG.userNftsTimeoutMs
      );
    
      if (!res.ok || !res.data) {
        toast('Could not load goblins');
        if (statusEl) {
          const msg = res.data?.error || 'Could not load goblins right now.';
          statusEl.textContent = msg;
        }
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'üîÑ Load / Refresh goblins';
          delete btn.dataset.loading;
        }
        return;
      }
    
      const payload = res.data || {};
    
      // nfts √® sempre dentro payload.nfts col nuovo backend
      const arr = Array.isArray(payload.nfts)
        ? payload.nfts
        // fallback ultra difensivo se in futuro tornasse un array ‚Äúnudo‚Äù
        : (Array.isArray(payload) ? payload : []);
    
      State.nftsLoaded = true;
      State.nftIndex.clear();
      State.selectedGoblinIds.clear();
    
      // Normalizzazione goblin lato FE
      const goblins = arr.map(n => {
        const id = String(n.asset_id || n.assetId || n.id);
        State.nftIndex.set(id, n);
    
        const dailyPower = toNumber(
          n.daily_power ??
          n['daily-power'] ??
          n.power ??
          n.strength ??
          n.stats?.power
        ) || 0;
    
        return {
          asset_id: id,
          name: n.name || n.title || `Goblin #${id}`,
          rarity: n.rarity || n.tier || '',
          daily_power_num: dailyPower
        };
      });
    
      State.goblinsUser = goblins;
    
      // Reinforcement per il cap
      const reinfRaw =
        toNumber(payload.reinforcement_count) ||
        toNumber(payload.troop_reinforcement) ||
        0;
      State.expedition.reinforcementCount = clamp(reinfRaw, 0, 40);
    
      // Messaggio di stato base
      if (statusEl) {
        statusEl.textContent = `Loaded ${goblins.length} goblins for ${State.user.wax_account}.`;
      }
    
      // ---- NUOVA PARTE: uso dei totali/medie/rarity_counts dal backend ----
      const statsSummary = payload.stats_summary || null;
      // Questa funzione deve usare:
      //   statsSummary.count_total
      //   statsSummary.totals.{loot_hungry,speed,resistance,accuracy}
      //   statsSummary.averages.{...}
      //   statsSummary.rarity_counts.{mythic,legendary,epic,rare,common,other}
      // e aggiornare il pannello riassuntivo UX
      if (typeof updateGoblinGlobalStats === 'function') {
        updateGoblinGlobalStats(statsSummary, goblins.length);
      }
    
      if (State.ui.goblinStatUpdated) {
        State.ui.goblinStatUpdated.textContent = 'Updated at ' + timeHM(new Date());
      }
      // ---------------------------------------------------------------------
    
      // Rinfresca resto della UI builder
      updateCapUI();
      setBuilderEnabled(true);
      hydrateGoblinBuilder();
      updateActionButtonsUI();
      scheduleForecastIfReady();
    
      if (btn) {
        btn.disabled = false;
        btn.textContent = 'üîÑ Refresh goblins';
        delete btn.dataset.loading;
      }
    }


    // ------------------------------------------------------------
    // COMMAND: START EXPEDITION
    // ------------------------------------------------------------
    async function sendExpedition(){
      if (!State.nftsLoaded){
        toast('Load your goblins first.');
        return;
      }
      // Se sei nel tab Simulator, ricordiamo che il run √® sempre sui goblin reali
      if (State.runtime.forecastMode === 'sim'){
        toast('Simulator tab active: expedition will still use your real selected goblins.');
      }

      const idsAll = Array.from(State.selectedGoblinIds);
      
      // Se il forecast ha marcato dei goblin come "tired", li escludiamo dallo start
      const tiredSet = State.runtime.forecastInsufficientIds || new Set();
      const ids = idsAll.filter(id => !tiredSet.has(String(id)));
      
      const skipped = idsAll.length - ids.length;
      
      if (!ids.length){
        toast(skipped
          ? 'All selected goblins are tired for this duration. Remove tired goblins or choose a shorter duration.'
          : 'Select at least one goblin');
        return;
      }
      
      if (skipped > 0){
        toast(`Skipping ${skipped} tired goblin${skipped>1?'s':''}. Starting with ${ids.length}.`);
      }

      const cap = getSendCap();
      if (ids.length > cap){
        toast(`You selected ${ids.length} goblins but your cap is ${cap}.`);
        return;
      }

      syncUserFromStorage();
      try { assertAuth(); } catch { toast('Please log in first'); return; }

      const durationMinutes = State.expedition?.durationMinutes || 30;

      const res = await Api.post('/2start_expedition', {
        wax_account: State.user.wax_account,
        user_id: State.user.user_id,
        usx_token: State.user.usx_token,
        asset_ids: ids,
        duration_minutes: durationMinutes
      }, 20000);

      if (!res.ok){
        if (res.status === 409 && res.data?.seconds_remaining){
          const left = fmtHMS(res.data.seconds_remaining*1000);
          toast(`You already have an expedition in progress. Ends in ${left}.`);
        } else {
          toast('Could not start expedition');
        }
        return;
      }

      const durSec = toNumber(res.data?.duration_seconds) || durationMinutes*60;
      const endAt = new Date(Date.now() + durSec*1000);

      toast(`‚õèÔ∏è Expedition started! ${ids.length}/${cap} goblins ¬∑ ETA ${fmtHMS(durSec*1000)} (ends ${timeHM(endAt)})`);
      pushCanvasMsg(`‚õèÔ∏è ${State.user.wax_account} started an expedition with ${ids.length}/${cap} goblins ¬∑ ETA ${fmtHMS(durSec*1000)}`);
      State.runtime.expeditionInProgress = true;
      State.runtime.forecastPowerByAsset = {};
      State.runtime.forecastInsufficientIds = new Set();
      const rf = document.getElementById('run-forecast');
      if (rf){
        rf.replaceChildren();
        rf.hidden = true;
      }

      updateActionButtonsUI();
      fetchGlobalSnapshot();
    }

async function claimActiveDrop(){
  const drop = State.drop.current;
  if (!drop) return;

  const left = dropTimeLeftMs(drop);
  if (left != null && left <= 0) {
    toast('Chest expired.');
    return;
  }
  if (State.drop.claimBusy) return;

  syncUserFromStorage();
  try { assertAuth(); } catch { toast('Please log in first'); return; }

  State.drop.claimBusy = true;
  State.drop.fx.phase = 'claiming';
  State.drop.fx.shakePower = 0.95;

  pushCanvasMsg('üß§ Claiming chest‚Ä¶');

  const body = {
    wax_account: State.user.wax_account,
    user_id: State.user.user_id,
    usx_token: State.user.usx_token,
    drop_id: drop.drop_id,
    event_id: drop.event_id
  };

  const res = await Api.post(CLAIM_DROP_API_PATH, body, 15000).catch(()=>({ok:false, status:0, data:null}));

  State.drop.claimBusy = false;

  // backend: se expired -> 409 con {"ok":false,"error":"expired"} (o simili)
  if (!res || !res.data) {
    toast('Claim failed.');
    State.drop.fx.phase = 'visible';
    State.drop.fx.shakePower = 0.45;
    return;
  }

  // Se non ok o 409 => qualcuno ha gi√† claimato / scaduto
  if (!res.ok || res.status === 409 || res.data.ok === false) {
    const by = (res.data && (res.data.claimed_by || res.data.claimedBy)) || 'someone';
    const err = res.data?.error;

    if (err === 'expired') {
      toast('Chest expired.');
      pushCanvasMsg('‚åõ Chest expired.');
      State.drop.fx.phase = 'expired';
      State.drop.fx.doneAtMs = performance.now();
      State.drop.fx.shakePower = 0.10;
      return;
    }

    toast(`Too late ‚Äî claimed by ${by}.`);
    pushCanvasMsg(`üí® Chest claimed by ${by}.`);
    State.drop.fx.phase = 'done';
    State.drop.fx.doneAtMs = performance.now();
    State.drop.fx.shakePower = 0.10;
    return;
  }

  // SUCCESS (your backend /2drop_claim):
  // res.data.reward.amount (string), res.data.reward.symbol, res.data.reward.tx_id
  const claimedBy = res.data?.claimed_by || State.user.wax_account;
  const amtStr = res.data?.reward?.amount;
  const sym = res.data?.reward?.symbol || 'CHIPS';
  const amtNum = (amtStr != null) ? Number(amtStr) : null;

  if (amtNum != null && Number.isFinite(amtNum)) {
    toast(`üéâ You found +${formatCompact(amtNum)} ${sym} in the chest!`);
  } else {
    toast('üéâ Chest claimed!');
  }

  // ticker local bello (per qualche secondo), include amount perch√© arriva da /2drop_claim
  const when = timeHM(new Date());
  State.drop.lastLocalTickerHtml =
    `<span class="ticker-time">[${when}]</span> ` +
    `üè¥‚Äç‚ò†Ô∏è <strong>${safe(claimedBy)}</strong> claimed a chest ` +
    (amtNum != null && Number.isFinite(amtNum)
      ? `‚Üí <span class="ticker-rew">+${formatCompact(amtNum)} ${safe(sym)}</span>`
      : '') +
    `<span class="ticker-eff">Use Twitch chat commands to spawn more chests and win prizes.</span>`;
  State.drop.lastLocalTickerUntilMs = Date.now() + 12_000;
  updateTicker();

// ‚úÖ NON sovrascrivere con res.data (manca x/y), tieni posizione e marca claimed
if (State.drop.current) {
  State.drop.current.claimed = true;
  State.drop.current.status = 'claimed';
  State.drop.current.claimedBy = claimedBy;
  if (State.engine) State.engine.setDrop(State.drop.current);
}


  // FX: opening -> hologram -> dissolve -> remove from canvas
  State.drop.fx.phase = 'opening';
  State.drop.fx.openAtMs = performance.now();
  State.drop.fx.shakePower = 1.15;
  State.drop.fx.shockwaves.push({ t:0, x: drop.world.x, y: drop.world.y });

  setTimeout(()=>{
    if (!State.drop.current) return;
    State.drop.fx.phase = 'hologram';
    State.drop.fx.holoAtMs = performance.now();
    State.drop.fx.shakePower = 0.40;
    pushCanvasMsg('üì° Reward unlocked!');
  }, CONFIG.drop.openingMs || 1100);

  setTimeout(()=>{
    if (!State.drop.current) return;
    State.drop.fx.phase = 'dissolve';
    State.drop.fx.doneAtMs = performance.now();
    State.drop.fx.shakePower = 0.12;
  }, (CONFIG.drop.openingMs||1100) + (CONFIG.drop.hologramMs||1200));

  setTimeout(()=>{
    // remove immediately from canvas/state (as you requested)
    State.drop.current = null;
    State.drop.serverKey = '';
    if (State.engine) State.engine.setDrop(null);
    State.drop.fx.phase = 'idle';
    State.drop.fx.particles = [];
    State.drop.fx.shockwaves = [];
  }, (CONFIG.drop.openingMs||1100) + (CONFIG.drop.hologramMs||1200) + (CONFIG.drop.dissolveMs||650));
}


    // ------------------------------------------------------------
    // SNAPSHOTS / POLLING (NO SSE)
    // ------------------------------------------------------------
    async function fetchGlobalSnapshot(){
      if (State.net.busySnapshot) return;
      State.net.busySnapshot = true;
    
      const t0 = performance.now();
      try {
        const [expRes, recentRes, logRes, dropRes] = await Promise.all([
          Api.post('/2all_expeditions', {}, CONFIG.snapshotTimeoutMs),
          Api.get('/2recent_expeditions', CONFIG.recentTimeoutMs),
          Api.get('/2global_log', CONFIG.recentTimeoutMs),
          Api.get(ACTIVE_DROP_API_PATH, CONFIG.recentTimeoutMs),
        ]);
    
        // ---------------------------
        // 1) ALL EXPEDITIONS SNAPSHOT
        // ---------------------------
        if (expRes.ok && expRes.data){
          // backend now returns { drop:{...}, expeditions:[...], goblins:[...] , ... }
          const snap = expRes.data;
    
          // ‚úÖ FIX: read "expeditions" first (your backend shape)
          const exps = pickArrayFromPayload(snap, 'expeditions', 'items', 'active_expeditions');
    
          const snapAt = Date.now();
          State.globalExpeditions = exps.map(e => (e && typeof e === 'object')
            ? Object.assign({}, e, { _snapAt: snapAt })
            : e
          );
    
          // optional: if you ever want to use goblins list globally
          State.runtime.lastSnapshotGoblins = pickArrayFromPayload(snap, 'goblins');
    
          if (State.engine) State.engine.syncExpeditions(State.globalExpeditions);
          renderGlobalPanel();
          ensureGlobalTimers();
          recalcMyExpeditionFlagAndUI();
        }
    
        // ---------------------------
        // 2) RECENT EXPEDITIONS
        // ---------------------------
        if (recentRes.ok && recentRes.data){
          // support: array OR {items:[...]} OR {recent:[...]} OR {expeditions:[...]}
          const arr = pickArrayFromPayload(recentRes.data, 'items', 'recent', 'expeditions');
          State.recentExpeditions = arr;
          renderRecentPanel();
        }
    
        // ---------------------------
        // 3) GLOBAL LOG
        // ---------------------------
        if (logRes && logRes.ok && logRes.data){
          // support: array OR {items:[...]} OR {events:[...]} OR {log:[...]}
          const logArr = pickArrayFromPayload(logRes.data, 'items', 'events', 'log');
          State.globalLogEvents = logArr;
          if (State.runtime?.ticker) State.runtime.ticker.idx = 0;

        }
    
        // ---------------------------
        // 4) ACTIVE DROP
        // ---------------------------
        if (dropRes && dropRes.ok && dropRes.data) {
          // support: {drop:{...}} OR direct drop object
          const raw = (dropRes.data && typeof dropRes.data === 'object' && 'drop' in dropRes.data)
            ? dropRes.data.drop
            : dropRes.data;
    
          const normalized = normalizeDrop(raw);
          const nextKey = normalized ? (normalized.event_id || normalized.drop_id) : ''; 
          const prevKey = State.drop.serverKey || '';
          State.drop.current = normalized;
          State.drop.serverKey = nextKey;
    
          if (normalized && nextKey && nextKey !== prevKey) {
            State.drop.fx.phase = 'visible';
            State.drop.fx.startedAtMs = performance.now();
            State.drop.fx.pulsePhase = 0;
            State.drop.fx.shakePower = 0.65;
            State.drop.fx.particles = [];
            State.drop.fx.shockwaves = [];
            pushCanvasMsg(`üéÅ A chest has appeared!`);
          }
    
          if (!normalized && prevKey) {
            State.drop.fx.phase = 'idle';
            State.drop.fx.particles = [];
            State.drop.fx.shockwaves = [];
          }
    
          if (State.engine) State.engine.setDrop(normalized);
        }
    
        updateTicker();
    
        const latency = Math.round(performance.now() - t0);
        if (State.ui.latency) State.ui.latency.textContent = `${latency} ms ¬∑ synced`;
      } catch {
        // ignore
      } finally {
        State.net.busySnapshot = false;
      }
    }
    function setPollingInterval(ms){
      const v = clamp(ms, 2500, 60000);
      if (State.net.pollMs === v && State.net.pollTimer) return;
      State.net.pollMs = v;
      stopPolling();
      State.net.pollTimer = setInterval(fetchGlobalSnapshot, State.net.pollMs);
    }
    function startPolling(){ setPollingInterval(State.net.pollMs || CONFIG.pollIntervalMs); }
    function stopPolling(){
      if (State.net.pollTimer){
        clearInterval(State.net.pollTimer);
        State.net.pollTimer = null;
      }
    }

    // ------------------------------------------------------------
    // MOUNT
    // ------------------------------------------------------------
    function mount(){
      if (State.mounted) return;
      State.mounted = true;

      State.ui.canvas = document.getElementById('game-canvas');
      State.ui.latency = document.getElementById('latency-label');
      State.ui.ticker = document.getElementById('ticker-line');

      State.ui.toastHost = document.getElementById('toast-host');
      State.ui.listHost = document.getElementById('goblin-list');
      State.ui.summaryCount = document.getElementById('sel-count');
      State.ui.summaryStats = document.getElementById('sel-stats');

      State.ui.fltSearch = document.getElementById('flt-search');
      State.ui.fltRarity = document.getElementById('flt-rarity');
      State.ui.fltPower = document.getElementById('flt-power');
      State.ui.fltPowerLabel = document.getElementById('flt-power-label');

      State.ui.btnFirst = document.getElementById('qs-first');
      State.ui.btnBest  = document.getElementById('qs-best');
      State.ui.btnClear = document.getElementById('qs-clear');
      State.ui.btnToggleMore = document.getElementById('btn-toggle-more');

      State.ui.btnStart = document.getElementById('btn-start');
      State.ui.btnCopyOverlay = document.getElementById('btn-copy-overlay');

      State.ui.capLabel = document.getElementById('cap-label');
      State.ui.reinfLabel = document.getElementById('reinf-label');

      State.ui.durationSelect = document.getElementById('sel-duration');
      State.ui.durationHint = document.getElementById('duration-hint');

      State.ui.globalList = document.getElementById('global-list');
      State.ui.globalCount = document.getElementById('global-count');
      State.ui.recentList = document.getElementById('recent-list');

      State.ui.goblinStatCount   = document.getElementById('stat-goblins-count');
      State.ui.goblinStatTotal   = document.getElementById('stat-goblins-power-total');
      State.ui.goblinStatAvg     = document.getElementById('stat-goblins-power-avg');
      State.ui.goblinStatUpdated = document.getElementById('stat-goblins-updated');
      State.ui.btnLoadGoblins    = document.getElementById('btn-load-goblins');
      // staking tab elements
      State.ui.stakingHost = document.getElementById('staking-host');
      State.ui.stakingAccount = document.getElementById('staking-account');
      State.ui.stakingStartedAt = document.getElementById('staking-started-at');
      State.ui.stakingCache = document.getElementById('staking-cache');
      State.ui.btnStakingRefresh = document.getElementById('btn-staking-refresh');
      State.ui.btnStakingCopy = document.getElementById('btn-staking-copy');

      applyOverlayMode();
      setTabsBehavior();

      wireBuilderUI();
      updateCapUI();
      initDurationSwitch();
      mountBuilderControls();

      setBuilderEnabled(false);      // finch√© non carichi i goblin
      updateGoblinGlobalStats();     // 0,0,0 all'inizio
      updateActionButtonsUI();
      scheduleForecastIfReady();     // mostra solo messaggio ‚ÄúLoad your goblins‚Ä¶‚Äù

      if (State.ui.btnStart) State.ui.btnStart.onclick = sendExpedition;
      if (State.ui.btnCopyOverlay) State.ui.btnCopyOverlay.onclick = ()=>{
        const url = new URL(window.location.href);
        url.searchParams.set('overlay','1');
        const text = url.toString();
        if (navigator.clipboard?.writeText){
          navigator.clipboard.writeText(text)
            .then(()=>toast('Overlay link copied'))
            .catch(()=>{ prompt('Copy overlay link:', text); });
        } else {
          prompt('Copy overlay link:', text);
        }
      };

      if (State.ui.btnLoadGoblins) {
        State.ui.btnLoadGoblins.onclick = fetchUserNFTs;
      }
      if (State.ui.btnStakingRefresh){
        State.ui.btnStakingRefresh.onclick = ()=> fetchAndRenderStakingReport({force:true});
      }
      if (State.ui.btnStakingCopy){
        State.ui.btnStakingCopy.onclick = ()=>{
          try{
            const wax = (State.user.wax_account || '').trim().toLowerCase();
            const cachedRaw = localStorage.getItem(stakingCacheKey(wax));
            const cached = cachedRaw ? JSON.parse(cachedRaw) : null;
            const data = cached?.report || null;
        
            if (!data){
              toast('No staking report loaded yet.');
              return;
            }
        
            const ptsNum = Number(data?.grand_totals?.points) || 0;
            const pct = clamp(Math.floor(Math.max(0, ptsNum) / 10), 0, 100);
            const mult = (1 + pct/100);
        
            // Conta posizioni/pool totali
            const venues = data?.venues || {};
            const venueNames = Object.keys(venues);
            let pools = 0;
            for (const name of venueNames){
              const rows = Array.isArray(venues[name]?.rows) ? venues[name].rows : [];
              pools += rows.length;
            }
        
            const text =
        `Staking bonus for ${wax}
        Bonus per expedition: +${pct}% (x${mult.toFixed(2)} CHIPS)
        Total points: ${ptsNum}
        Open pools: ${pools} across ${venueNames.length} venues
        Generated (UTC): ${data?.started_at_utc || '‚Äî'}
        
        Tip: Add more liquidity to your staking pools to increase points ‚Üí increase bonus %.`;
        
            if (navigator.clipboard?.writeText){
              navigator.clipboard.writeText(text)
                .then(()=>toast('Copied staking bonus summary'))
                .catch(()=>prompt('Copy staking bonus summary:', text));
            } else {
              prompt('Copy staking bonus summary:', text);
            }
          } catch {
            toast('Could not copy summary.');
          }
        };
      }

      State.engine = new GameEngine(State.ui.canvas);
      loadAssets().then(()=> State.engine && State.engine.handleResize());
      State.engine.start();

      fetchGlobalSnapshot();
      startPolling();
// ‚úÖ ticker rotator: cambia evento ogni 2 secondi
if (State.runtime?.ticker?.timer) clearInterval(State.runtime.ticker.timer);
State.runtime.ticker.timer = setInterval(() => {
  const list = State.globalLogEvents || [];
  if (!list.length) return;
  State.runtime.ticker.idx = (State.runtime.ticker.idx + 1) % list.length;
  updateTicker();
}, 2000);

      window.addEventListener('orientationchange', ()=>{
        State.engine && State.engine.handleResize();
      }, { passive:true });
    }

    if (!window.GOBLIN_DEX_NO_AUTO_MOUNT) mount();
    window.GoblinDex = { mount };
  })();
  </script>

  <script>
  (function () {
    function applyGlow(el, e){
      const r = el.getBoundingClientRect();
      const x = ((e.clientX - r.left) / Math.max(1, r.width)) * 100;
      el.style.setProperty('--mx', x + '%');
    }

    document.addEventListener('mousemove', (e) => {
      const el = e.target.closest(
        '#goblin-list button[role="checkbox"], #quick-select button, #action-buttons button, #tabs button[role="tab"], #btn-load-goblins'
      );
      if (!el) return;
      applyGlow(el, e);
    }, { passive:true });
  })();
  </script>
</body>
</html>
